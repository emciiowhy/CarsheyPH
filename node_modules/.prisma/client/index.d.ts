
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Dealership
 * 
 */
export type Dealership = $Result.DefaultSelection<Prisma.$DealershipPayload>
/**
 * Model Branch
 * 
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model BranchInventory
 * 
 */
export type BranchInventory = $Result.DefaultSelection<Prisma.$BranchInventoryPayload>
/**
 * Model LoanRate
 * 
 */
export type LoanRate = $Result.DefaultSelection<Prisma.$LoanRatePayload>
/**
 * Model Vehicle
 * 
 */
export type Vehicle = $Result.DefaultSelection<Prisma.$VehiclePayload>
/**
 * Model VehicleImage
 * 
 */
export type VehicleImage = $Result.DefaultSelection<Prisma.$VehicleImagePayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model SavedVehicle
 * 
 */
export type SavedVehicle = $Result.DefaultSelection<Prisma.$SavedVehiclePayload>
/**
 * Model Configuration
 * 
 */
export type Configuration = $Result.DefaultSelection<Prisma.$ConfigurationPayload>
/**
 * Model TestDrive
 * 
 */
export type TestDrive = $Result.DefaultSelection<Prisma.$TestDrivePayload>
/**
 * Model Inquiry
 * 
 */
export type Inquiry = $Result.DefaultSelection<Prisma.$InquiryPayload>
/**
 * Model FinancingApplication
 * 
 */
export type FinancingApplication = $Result.DefaultSelection<Prisma.$FinancingApplicationPayload>
/**
 * Model TradeIn
 * 
 */
export type TradeIn = $Result.DefaultSelection<Prisma.$TradeInPayload>
/**
 * Model Promotion
 * 
 */
export type Promotion = $Result.DefaultSelection<Prisma.$PromotionPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const VehicleStatus: {
  AVAILABLE: 'AVAILABLE',
  RESERVED: 'RESERVED',
  SOLD: 'SOLD',
  COMING_SOON: 'COMING_SOON',
  OUT_OF_STOCK: 'OUT_OF_STOCK'
};

export type VehicleStatus = (typeof VehicleStatus)[keyof typeof VehicleStatus]


export const BookingStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  NO_SHOW: 'NO_SHOW'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const InquiryType: {
  GENERAL: 'GENERAL',
  VEHICLE_INFO: 'VEHICLE_INFO',
  FINANCING: 'FINANCING',
  TEST_DRIVE: 'TEST_DRIVE',
  TRADE_IN: 'TRADE_IN',
  AFTER_SALES: 'AFTER_SALES'
};

export type InquiryType = (typeof InquiryType)[keyof typeof InquiryType]


export const InquiryStatus: {
  NEW: 'NEW',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type InquiryStatus = (typeof InquiryStatus)[keyof typeof InquiryStatus]


export const ApplicationStatus: {
  PENDING: 'PENDING',
  UNDER_REVIEW: 'UNDER_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

export type ApplicationStatus = (typeof ApplicationStatus)[keyof typeof ApplicationStatus]


export const TradeInStatus: {
  PENDING: 'PENDING',
  EVALUATING: 'EVALUATING',
  OFFER_MADE: 'OFFER_MADE',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  COMPLETED: 'COMPLETED'
};

export type TradeInStatus = (typeof TradeInStatus)[keyof typeof TradeInStatus]

}

export type VehicleStatus = $Enums.VehicleStatus

export const VehicleStatus: typeof $Enums.VehicleStatus

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type InquiryType = $Enums.InquiryType

export const InquiryType: typeof $Enums.InquiryType

export type InquiryStatus = $Enums.InquiryStatus

export const InquiryStatus: typeof $Enums.InquiryStatus

export type ApplicationStatus = $Enums.ApplicationStatus

export const ApplicationStatus: typeof $Enums.ApplicationStatus

export type TradeInStatus = $Enums.TradeInStatus

export const TradeInStatus: typeof $Enums.TradeInStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Dealerships
 * const dealerships = await prisma.dealership.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Dealerships
   * const dealerships = await prisma.dealership.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.dealership`: Exposes CRUD operations for the **Dealership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dealerships
    * const dealerships = await prisma.dealership.findMany()
    * ```
    */
  get dealership(): Prisma.DealershipDelegate<ExtArgs>;

  /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs>;

  /**
   * `prisma.branchInventory`: Exposes CRUD operations for the **BranchInventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BranchInventories
    * const branchInventories = await prisma.branchInventory.findMany()
    * ```
    */
  get branchInventory(): Prisma.BranchInventoryDelegate<ExtArgs>;

  /**
   * `prisma.loanRate`: Exposes CRUD operations for the **LoanRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoanRates
    * const loanRates = await prisma.loanRate.findMany()
    * ```
    */
  get loanRate(): Prisma.LoanRateDelegate<ExtArgs>;

  /**
   * `prisma.vehicle`: Exposes CRUD operations for the **Vehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicle.findMany()
    * ```
    */
  get vehicle(): Prisma.VehicleDelegate<ExtArgs>;

  /**
   * `prisma.vehicleImage`: Exposes CRUD operations for the **VehicleImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleImages
    * const vehicleImages = await prisma.vehicleImage.findMany()
    * ```
    */
  get vehicleImage(): Prisma.VehicleImageDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.savedVehicle`: Exposes CRUD operations for the **SavedVehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavedVehicles
    * const savedVehicles = await prisma.savedVehicle.findMany()
    * ```
    */
  get savedVehicle(): Prisma.SavedVehicleDelegate<ExtArgs>;

  /**
   * `prisma.configuration`: Exposes CRUD operations for the **Configuration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configurations
    * const configurations = await prisma.configuration.findMany()
    * ```
    */
  get configuration(): Prisma.ConfigurationDelegate<ExtArgs>;

  /**
   * `prisma.testDrive`: Exposes CRUD operations for the **TestDrive** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestDrives
    * const testDrives = await prisma.testDrive.findMany()
    * ```
    */
  get testDrive(): Prisma.TestDriveDelegate<ExtArgs>;

  /**
   * `prisma.inquiry`: Exposes CRUD operations for the **Inquiry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inquiries
    * const inquiries = await prisma.inquiry.findMany()
    * ```
    */
  get inquiry(): Prisma.InquiryDelegate<ExtArgs>;

  /**
   * `prisma.financingApplication`: Exposes CRUD operations for the **FinancingApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinancingApplications
    * const financingApplications = await prisma.financingApplication.findMany()
    * ```
    */
  get financingApplication(): Prisma.FinancingApplicationDelegate<ExtArgs>;

  /**
   * `prisma.tradeIn`: Exposes CRUD operations for the **TradeIn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TradeIns
    * const tradeIns = await prisma.tradeIn.findMany()
    * ```
    */
  get tradeIn(): Prisma.TradeInDelegate<ExtArgs>;

  /**
   * `prisma.promotion`: Exposes CRUD operations for the **Promotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Promotions
    * const promotions = await prisma.promotion.findMany()
    * ```
    */
  get promotion(): Prisma.PromotionDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Dealership: 'Dealership',
    Branch: 'Branch',
    BranchInventory: 'BranchInventory',
    LoanRate: 'LoanRate',
    Vehicle: 'Vehicle',
    VehicleImage: 'VehicleImage',
    Category: 'Category',
    User: 'User',
    SavedVehicle: 'SavedVehicle',
    Configuration: 'Configuration',
    TestDrive: 'TestDrive',
    Inquiry: 'Inquiry',
    FinancingApplication: 'FinancingApplication',
    TradeIn: 'TradeIn',
    Promotion: 'Promotion',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "dealership" | "branch" | "branchInventory" | "loanRate" | "vehicle" | "vehicleImage" | "category" | "user" | "savedVehicle" | "configuration" | "testDrive" | "inquiry" | "financingApplication" | "tradeIn" | "promotion" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Dealership: {
        payload: Prisma.$DealershipPayload<ExtArgs>
        fields: Prisma.DealershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DealershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DealershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealershipPayload>
          }
          findFirst: {
            args: Prisma.DealershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DealershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealershipPayload>
          }
          findMany: {
            args: Prisma.DealershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealershipPayload>[]
          }
          create: {
            args: Prisma.DealershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealershipPayload>
          }
          createMany: {
            args: Prisma.DealershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DealershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealershipPayload>[]
          }
          delete: {
            args: Prisma.DealershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealershipPayload>
          }
          update: {
            args: Prisma.DealershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealershipPayload>
          }
          deleteMany: {
            args: Prisma.DealershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DealershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DealershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealershipPayload>
          }
          aggregate: {
            args: Prisma.DealershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDealership>
          }
          groupBy: {
            args: Prisma.DealershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<DealershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.DealershipCountArgs<ExtArgs>
            result: $Utils.Optional<DealershipCountAggregateOutputType> | number
          }
        }
      }
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          createMany: {
            args: Prisma.BranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      BranchInventory: {
        payload: Prisma.$BranchInventoryPayload<ExtArgs>
        fields: Prisma.BranchInventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchInventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchInventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchInventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchInventoryPayload>
          }
          findFirst: {
            args: Prisma.BranchInventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchInventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchInventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchInventoryPayload>
          }
          findMany: {
            args: Prisma.BranchInventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchInventoryPayload>[]
          }
          create: {
            args: Prisma.BranchInventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchInventoryPayload>
          }
          createMany: {
            args: Prisma.BranchInventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchInventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchInventoryPayload>[]
          }
          delete: {
            args: Prisma.BranchInventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchInventoryPayload>
          }
          update: {
            args: Prisma.BranchInventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchInventoryPayload>
          }
          deleteMany: {
            args: Prisma.BranchInventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchInventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BranchInventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchInventoryPayload>
          }
          aggregate: {
            args: Prisma.BranchInventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranchInventory>
          }
          groupBy: {
            args: Prisma.BranchInventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchInventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchInventoryCountArgs<ExtArgs>
            result: $Utils.Optional<BranchInventoryCountAggregateOutputType> | number
          }
        }
      }
      LoanRate: {
        payload: Prisma.$LoanRatePayload<ExtArgs>
        fields: Prisma.LoanRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoanRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoanRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanRatePayload>
          }
          findFirst: {
            args: Prisma.LoanRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoanRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanRatePayload>
          }
          findMany: {
            args: Prisma.LoanRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanRatePayload>[]
          }
          create: {
            args: Prisma.LoanRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanRatePayload>
          }
          createMany: {
            args: Prisma.LoanRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoanRateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanRatePayload>[]
          }
          delete: {
            args: Prisma.LoanRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanRatePayload>
          }
          update: {
            args: Prisma.LoanRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanRatePayload>
          }
          deleteMany: {
            args: Prisma.LoanRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoanRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LoanRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanRatePayload>
          }
          aggregate: {
            args: Prisma.LoanRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoanRate>
          }
          groupBy: {
            args: Prisma.LoanRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoanRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoanRateCountArgs<ExtArgs>
            result: $Utils.Optional<LoanRateCountAggregateOutputType> | number
          }
        }
      }
      Vehicle: {
        payload: Prisma.$VehiclePayload<ExtArgs>
        fields: Prisma.VehicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findFirst: {
            args: Prisma.VehicleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findMany: {
            args: Prisma.VehicleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          create: {
            args: Prisma.VehicleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          createMany: {
            args: Prisma.VehicleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          delete: {
            args: Prisma.VehicleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          update: {
            args: Prisma.VehicleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          deleteMany: {
            args: Prisma.VehicleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VehicleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          aggregate: {
            args: Prisma.VehicleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle>
          }
          groupBy: {
            args: Prisma.VehicleGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleCountAggregateOutputType> | number
          }
        }
      }
      VehicleImage: {
        payload: Prisma.$VehicleImagePayload<ExtArgs>
        fields: Prisma.VehicleImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleImagePayload>
          }
          findFirst: {
            args: Prisma.VehicleImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleImagePayload>
          }
          findMany: {
            args: Prisma.VehicleImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleImagePayload>[]
          }
          create: {
            args: Prisma.VehicleImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleImagePayload>
          }
          createMany: {
            args: Prisma.VehicleImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleImagePayload>[]
          }
          delete: {
            args: Prisma.VehicleImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleImagePayload>
          }
          update: {
            args: Prisma.VehicleImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleImagePayload>
          }
          deleteMany: {
            args: Prisma.VehicleImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VehicleImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleImagePayload>
          }
          aggregate: {
            args: Prisma.VehicleImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicleImage>
          }
          groupBy: {
            args: Prisma.VehicleImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleImageCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleImageCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      SavedVehicle: {
        payload: Prisma.$SavedVehiclePayload<ExtArgs>
        fields: Prisma.SavedVehicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SavedVehicleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedVehiclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SavedVehicleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedVehiclePayload>
          }
          findFirst: {
            args: Prisma.SavedVehicleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedVehiclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SavedVehicleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedVehiclePayload>
          }
          findMany: {
            args: Prisma.SavedVehicleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedVehiclePayload>[]
          }
          create: {
            args: Prisma.SavedVehicleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedVehiclePayload>
          }
          createMany: {
            args: Prisma.SavedVehicleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SavedVehicleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedVehiclePayload>[]
          }
          delete: {
            args: Prisma.SavedVehicleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedVehiclePayload>
          }
          update: {
            args: Prisma.SavedVehicleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedVehiclePayload>
          }
          deleteMany: {
            args: Prisma.SavedVehicleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SavedVehicleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SavedVehicleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedVehiclePayload>
          }
          aggregate: {
            args: Prisma.SavedVehicleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSavedVehicle>
          }
          groupBy: {
            args: Prisma.SavedVehicleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SavedVehicleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SavedVehicleCountArgs<ExtArgs>
            result: $Utils.Optional<SavedVehicleCountAggregateOutputType> | number
          }
        }
      }
      Configuration: {
        payload: Prisma.$ConfigurationPayload<ExtArgs>
        fields: Prisma.ConfigurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfigurationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfigurationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          findFirst: {
            args: Prisma.ConfigurationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfigurationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          findMany: {
            args: Prisma.ConfigurationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>[]
          }
          create: {
            args: Prisma.ConfigurationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          createMany: {
            args: Prisma.ConfigurationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConfigurationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>[]
          }
          delete: {
            args: Prisma.ConfigurationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          update: {
            args: Prisma.ConfigurationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          deleteMany: {
            args: Prisma.ConfigurationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfigurationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConfigurationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          aggregate: {
            args: Prisma.ConfigurationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfiguration>
          }
          groupBy: {
            args: Prisma.ConfigurationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigurationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfigurationCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigurationCountAggregateOutputType> | number
          }
        }
      }
      TestDrive: {
        payload: Prisma.$TestDrivePayload<ExtArgs>
        fields: Prisma.TestDriveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestDriveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestDrivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestDriveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestDrivePayload>
          }
          findFirst: {
            args: Prisma.TestDriveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestDrivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestDriveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestDrivePayload>
          }
          findMany: {
            args: Prisma.TestDriveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestDrivePayload>[]
          }
          create: {
            args: Prisma.TestDriveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestDrivePayload>
          }
          createMany: {
            args: Prisma.TestDriveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestDriveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestDrivePayload>[]
          }
          delete: {
            args: Prisma.TestDriveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestDrivePayload>
          }
          update: {
            args: Prisma.TestDriveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestDrivePayload>
          }
          deleteMany: {
            args: Prisma.TestDriveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestDriveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestDriveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestDrivePayload>
          }
          aggregate: {
            args: Prisma.TestDriveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestDrive>
          }
          groupBy: {
            args: Prisma.TestDriveGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestDriveGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestDriveCountArgs<ExtArgs>
            result: $Utils.Optional<TestDriveCountAggregateOutputType> | number
          }
        }
      }
      Inquiry: {
        payload: Prisma.$InquiryPayload<ExtArgs>
        fields: Prisma.InquiryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InquiryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InquiryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          findFirst: {
            args: Prisma.InquiryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InquiryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          findMany: {
            args: Prisma.InquiryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>[]
          }
          create: {
            args: Prisma.InquiryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          createMany: {
            args: Prisma.InquiryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InquiryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>[]
          }
          delete: {
            args: Prisma.InquiryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          update: {
            args: Prisma.InquiryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          deleteMany: {
            args: Prisma.InquiryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InquiryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InquiryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          aggregate: {
            args: Prisma.InquiryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInquiry>
          }
          groupBy: {
            args: Prisma.InquiryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InquiryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InquiryCountArgs<ExtArgs>
            result: $Utils.Optional<InquiryCountAggregateOutputType> | number
          }
        }
      }
      FinancingApplication: {
        payload: Prisma.$FinancingApplicationPayload<ExtArgs>
        fields: Prisma.FinancingApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinancingApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancingApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinancingApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancingApplicationPayload>
          }
          findFirst: {
            args: Prisma.FinancingApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancingApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinancingApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancingApplicationPayload>
          }
          findMany: {
            args: Prisma.FinancingApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancingApplicationPayload>[]
          }
          create: {
            args: Prisma.FinancingApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancingApplicationPayload>
          }
          createMany: {
            args: Prisma.FinancingApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinancingApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancingApplicationPayload>[]
          }
          delete: {
            args: Prisma.FinancingApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancingApplicationPayload>
          }
          update: {
            args: Prisma.FinancingApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancingApplicationPayload>
          }
          deleteMany: {
            args: Prisma.FinancingApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinancingApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FinancingApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancingApplicationPayload>
          }
          aggregate: {
            args: Prisma.FinancingApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancingApplication>
          }
          groupBy: {
            args: Prisma.FinancingApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancingApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinancingApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<FinancingApplicationCountAggregateOutputType> | number
          }
        }
      }
      TradeIn: {
        payload: Prisma.$TradeInPayload<ExtArgs>
        fields: Prisma.TradeInFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TradeInFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeInPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TradeInFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeInPayload>
          }
          findFirst: {
            args: Prisma.TradeInFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeInPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TradeInFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeInPayload>
          }
          findMany: {
            args: Prisma.TradeInFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeInPayload>[]
          }
          create: {
            args: Prisma.TradeInCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeInPayload>
          }
          createMany: {
            args: Prisma.TradeInCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TradeInCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeInPayload>[]
          }
          delete: {
            args: Prisma.TradeInDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeInPayload>
          }
          update: {
            args: Prisma.TradeInUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeInPayload>
          }
          deleteMany: {
            args: Prisma.TradeInDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TradeInUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TradeInUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeInPayload>
          }
          aggregate: {
            args: Prisma.TradeInAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTradeIn>
          }
          groupBy: {
            args: Prisma.TradeInGroupByArgs<ExtArgs>
            result: $Utils.Optional<TradeInGroupByOutputType>[]
          }
          count: {
            args: Prisma.TradeInCountArgs<ExtArgs>
            result: $Utils.Optional<TradeInCountAggregateOutputType> | number
          }
        }
      }
      Promotion: {
        payload: Prisma.$PromotionPayload<ExtArgs>
        fields: Prisma.PromotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findFirst: {
            args: Prisma.PromotionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findMany: {
            args: Prisma.PromotionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          create: {
            args: Prisma.PromotionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          createMany: {
            args: Prisma.PromotionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromotionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          delete: {
            args: Prisma.PromotionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          update: {
            args: Prisma.PromotionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          deleteMany: {
            args: Prisma.PromotionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromotionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          aggregate: {
            args: Prisma.PromotionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotion>
          }
          groupBy: {
            args: Prisma.PromotionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type DealershipCountOutputType
   */

  export type DealershipCountOutputType = {
    branches: number
  }

  export type DealershipCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | DealershipCountOutputTypeCountBranchesArgs
  }

  // Custom InputTypes
  /**
   * DealershipCountOutputType without action
   */
  export type DealershipCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealershipCountOutputType
     */
    select?: DealershipCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DealershipCountOutputType without action
   */
  export type DealershipCountOutputTypeCountBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
  }


  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    inventory: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | BranchCountOutputTypeCountInventoryArgs
  }

  // Custom InputTypes
  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchInventoryWhereInput
  }


  /**
   * Count Type VehicleCountOutputType
   */

  export type VehicleCountOutputType = {
    images: number
    inquiries: number
    testDrives: number
    savedBy: number
    configurations: number
    branchInventory: number
  }

  export type VehicleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | VehicleCountOutputTypeCountImagesArgs
    inquiries?: boolean | VehicleCountOutputTypeCountInquiriesArgs
    testDrives?: boolean | VehicleCountOutputTypeCountTestDrivesArgs
    savedBy?: boolean | VehicleCountOutputTypeCountSavedByArgs
    configurations?: boolean | VehicleCountOutputTypeCountConfigurationsArgs
    branchInventory?: boolean | VehicleCountOutputTypeCountBranchInventoryArgs
  }

  // Custom InputTypes
  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleCountOutputType
     */
    select?: VehicleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleImageWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountInquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountTestDrivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestDriveWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountSavedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedVehicleWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountConfigurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigurationWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountBranchInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchInventoryWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    vehicles: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicles?: boolean | CategoryCountOutputTypeCountVehiclesArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountVehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    savedVehicles: number
    configurations: number
    inquiries: number
    testDrives: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    savedVehicles?: boolean | UserCountOutputTypeCountSavedVehiclesArgs
    configurations?: boolean | UserCountOutputTypeCountConfigurationsArgs
    inquiries?: boolean | UserCountOutputTypeCountInquiriesArgs
    testDrives?: boolean | UserCountOutputTypeCountTestDrivesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSavedVehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedVehicleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConfigurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigurationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTestDrivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestDriveWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Dealership
   */

  export type AggregateDealership = {
    _count: DealershipCountAggregateOutputType | null
    _min: DealershipMinAggregateOutputType | null
    _max: DealershipMaxAggregateOutputType | null
  }

  export type DealershipMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealershipMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealershipCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    website: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DealershipMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    website?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealershipMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    website?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealershipCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    website?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DealershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dealership to aggregate.
     */
    where?: DealershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dealerships to fetch.
     */
    orderBy?: DealershipOrderByWithRelationInput | DealershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DealershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dealerships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dealerships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dealerships
    **/
    _count?: true | DealershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DealershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DealershipMaxAggregateInputType
  }

  export type GetDealershipAggregateType<T extends DealershipAggregateArgs> = {
        [P in keyof T & keyof AggregateDealership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDealership[P]>
      : GetScalarType<T[P], AggregateDealership[P]>
  }




  export type DealershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealershipWhereInput
    orderBy?: DealershipOrderByWithAggregationInput | DealershipOrderByWithAggregationInput[]
    by: DealershipScalarFieldEnum[] | DealershipScalarFieldEnum
    having?: DealershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DealershipCountAggregateInputType | true
    _min?: DealershipMinAggregateInputType
    _max?: DealershipMaxAggregateInputType
  }

  export type DealershipGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    website: string | null
    createdAt: Date
    updatedAt: Date
    _count: DealershipCountAggregateOutputType | null
    _min: DealershipMinAggregateOutputType | null
    _max: DealershipMaxAggregateOutputType | null
  }

  type GetDealershipGroupByPayload<T extends DealershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DealershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DealershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DealershipGroupByOutputType[P]>
            : GetScalarType<T[P], DealershipGroupByOutputType[P]>
        }
      >
    >


  export type DealershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branches?: boolean | Dealership$branchesArgs<ExtArgs>
    _count?: boolean | DealershipCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dealership"]>

  export type DealershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dealership"]>

  export type DealershipSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DealershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | Dealership$branchesArgs<ExtArgs>
    _count?: boolean | DealershipCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DealershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DealershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dealership"
    objects: {
      branches: Prisma.$BranchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      website: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dealership"]>
    composites: {}
  }

  type DealershipGetPayload<S extends boolean | null | undefined | DealershipDefaultArgs> = $Result.GetResult<Prisma.$DealershipPayload, S>

  type DealershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DealershipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DealershipCountAggregateInputType | true
    }

  export interface DealershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dealership'], meta: { name: 'Dealership' } }
    /**
     * Find zero or one Dealership that matches the filter.
     * @param {DealershipFindUniqueArgs} args - Arguments to find a Dealership
     * @example
     * // Get one Dealership
     * const dealership = await prisma.dealership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DealershipFindUniqueArgs>(args: SelectSubset<T, DealershipFindUniqueArgs<ExtArgs>>): Prisma__DealershipClient<$Result.GetResult<Prisma.$DealershipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Dealership that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DealershipFindUniqueOrThrowArgs} args - Arguments to find a Dealership
     * @example
     * // Get one Dealership
     * const dealership = await prisma.dealership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DealershipFindUniqueOrThrowArgs>(args: SelectSubset<T, DealershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DealershipClient<$Result.GetResult<Prisma.$DealershipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Dealership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealershipFindFirstArgs} args - Arguments to find a Dealership
     * @example
     * // Get one Dealership
     * const dealership = await prisma.dealership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DealershipFindFirstArgs>(args?: SelectSubset<T, DealershipFindFirstArgs<ExtArgs>>): Prisma__DealershipClient<$Result.GetResult<Prisma.$DealershipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Dealership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealershipFindFirstOrThrowArgs} args - Arguments to find a Dealership
     * @example
     * // Get one Dealership
     * const dealership = await prisma.dealership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DealershipFindFirstOrThrowArgs>(args?: SelectSubset<T, DealershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__DealershipClient<$Result.GetResult<Prisma.$DealershipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Dealerships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dealerships
     * const dealerships = await prisma.dealership.findMany()
     * 
     * // Get first 10 Dealerships
     * const dealerships = await prisma.dealership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dealershipWithIdOnly = await prisma.dealership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DealershipFindManyArgs>(args?: SelectSubset<T, DealershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealershipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Dealership.
     * @param {DealershipCreateArgs} args - Arguments to create a Dealership.
     * @example
     * // Create one Dealership
     * const Dealership = await prisma.dealership.create({
     *   data: {
     *     // ... data to create a Dealership
     *   }
     * })
     * 
     */
    create<T extends DealershipCreateArgs>(args: SelectSubset<T, DealershipCreateArgs<ExtArgs>>): Prisma__DealershipClient<$Result.GetResult<Prisma.$DealershipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Dealerships.
     * @param {DealershipCreateManyArgs} args - Arguments to create many Dealerships.
     * @example
     * // Create many Dealerships
     * const dealership = await prisma.dealership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DealershipCreateManyArgs>(args?: SelectSubset<T, DealershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dealerships and returns the data saved in the database.
     * @param {DealershipCreateManyAndReturnArgs} args - Arguments to create many Dealerships.
     * @example
     * // Create many Dealerships
     * const dealership = await prisma.dealership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dealerships and only return the `id`
     * const dealershipWithIdOnly = await prisma.dealership.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DealershipCreateManyAndReturnArgs>(args?: SelectSubset<T, DealershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealershipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Dealership.
     * @param {DealershipDeleteArgs} args - Arguments to delete one Dealership.
     * @example
     * // Delete one Dealership
     * const Dealership = await prisma.dealership.delete({
     *   where: {
     *     // ... filter to delete one Dealership
     *   }
     * })
     * 
     */
    delete<T extends DealershipDeleteArgs>(args: SelectSubset<T, DealershipDeleteArgs<ExtArgs>>): Prisma__DealershipClient<$Result.GetResult<Prisma.$DealershipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Dealership.
     * @param {DealershipUpdateArgs} args - Arguments to update one Dealership.
     * @example
     * // Update one Dealership
     * const dealership = await prisma.dealership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DealershipUpdateArgs>(args: SelectSubset<T, DealershipUpdateArgs<ExtArgs>>): Prisma__DealershipClient<$Result.GetResult<Prisma.$DealershipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Dealerships.
     * @param {DealershipDeleteManyArgs} args - Arguments to filter Dealerships to delete.
     * @example
     * // Delete a few Dealerships
     * const { count } = await prisma.dealership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DealershipDeleteManyArgs>(args?: SelectSubset<T, DealershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dealerships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dealerships
     * const dealership = await prisma.dealership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DealershipUpdateManyArgs>(args: SelectSubset<T, DealershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dealership.
     * @param {DealershipUpsertArgs} args - Arguments to update or create a Dealership.
     * @example
     * // Update or create a Dealership
     * const dealership = await prisma.dealership.upsert({
     *   create: {
     *     // ... data to create a Dealership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dealership we want to update
     *   }
     * })
     */
    upsert<T extends DealershipUpsertArgs>(args: SelectSubset<T, DealershipUpsertArgs<ExtArgs>>): Prisma__DealershipClient<$Result.GetResult<Prisma.$DealershipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Dealerships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealershipCountArgs} args - Arguments to filter Dealerships to count.
     * @example
     * // Count the number of Dealerships
     * const count = await prisma.dealership.count({
     *   where: {
     *     // ... the filter for the Dealerships we want to count
     *   }
     * })
    **/
    count<T extends DealershipCountArgs>(
      args?: Subset<T, DealershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DealershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dealership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DealershipAggregateArgs>(args: Subset<T, DealershipAggregateArgs>): Prisma.PrismaPromise<GetDealershipAggregateType<T>>

    /**
     * Group by Dealership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DealershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DealershipGroupByArgs['orderBy'] }
        : { orderBy?: DealershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DealershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDealershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dealership model
   */
  readonly fields: DealershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dealership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DealershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branches<T extends Dealership$branchesArgs<ExtArgs> = {}>(args?: Subset<T, Dealership$branchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dealership model
   */ 
  interface DealershipFieldRefs {
    readonly id: FieldRef<"Dealership", 'String'>
    readonly name: FieldRef<"Dealership", 'String'>
    readonly slug: FieldRef<"Dealership", 'String'>
    readonly description: FieldRef<"Dealership", 'String'>
    readonly website: FieldRef<"Dealership", 'String'>
    readonly createdAt: FieldRef<"Dealership", 'DateTime'>
    readonly updatedAt: FieldRef<"Dealership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dealership findUnique
   */
  export type DealershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealership
     */
    select?: DealershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealershipInclude<ExtArgs> | null
    /**
     * Filter, which Dealership to fetch.
     */
    where: DealershipWhereUniqueInput
  }

  /**
   * Dealership findUniqueOrThrow
   */
  export type DealershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealership
     */
    select?: DealershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealershipInclude<ExtArgs> | null
    /**
     * Filter, which Dealership to fetch.
     */
    where: DealershipWhereUniqueInput
  }

  /**
   * Dealership findFirst
   */
  export type DealershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealership
     */
    select?: DealershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealershipInclude<ExtArgs> | null
    /**
     * Filter, which Dealership to fetch.
     */
    where?: DealershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dealerships to fetch.
     */
    orderBy?: DealershipOrderByWithRelationInput | DealershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dealerships.
     */
    cursor?: DealershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dealerships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dealerships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dealerships.
     */
    distinct?: DealershipScalarFieldEnum | DealershipScalarFieldEnum[]
  }

  /**
   * Dealership findFirstOrThrow
   */
  export type DealershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealership
     */
    select?: DealershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealershipInclude<ExtArgs> | null
    /**
     * Filter, which Dealership to fetch.
     */
    where?: DealershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dealerships to fetch.
     */
    orderBy?: DealershipOrderByWithRelationInput | DealershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dealerships.
     */
    cursor?: DealershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dealerships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dealerships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dealerships.
     */
    distinct?: DealershipScalarFieldEnum | DealershipScalarFieldEnum[]
  }

  /**
   * Dealership findMany
   */
  export type DealershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealership
     */
    select?: DealershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealershipInclude<ExtArgs> | null
    /**
     * Filter, which Dealerships to fetch.
     */
    where?: DealershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dealerships to fetch.
     */
    orderBy?: DealershipOrderByWithRelationInput | DealershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dealerships.
     */
    cursor?: DealershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dealerships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dealerships.
     */
    skip?: number
    distinct?: DealershipScalarFieldEnum | DealershipScalarFieldEnum[]
  }

  /**
   * Dealership create
   */
  export type DealershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealership
     */
    select?: DealershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealershipInclude<ExtArgs> | null
    /**
     * The data needed to create a Dealership.
     */
    data: XOR<DealershipCreateInput, DealershipUncheckedCreateInput>
  }

  /**
   * Dealership createMany
   */
  export type DealershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dealerships.
     */
    data: DealershipCreateManyInput | DealershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dealership createManyAndReturn
   */
  export type DealershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealership
     */
    select?: DealershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Dealerships.
     */
    data: DealershipCreateManyInput | DealershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dealership update
   */
  export type DealershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealership
     */
    select?: DealershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealershipInclude<ExtArgs> | null
    /**
     * The data needed to update a Dealership.
     */
    data: XOR<DealershipUpdateInput, DealershipUncheckedUpdateInput>
    /**
     * Choose, which Dealership to update.
     */
    where: DealershipWhereUniqueInput
  }

  /**
   * Dealership updateMany
   */
  export type DealershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dealerships.
     */
    data: XOR<DealershipUpdateManyMutationInput, DealershipUncheckedUpdateManyInput>
    /**
     * Filter which Dealerships to update
     */
    where?: DealershipWhereInput
  }

  /**
   * Dealership upsert
   */
  export type DealershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealership
     */
    select?: DealershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealershipInclude<ExtArgs> | null
    /**
     * The filter to search for the Dealership to update in case it exists.
     */
    where: DealershipWhereUniqueInput
    /**
     * In case the Dealership found by the `where` argument doesn't exist, create a new Dealership with this data.
     */
    create: XOR<DealershipCreateInput, DealershipUncheckedCreateInput>
    /**
     * In case the Dealership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DealershipUpdateInput, DealershipUncheckedUpdateInput>
  }

  /**
   * Dealership delete
   */
  export type DealershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealership
     */
    select?: DealershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealershipInclude<ExtArgs> | null
    /**
     * Filter which Dealership to delete.
     */
    where: DealershipWhereUniqueInput
  }

  /**
   * Dealership deleteMany
   */
  export type DealershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dealerships to delete
     */
    where?: DealershipWhereInput
  }

  /**
   * Dealership.branches
   */
  export type Dealership$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    cursor?: BranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Dealership without action
   */
  export type DealershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealership
     */
    select?: DealershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealershipInclude<ExtArgs> | null
  }


  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    dealershipId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    dealershipId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phone: number
    email: number
    dealershipId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BranchMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    dealershipId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    dealershipId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    dealershipId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    id: string
    name: string
    address: string
    phone: string | null
    email: string | null
    dealershipId: string
    createdAt: Date
    updatedAt: Date
    _count: BranchCountAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    dealershipId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dealership?: boolean | DealershipDefaultArgs<ExtArgs>
    inventory?: boolean | Branch$inventoryArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    dealershipId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dealership?: boolean | DealershipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    dealershipId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dealership?: boolean | DealershipDefaultArgs<ExtArgs>
    inventory?: boolean | Branch$inventoryArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dealership?: boolean | DealershipDefaultArgs<ExtArgs>
  }

  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      dealership: Prisma.$DealershipPayload<ExtArgs>
      inventory: Prisma.$BranchInventoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      phone: string | null
      email: string | null
      dealershipId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }

  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchFindUniqueArgs>(args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Branch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchFindFirstArgs>(args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchFindManyArgs>(args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
     */
    create<T extends BranchCreateArgs>(args: SelectSubset<T, BranchCreateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Branches.
     * @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchCreateManyArgs>(args?: SelectSubset<T, BranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Branches and returns the data saved in the database.
     * @param {BranchCreateManyAndReturnArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
     */
    delete<T extends BranchDeleteArgs>(args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchUpdateArgs>(args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchDeleteManyArgs>(args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchUpdateManyArgs>(args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
     */
    upsert<T extends BranchUpsertArgs>(args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dealership<T extends DealershipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DealershipDefaultArgs<ExtArgs>>): Prisma__DealershipClient<$Result.GetResult<Prisma.$DealershipPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    inventory<T extends Branch$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Branch$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchInventoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Branch model
   */ 
  interface BranchFieldRefs {
    readonly id: FieldRef<"Branch", 'String'>
    readonly name: FieldRef<"Branch", 'String'>
    readonly address: FieldRef<"Branch", 'String'>
    readonly phone: FieldRef<"Branch", 'String'>
    readonly email: FieldRef<"Branch", 'String'>
    readonly dealershipId: FieldRef<"Branch", 'String'>
    readonly createdAt: FieldRef<"Branch", 'DateTime'>
    readonly updatedAt: FieldRef<"Branch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }

  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch createManyAndReturn
   */
  export type BranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
  }

  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }

  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
  }

  /**
   * Branch.inventory
   */
  export type Branch$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchInventory
     */
    select?: BranchInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInventoryInclude<ExtArgs> | null
    where?: BranchInventoryWhereInput
    orderBy?: BranchInventoryOrderByWithRelationInput | BranchInventoryOrderByWithRelationInput[]
    cursor?: BranchInventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchInventoryScalarFieldEnum | BranchInventoryScalarFieldEnum[]
  }

  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
  }


  /**
   * Model BranchInventory
   */

  export type AggregateBranchInventory = {
    _count: BranchInventoryCountAggregateOutputType | null
    _avg: BranchInventoryAvgAggregateOutputType | null
    _sum: BranchInventorySumAggregateOutputType | null
    _min: BranchInventoryMinAggregateOutputType | null
    _max: BranchInventoryMaxAggregateOutputType | null
  }

  export type BranchInventoryAvgAggregateOutputType = {
    stock: number | null
    price: Decimal | null
  }

  export type BranchInventorySumAggregateOutputType = {
    stock: number | null
    price: Decimal | null
  }

  export type BranchInventoryMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    vehicleId: string | null
    stock: number | null
    price: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchInventoryMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    vehicleId: string | null
    stock: number | null
    price: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchInventoryCountAggregateOutputType = {
    id: number
    branchId: number
    vehicleId: number
    stock: number
    price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BranchInventoryAvgAggregateInputType = {
    stock?: true
    price?: true
  }

  export type BranchInventorySumAggregateInputType = {
    stock?: true
    price?: true
  }

  export type BranchInventoryMinAggregateInputType = {
    id?: true
    branchId?: true
    vehicleId?: true
    stock?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchInventoryMaxAggregateInputType = {
    id?: true
    branchId?: true
    vehicleId?: true
    stock?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchInventoryCountAggregateInputType = {
    id?: true
    branchId?: true
    vehicleId?: true
    stock?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BranchInventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BranchInventory to aggregate.
     */
    where?: BranchInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchInventories to fetch.
     */
    orderBy?: BranchInventoryOrderByWithRelationInput | BranchInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BranchInventories
    **/
    _count?: true | BranchInventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BranchInventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BranchInventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchInventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchInventoryMaxAggregateInputType
  }

  export type GetBranchInventoryAggregateType<T extends BranchInventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBranchInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranchInventory[P]>
      : GetScalarType<T[P], AggregateBranchInventory[P]>
  }




  export type BranchInventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchInventoryWhereInput
    orderBy?: BranchInventoryOrderByWithAggregationInput | BranchInventoryOrderByWithAggregationInput[]
    by: BranchInventoryScalarFieldEnum[] | BranchInventoryScalarFieldEnum
    having?: BranchInventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchInventoryCountAggregateInputType | true
    _avg?: BranchInventoryAvgAggregateInputType
    _sum?: BranchInventorySumAggregateInputType
    _min?: BranchInventoryMinAggregateInputType
    _max?: BranchInventoryMaxAggregateInputType
  }

  export type BranchInventoryGroupByOutputType = {
    id: string
    branchId: string
    vehicleId: string
    stock: number
    price: Decimal
    createdAt: Date
    updatedAt: Date
    _count: BranchInventoryCountAggregateOutputType | null
    _avg: BranchInventoryAvgAggregateOutputType | null
    _sum: BranchInventorySumAggregateOutputType | null
    _min: BranchInventoryMinAggregateOutputType | null
    _max: BranchInventoryMaxAggregateOutputType | null
  }

  type GetBranchInventoryGroupByPayload<T extends BranchInventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchInventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchInventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchInventoryGroupByOutputType[P]>
            : GetScalarType<T[P], BranchInventoryGroupByOutputType[P]>
        }
      >
    >


  export type BranchInventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    vehicleId?: boolean
    stock?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branchInventory"]>

  export type BranchInventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    vehicleId?: boolean
    stock?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branchInventory"]>

  export type BranchInventorySelectScalar = {
    id?: boolean
    branchId?: boolean
    vehicleId?: boolean
    stock?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BranchInventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }
  export type BranchInventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }

  export type $BranchInventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BranchInventory"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      vehicle: Prisma.$VehiclePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      vehicleId: string
      stock: number
      price: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["branchInventory"]>
    composites: {}
  }

  type BranchInventoryGetPayload<S extends boolean | null | undefined | BranchInventoryDefaultArgs> = $Result.GetResult<Prisma.$BranchInventoryPayload, S>

  type BranchInventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BranchInventoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BranchInventoryCountAggregateInputType | true
    }

  export interface BranchInventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BranchInventory'], meta: { name: 'BranchInventory' } }
    /**
     * Find zero or one BranchInventory that matches the filter.
     * @param {BranchInventoryFindUniqueArgs} args - Arguments to find a BranchInventory
     * @example
     * // Get one BranchInventory
     * const branchInventory = await prisma.branchInventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchInventoryFindUniqueArgs>(args: SelectSubset<T, BranchInventoryFindUniqueArgs<ExtArgs>>): Prisma__BranchInventoryClient<$Result.GetResult<Prisma.$BranchInventoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BranchInventory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BranchInventoryFindUniqueOrThrowArgs} args - Arguments to find a BranchInventory
     * @example
     * // Get one BranchInventory
     * const branchInventory = await prisma.branchInventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchInventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchInventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchInventoryClient<$Result.GetResult<Prisma.$BranchInventoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BranchInventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchInventoryFindFirstArgs} args - Arguments to find a BranchInventory
     * @example
     * // Get one BranchInventory
     * const branchInventory = await prisma.branchInventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchInventoryFindFirstArgs>(args?: SelectSubset<T, BranchInventoryFindFirstArgs<ExtArgs>>): Prisma__BranchInventoryClient<$Result.GetResult<Prisma.$BranchInventoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BranchInventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchInventoryFindFirstOrThrowArgs} args - Arguments to find a BranchInventory
     * @example
     * // Get one BranchInventory
     * const branchInventory = await prisma.branchInventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchInventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchInventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchInventoryClient<$Result.GetResult<Prisma.$BranchInventoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BranchInventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchInventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BranchInventories
     * const branchInventories = await prisma.branchInventory.findMany()
     * 
     * // Get first 10 BranchInventories
     * const branchInventories = await prisma.branchInventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchInventoryWithIdOnly = await prisma.branchInventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchInventoryFindManyArgs>(args?: SelectSubset<T, BranchInventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchInventoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BranchInventory.
     * @param {BranchInventoryCreateArgs} args - Arguments to create a BranchInventory.
     * @example
     * // Create one BranchInventory
     * const BranchInventory = await prisma.branchInventory.create({
     *   data: {
     *     // ... data to create a BranchInventory
     *   }
     * })
     * 
     */
    create<T extends BranchInventoryCreateArgs>(args: SelectSubset<T, BranchInventoryCreateArgs<ExtArgs>>): Prisma__BranchInventoryClient<$Result.GetResult<Prisma.$BranchInventoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BranchInventories.
     * @param {BranchInventoryCreateManyArgs} args - Arguments to create many BranchInventories.
     * @example
     * // Create many BranchInventories
     * const branchInventory = await prisma.branchInventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchInventoryCreateManyArgs>(args?: SelectSubset<T, BranchInventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BranchInventories and returns the data saved in the database.
     * @param {BranchInventoryCreateManyAndReturnArgs} args - Arguments to create many BranchInventories.
     * @example
     * // Create many BranchInventories
     * const branchInventory = await prisma.branchInventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BranchInventories and only return the `id`
     * const branchInventoryWithIdOnly = await prisma.branchInventory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchInventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchInventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchInventoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BranchInventory.
     * @param {BranchInventoryDeleteArgs} args - Arguments to delete one BranchInventory.
     * @example
     * // Delete one BranchInventory
     * const BranchInventory = await prisma.branchInventory.delete({
     *   where: {
     *     // ... filter to delete one BranchInventory
     *   }
     * })
     * 
     */
    delete<T extends BranchInventoryDeleteArgs>(args: SelectSubset<T, BranchInventoryDeleteArgs<ExtArgs>>): Prisma__BranchInventoryClient<$Result.GetResult<Prisma.$BranchInventoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BranchInventory.
     * @param {BranchInventoryUpdateArgs} args - Arguments to update one BranchInventory.
     * @example
     * // Update one BranchInventory
     * const branchInventory = await prisma.branchInventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchInventoryUpdateArgs>(args: SelectSubset<T, BranchInventoryUpdateArgs<ExtArgs>>): Prisma__BranchInventoryClient<$Result.GetResult<Prisma.$BranchInventoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BranchInventories.
     * @param {BranchInventoryDeleteManyArgs} args - Arguments to filter BranchInventories to delete.
     * @example
     * // Delete a few BranchInventories
     * const { count } = await prisma.branchInventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchInventoryDeleteManyArgs>(args?: SelectSubset<T, BranchInventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BranchInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchInventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BranchInventories
     * const branchInventory = await prisma.branchInventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchInventoryUpdateManyArgs>(args: SelectSubset<T, BranchInventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BranchInventory.
     * @param {BranchInventoryUpsertArgs} args - Arguments to update or create a BranchInventory.
     * @example
     * // Update or create a BranchInventory
     * const branchInventory = await prisma.branchInventory.upsert({
     *   create: {
     *     // ... data to create a BranchInventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BranchInventory we want to update
     *   }
     * })
     */
    upsert<T extends BranchInventoryUpsertArgs>(args: SelectSubset<T, BranchInventoryUpsertArgs<ExtArgs>>): Prisma__BranchInventoryClient<$Result.GetResult<Prisma.$BranchInventoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BranchInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchInventoryCountArgs} args - Arguments to filter BranchInventories to count.
     * @example
     * // Count the number of BranchInventories
     * const count = await prisma.branchInventory.count({
     *   where: {
     *     // ... the filter for the BranchInventories we want to count
     *   }
     * })
    **/
    count<T extends BranchInventoryCountArgs>(
      args?: Subset<T, BranchInventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchInventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BranchInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchInventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchInventoryAggregateArgs>(args: Subset<T, BranchInventoryAggregateArgs>): Prisma.PrismaPromise<GetBranchInventoryAggregateType<T>>

    /**
     * Group by BranchInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchInventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchInventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchInventoryGroupByArgs['orderBy'] }
        : { orderBy?: BranchInventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchInventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BranchInventory model
   */
  readonly fields: BranchInventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BranchInventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchInventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BranchInventory model
   */ 
  interface BranchInventoryFieldRefs {
    readonly id: FieldRef<"BranchInventory", 'String'>
    readonly branchId: FieldRef<"BranchInventory", 'String'>
    readonly vehicleId: FieldRef<"BranchInventory", 'String'>
    readonly stock: FieldRef<"BranchInventory", 'Int'>
    readonly price: FieldRef<"BranchInventory", 'Decimal'>
    readonly createdAt: FieldRef<"BranchInventory", 'DateTime'>
    readonly updatedAt: FieldRef<"BranchInventory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BranchInventory findUnique
   */
  export type BranchInventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchInventory
     */
    select?: BranchInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInventoryInclude<ExtArgs> | null
    /**
     * Filter, which BranchInventory to fetch.
     */
    where: BranchInventoryWhereUniqueInput
  }

  /**
   * BranchInventory findUniqueOrThrow
   */
  export type BranchInventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchInventory
     */
    select?: BranchInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInventoryInclude<ExtArgs> | null
    /**
     * Filter, which BranchInventory to fetch.
     */
    where: BranchInventoryWhereUniqueInput
  }

  /**
   * BranchInventory findFirst
   */
  export type BranchInventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchInventory
     */
    select?: BranchInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInventoryInclude<ExtArgs> | null
    /**
     * Filter, which BranchInventory to fetch.
     */
    where?: BranchInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchInventories to fetch.
     */
    orderBy?: BranchInventoryOrderByWithRelationInput | BranchInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BranchInventories.
     */
    cursor?: BranchInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BranchInventories.
     */
    distinct?: BranchInventoryScalarFieldEnum | BranchInventoryScalarFieldEnum[]
  }

  /**
   * BranchInventory findFirstOrThrow
   */
  export type BranchInventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchInventory
     */
    select?: BranchInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInventoryInclude<ExtArgs> | null
    /**
     * Filter, which BranchInventory to fetch.
     */
    where?: BranchInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchInventories to fetch.
     */
    orderBy?: BranchInventoryOrderByWithRelationInput | BranchInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BranchInventories.
     */
    cursor?: BranchInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BranchInventories.
     */
    distinct?: BranchInventoryScalarFieldEnum | BranchInventoryScalarFieldEnum[]
  }

  /**
   * BranchInventory findMany
   */
  export type BranchInventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchInventory
     */
    select?: BranchInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInventoryInclude<ExtArgs> | null
    /**
     * Filter, which BranchInventories to fetch.
     */
    where?: BranchInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchInventories to fetch.
     */
    orderBy?: BranchInventoryOrderByWithRelationInput | BranchInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BranchInventories.
     */
    cursor?: BranchInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchInventories.
     */
    skip?: number
    distinct?: BranchInventoryScalarFieldEnum | BranchInventoryScalarFieldEnum[]
  }

  /**
   * BranchInventory create
   */
  export type BranchInventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchInventory
     */
    select?: BranchInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a BranchInventory.
     */
    data: XOR<BranchInventoryCreateInput, BranchInventoryUncheckedCreateInput>
  }

  /**
   * BranchInventory createMany
   */
  export type BranchInventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BranchInventories.
     */
    data: BranchInventoryCreateManyInput | BranchInventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BranchInventory createManyAndReturn
   */
  export type BranchInventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchInventory
     */
    select?: BranchInventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BranchInventories.
     */
    data: BranchInventoryCreateManyInput | BranchInventoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInventoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BranchInventory update
   */
  export type BranchInventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchInventory
     */
    select?: BranchInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a BranchInventory.
     */
    data: XOR<BranchInventoryUpdateInput, BranchInventoryUncheckedUpdateInput>
    /**
     * Choose, which BranchInventory to update.
     */
    where: BranchInventoryWhereUniqueInput
  }

  /**
   * BranchInventory updateMany
   */
  export type BranchInventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BranchInventories.
     */
    data: XOR<BranchInventoryUpdateManyMutationInput, BranchInventoryUncheckedUpdateManyInput>
    /**
     * Filter which BranchInventories to update
     */
    where?: BranchInventoryWhereInput
  }

  /**
   * BranchInventory upsert
   */
  export type BranchInventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchInventory
     */
    select?: BranchInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the BranchInventory to update in case it exists.
     */
    where: BranchInventoryWhereUniqueInput
    /**
     * In case the BranchInventory found by the `where` argument doesn't exist, create a new BranchInventory with this data.
     */
    create: XOR<BranchInventoryCreateInput, BranchInventoryUncheckedCreateInput>
    /**
     * In case the BranchInventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchInventoryUpdateInput, BranchInventoryUncheckedUpdateInput>
  }

  /**
   * BranchInventory delete
   */
  export type BranchInventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchInventory
     */
    select?: BranchInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInventoryInclude<ExtArgs> | null
    /**
     * Filter which BranchInventory to delete.
     */
    where: BranchInventoryWhereUniqueInput
  }

  /**
   * BranchInventory deleteMany
   */
  export type BranchInventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BranchInventories to delete
     */
    where?: BranchInventoryWhereInput
  }

  /**
   * BranchInventory without action
   */
  export type BranchInventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchInventory
     */
    select?: BranchInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInventoryInclude<ExtArgs> | null
  }


  /**
   * Model LoanRate
   */

  export type AggregateLoanRate = {
    _count: LoanRateCountAggregateOutputType | null
    _avg: LoanRateAvgAggregateOutputType | null
    _sum: LoanRateSumAggregateOutputType | null
    _min: LoanRateMinAggregateOutputType | null
    _max: LoanRateMaxAggregateOutputType | null
  }

  export type LoanRateAvgAggregateOutputType = {
    annualRate: Decimal | null
    minTermMonths: number | null
    maxTermMonths: number | null
  }

  export type LoanRateSumAggregateOutputType = {
    annualRate: Decimal | null
    minTermMonths: number | null
    maxTermMonths: number | null
  }

  export type LoanRateMinAggregateOutputType = {
    id: string | null
    bankName: string | null
    annualRate: Decimal | null
    minTermMonths: number | null
    maxTermMonths: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanRateMaxAggregateOutputType = {
    id: string | null
    bankName: string | null
    annualRate: Decimal | null
    minTermMonths: number | null
    maxTermMonths: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanRateCountAggregateOutputType = {
    id: number
    bankName: number
    annualRate: number
    minTermMonths: number
    maxTermMonths: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoanRateAvgAggregateInputType = {
    annualRate?: true
    minTermMonths?: true
    maxTermMonths?: true
  }

  export type LoanRateSumAggregateInputType = {
    annualRate?: true
    minTermMonths?: true
    maxTermMonths?: true
  }

  export type LoanRateMinAggregateInputType = {
    id?: true
    bankName?: true
    annualRate?: true
    minTermMonths?: true
    maxTermMonths?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanRateMaxAggregateInputType = {
    id?: true
    bankName?: true
    annualRate?: true
    minTermMonths?: true
    maxTermMonths?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanRateCountAggregateInputType = {
    id?: true
    bankName?: true
    annualRate?: true
    minTermMonths?: true
    maxTermMonths?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoanRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanRate to aggregate.
     */
    where?: LoanRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanRates to fetch.
     */
    orderBy?: LoanRateOrderByWithRelationInput | LoanRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoanRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoanRates
    **/
    _count?: true | LoanRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoanRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoanRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoanRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoanRateMaxAggregateInputType
  }

  export type GetLoanRateAggregateType<T extends LoanRateAggregateArgs> = {
        [P in keyof T & keyof AggregateLoanRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoanRate[P]>
      : GetScalarType<T[P], AggregateLoanRate[P]>
  }




  export type LoanRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanRateWhereInput
    orderBy?: LoanRateOrderByWithAggregationInput | LoanRateOrderByWithAggregationInput[]
    by: LoanRateScalarFieldEnum[] | LoanRateScalarFieldEnum
    having?: LoanRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoanRateCountAggregateInputType | true
    _avg?: LoanRateAvgAggregateInputType
    _sum?: LoanRateSumAggregateInputType
    _min?: LoanRateMinAggregateInputType
    _max?: LoanRateMaxAggregateInputType
  }

  export type LoanRateGroupByOutputType = {
    id: string
    bankName: string
    annualRate: Decimal
    minTermMonths: number
    maxTermMonths: number
    createdAt: Date
    updatedAt: Date
    _count: LoanRateCountAggregateOutputType | null
    _avg: LoanRateAvgAggregateOutputType | null
    _sum: LoanRateSumAggregateOutputType | null
    _min: LoanRateMinAggregateOutputType | null
    _max: LoanRateMaxAggregateOutputType | null
  }

  type GetLoanRateGroupByPayload<T extends LoanRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoanRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoanRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoanRateGroupByOutputType[P]>
            : GetScalarType<T[P], LoanRateGroupByOutputType[P]>
        }
      >
    >


  export type LoanRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankName?: boolean
    annualRate?: boolean
    minTermMonths?: boolean
    maxTermMonths?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["loanRate"]>

  export type LoanRateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankName?: boolean
    annualRate?: boolean
    minTermMonths?: boolean
    maxTermMonths?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["loanRate"]>

  export type LoanRateSelectScalar = {
    id?: boolean
    bankName?: boolean
    annualRate?: boolean
    minTermMonths?: boolean
    maxTermMonths?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $LoanRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoanRate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bankName: string
      annualRate: Prisma.Decimal
      minTermMonths: number
      maxTermMonths: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["loanRate"]>
    composites: {}
  }

  type LoanRateGetPayload<S extends boolean | null | undefined | LoanRateDefaultArgs> = $Result.GetResult<Prisma.$LoanRatePayload, S>

  type LoanRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LoanRateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LoanRateCountAggregateInputType | true
    }

  export interface LoanRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoanRate'], meta: { name: 'LoanRate' } }
    /**
     * Find zero or one LoanRate that matches the filter.
     * @param {LoanRateFindUniqueArgs} args - Arguments to find a LoanRate
     * @example
     * // Get one LoanRate
     * const loanRate = await prisma.loanRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoanRateFindUniqueArgs>(args: SelectSubset<T, LoanRateFindUniqueArgs<ExtArgs>>): Prisma__LoanRateClient<$Result.GetResult<Prisma.$LoanRatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LoanRate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LoanRateFindUniqueOrThrowArgs} args - Arguments to find a LoanRate
     * @example
     * // Get one LoanRate
     * const loanRate = await prisma.loanRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoanRateFindUniqueOrThrowArgs>(args: SelectSubset<T, LoanRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoanRateClient<$Result.GetResult<Prisma.$LoanRatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LoanRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanRateFindFirstArgs} args - Arguments to find a LoanRate
     * @example
     * // Get one LoanRate
     * const loanRate = await prisma.loanRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoanRateFindFirstArgs>(args?: SelectSubset<T, LoanRateFindFirstArgs<ExtArgs>>): Prisma__LoanRateClient<$Result.GetResult<Prisma.$LoanRatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LoanRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanRateFindFirstOrThrowArgs} args - Arguments to find a LoanRate
     * @example
     * // Get one LoanRate
     * const loanRate = await prisma.loanRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoanRateFindFirstOrThrowArgs>(args?: SelectSubset<T, LoanRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoanRateClient<$Result.GetResult<Prisma.$LoanRatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LoanRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoanRates
     * const loanRates = await prisma.loanRate.findMany()
     * 
     * // Get first 10 LoanRates
     * const loanRates = await prisma.loanRate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loanRateWithIdOnly = await prisma.loanRate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoanRateFindManyArgs>(args?: SelectSubset<T, LoanRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanRatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LoanRate.
     * @param {LoanRateCreateArgs} args - Arguments to create a LoanRate.
     * @example
     * // Create one LoanRate
     * const LoanRate = await prisma.loanRate.create({
     *   data: {
     *     // ... data to create a LoanRate
     *   }
     * })
     * 
     */
    create<T extends LoanRateCreateArgs>(args: SelectSubset<T, LoanRateCreateArgs<ExtArgs>>): Prisma__LoanRateClient<$Result.GetResult<Prisma.$LoanRatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LoanRates.
     * @param {LoanRateCreateManyArgs} args - Arguments to create many LoanRates.
     * @example
     * // Create many LoanRates
     * const loanRate = await prisma.loanRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoanRateCreateManyArgs>(args?: SelectSubset<T, LoanRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoanRates and returns the data saved in the database.
     * @param {LoanRateCreateManyAndReturnArgs} args - Arguments to create many LoanRates.
     * @example
     * // Create many LoanRates
     * const loanRate = await prisma.loanRate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoanRates and only return the `id`
     * const loanRateWithIdOnly = await prisma.loanRate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoanRateCreateManyAndReturnArgs>(args?: SelectSubset<T, LoanRateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanRatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LoanRate.
     * @param {LoanRateDeleteArgs} args - Arguments to delete one LoanRate.
     * @example
     * // Delete one LoanRate
     * const LoanRate = await prisma.loanRate.delete({
     *   where: {
     *     // ... filter to delete one LoanRate
     *   }
     * })
     * 
     */
    delete<T extends LoanRateDeleteArgs>(args: SelectSubset<T, LoanRateDeleteArgs<ExtArgs>>): Prisma__LoanRateClient<$Result.GetResult<Prisma.$LoanRatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LoanRate.
     * @param {LoanRateUpdateArgs} args - Arguments to update one LoanRate.
     * @example
     * // Update one LoanRate
     * const loanRate = await prisma.loanRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoanRateUpdateArgs>(args: SelectSubset<T, LoanRateUpdateArgs<ExtArgs>>): Prisma__LoanRateClient<$Result.GetResult<Prisma.$LoanRatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LoanRates.
     * @param {LoanRateDeleteManyArgs} args - Arguments to filter LoanRates to delete.
     * @example
     * // Delete a few LoanRates
     * const { count } = await prisma.loanRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoanRateDeleteManyArgs>(args?: SelectSubset<T, LoanRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoanRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoanRates
     * const loanRate = await prisma.loanRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoanRateUpdateManyArgs>(args: SelectSubset<T, LoanRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LoanRate.
     * @param {LoanRateUpsertArgs} args - Arguments to update or create a LoanRate.
     * @example
     * // Update or create a LoanRate
     * const loanRate = await prisma.loanRate.upsert({
     *   create: {
     *     // ... data to create a LoanRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoanRate we want to update
     *   }
     * })
     */
    upsert<T extends LoanRateUpsertArgs>(args: SelectSubset<T, LoanRateUpsertArgs<ExtArgs>>): Prisma__LoanRateClient<$Result.GetResult<Prisma.$LoanRatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LoanRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanRateCountArgs} args - Arguments to filter LoanRates to count.
     * @example
     * // Count the number of LoanRates
     * const count = await prisma.loanRate.count({
     *   where: {
     *     // ... the filter for the LoanRates we want to count
     *   }
     * })
    **/
    count<T extends LoanRateCountArgs>(
      args?: Subset<T, LoanRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoanRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoanRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoanRateAggregateArgs>(args: Subset<T, LoanRateAggregateArgs>): Prisma.PrismaPromise<GetLoanRateAggregateType<T>>

    /**
     * Group by LoanRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoanRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoanRateGroupByArgs['orderBy'] }
        : { orderBy?: LoanRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoanRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoanRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoanRate model
   */
  readonly fields: LoanRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoanRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoanRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoanRate model
   */ 
  interface LoanRateFieldRefs {
    readonly id: FieldRef<"LoanRate", 'String'>
    readonly bankName: FieldRef<"LoanRate", 'String'>
    readonly annualRate: FieldRef<"LoanRate", 'Decimal'>
    readonly minTermMonths: FieldRef<"LoanRate", 'Int'>
    readonly maxTermMonths: FieldRef<"LoanRate", 'Int'>
    readonly createdAt: FieldRef<"LoanRate", 'DateTime'>
    readonly updatedAt: FieldRef<"LoanRate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoanRate findUnique
   */
  export type LoanRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanRate
     */
    select?: LoanRateSelect<ExtArgs> | null
    /**
     * Filter, which LoanRate to fetch.
     */
    where: LoanRateWhereUniqueInput
  }

  /**
   * LoanRate findUniqueOrThrow
   */
  export type LoanRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanRate
     */
    select?: LoanRateSelect<ExtArgs> | null
    /**
     * Filter, which LoanRate to fetch.
     */
    where: LoanRateWhereUniqueInput
  }

  /**
   * LoanRate findFirst
   */
  export type LoanRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanRate
     */
    select?: LoanRateSelect<ExtArgs> | null
    /**
     * Filter, which LoanRate to fetch.
     */
    where?: LoanRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanRates to fetch.
     */
    orderBy?: LoanRateOrderByWithRelationInput | LoanRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanRates.
     */
    cursor?: LoanRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanRates.
     */
    distinct?: LoanRateScalarFieldEnum | LoanRateScalarFieldEnum[]
  }

  /**
   * LoanRate findFirstOrThrow
   */
  export type LoanRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanRate
     */
    select?: LoanRateSelect<ExtArgs> | null
    /**
     * Filter, which LoanRate to fetch.
     */
    where?: LoanRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanRates to fetch.
     */
    orderBy?: LoanRateOrderByWithRelationInput | LoanRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanRates.
     */
    cursor?: LoanRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanRates.
     */
    distinct?: LoanRateScalarFieldEnum | LoanRateScalarFieldEnum[]
  }

  /**
   * LoanRate findMany
   */
  export type LoanRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanRate
     */
    select?: LoanRateSelect<ExtArgs> | null
    /**
     * Filter, which LoanRates to fetch.
     */
    where?: LoanRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanRates to fetch.
     */
    orderBy?: LoanRateOrderByWithRelationInput | LoanRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoanRates.
     */
    cursor?: LoanRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanRates.
     */
    skip?: number
    distinct?: LoanRateScalarFieldEnum | LoanRateScalarFieldEnum[]
  }

  /**
   * LoanRate create
   */
  export type LoanRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanRate
     */
    select?: LoanRateSelect<ExtArgs> | null
    /**
     * The data needed to create a LoanRate.
     */
    data: XOR<LoanRateCreateInput, LoanRateUncheckedCreateInput>
  }

  /**
   * LoanRate createMany
   */
  export type LoanRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoanRates.
     */
    data: LoanRateCreateManyInput | LoanRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoanRate createManyAndReturn
   */
  export type LoanRateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanRate
     */
    select?: LoanRateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LoanRates.
     */
    data: LoanRateCreateManyInput | LoanRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoanRate update
   */
  export type LoanRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanRate
     */
    select?: LoanRateSelect<ExtArgs> | null
    /**
     * The data needed to update a LoanRate.
     */
    data: XOR<LoanRateUpdateInput, LoanRateUncheckedUpdateInput>
    /**
     * Choose, which LoanRate to update.
     */
    where: LoanRateWhereUniqueInput
  }

  /**
   * LoanRate updateMany
   */
  export type LoanRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoanRates.
     */
    data: XOR<LoanRateUpdateManyMutationInput, LoanRateUncheckedUpdateManyInput>
    /**
     * Filter which LoanRates to update
     */
    where?: LoanRateWhereInput
  }

  /**
   * LoanRate upsert
   */
  export type LoanRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanRate
     */
    select?: LoanRateSelect<ExtArgs> | null
    /**
     * The filter to search for the LoanRate to update in case it exists.
     */
    where: LoanRateWhereUniqueInput
    /**
     * In case the LoanRate found by the `where` argument doesn't exist, create a new LoanRate with this data.
     */
    create: XOR<LoanRateCreateInput, LoanRateUncheckedCreateInput>
    /**
     * In case the LoanRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoanRateUpdateInput, LoanRateUncheckedUpdateInput>
  }

  /**
   * LoanRate delete
   */
  export type LoanRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanRate
     */
    select?: LoanRateSelect<ExtArgs> | null
    /**
     * Filter which LoanRate to delete.
     */
    where: LoanRateWhereUniqueInput
  }

  /**
   * LoanRate deleteMany
   */
  export type LoanRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanRates to delete
     */
    where?: LoanRateWhereInput
  }

  /**
   * LoanRate without action
   */
  export type LoanRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanRate
     */
    select?: LoanRateSelect<ExtArgs> | null
  }


  /**
   * Model Vehicle
   */

  export type AggregateVehicle = {
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  export type VehicleAvgAggregateOutputType = {
    year: number | null
    cashPrice: Decimal | null
    downPayment: Decimal | null
    monthlyPayment: Decimal | null
    leaseTerm: number | null
    horsepower: number | null
    seatingCapacity: number | null
    stockCount: number | null
  }

  export type VehicleSumAggregateOutputType = {
    year: number | null
    cashPrice: Decimal | null
    downPayment: Decimal | null
    monthlyPayment: Decimal | null
    leaseTerm: number | null
    horsepower: number | null
    seatingCapacity: number | null
    stockCount: number | null
  }

  export type VehicleMinAggregateOutputType = {
    id: string | null
    slug: string | null
    brand: string | null
    model: string | null
    year: number | null
    variant: string | null
    cashPrice: Decimal | null
    downPayment: Decimal | null
    monthlyPayment: Decimal | null
    leaseTerm: number | null
    transmission: string | null
    fuelType: string | null
    engineSize: string | null
    horsepower: number | null
    seatingCapacity: number | null
    cargoSpace: string | null
    description: string | null
    model3dUrl: string | null
    thumbnailUrl: string | null
    status: $Enums.VehicleStatus | null
    availability: string | null
    featured: boolean | null
    stockCount: number | null
    metaTitle: string | null
    metaDescription: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    brand: string | null
    model: string | null
    year: number | null
    variant: string | null
    cashPrice: Decimal | null
    downPayment: Decimal | null
    monthlyPayment: Decimal | null
    leaseTerm: number | null
    transmission: string | null
    fuelType: string | null
    engineSize: string | null
    horsepower: number | null
    seatingCapacity: number | null
    cargoSpace: string | null
    description: string | null
    model3dUrl: string | null
    thumbnailUrl: string | null
    status: $Enums.VehicleStatus | null
    availability: string | null
    featured: boolean | null
    stockCount: number | null
    metaTitle: string | null
    metaDescription: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleCountAggregateOutputType = {
    id: number
    slug: number
    brand: number
    model: number
    year: number
    variant: number
    cashPrice: number
    downPayment: number
    monthlyPayment: number
    leaseTerm: number
    transmission: number
    fuelType: number
    engineSize: number
    horsepower: number
    seatingCapacity: number
    cargoSpace: number
    features: number
    specifications: number
    description: number
    videos: number
    model3dUrl: number
    thumbnailUrl: number
    status: number
    availability: number
    featured: number
    stockCount: number
    metaTitle: number
    metaDescription: number
    categoryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VehicleAvgAggregateInputType = {
    year?: true
    cashPrice?: true
    downPayment?: true
    monthlyPayment?: true
    leaseTerm?: true
    horsepower?: true
    seatingCapacity?: true
    stockCount?: true
  }

  export type VehicleSumAggregateInputType = {
    year?: true
    cashPrice?: true
    downPayment?: true
    monthlyPayment?: true
    leaseTerm?: true
    horsepower?: true
    seatingCapacity?: true
    stockCount?: true
  }

  export type VehicleMinAggregateInputType = {
    id?: true
    slug?: true
    brand?: true
    model?: true
    year?: true
    variant?: true
    cashPrice?: true
    downPayment?: true
    monthlyPayment?: true
    leaseTerm?: true
    transmission?: true
    fuelType?: true
    engineSize?: true
    horsepower?: true
    seatingCapacity?: true
    cargoSpace?: true
    description?: true
    model3dUrl?: true
    thumbnailUrl?: true
    status?: true
    availability?: true
    featured?: true
    stockCount?: true
    metaTitle?: true
    metaDescription?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleMaxAggregateInputType = {
    id?: true
    slug?: true
    brand?: true
    model?: true
    year?: true
    variant?: true
    cashPrice?: true
    downPayment?: true
    monthlyPayment?: true
    leaseTerm?: true
    transmission?: true
    fuelType?: true
    engineSize?: true
    horsepower?: true
    seatingCapacity?: true
    cargoSpace?: true
    description?: true
    model3dUrl?: true
    thumbnailUrl?: true
    status?: true
    availability?: true
    featured?: true
    stockCount?: true
    metaTitle?: true
    metaDescription?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleCountAggregateInputType = {
    id?: true
    slug?: true
    brand?: true
    model?: true
    year?: true
    variant?: true
    cashPrice?: true
    downPayment?: true
    monthlyPayment?: true
    leaseTerm?: true
    transmission?: true
    fuelType?: true
    engineSize?: true
    horsepower?: true
    seatingCapacity?: true
    cargoSpace?: true
    features?: true
    specifications?: true
    description?: true
    videos?: true
    model3dUrl?: true
    thumbnailUrl?: true
    status?: true
    availability?: true
    featured?: true
    stockCount?: true
    metaTitle?: true
    metaDescription?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VehicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicle to aggregate.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vehicles
    **/
    _count?: true | VehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleMaxAggregateInputType
  }

  export type GetVehicleAggregateType<T extends VehicleAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle[P]>
      : GetScalarType<T[P], AggregateVehicle[P]>
  }




  export type VehicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithAggregationInput | VehicleOrderByWithAggregationInput[]
    by: VehicleScalarFieldEnum[] | VehicleScalarFieldEnum
    having?: VehicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleCountAggregateInputType | true
    _avg?: VehicleAvgAggregateInputType
    _sum?: VehicleSumAggregateInputType
    _min?: VehicleMinAggregateInputType
    _max?: VehicleMaxAggregateInputType
  }

  export type VehicleGroupByOutputType = {
    id: string
    slug: string
    brand: string
    model: string
    year: number
    variant: string | null
    cashPrice: Decimal
    downPayment: Decimal
    monthlyPayment: Decimal
    leaseTerm: number
    transmission: string
    fuelType: string
    engineSize: string | null
    horsepower: number | null
    seatingCapacity: number
    cargoSpace: string | null
    features: JsonValue
    specifications: JsonValue
    description: string | null
    videos: string[]
    model3dUrl: string | null
    thumbnailUrl: string
    status: $Enums.VehicleStatus
    availability: string
    featured: boolean
    stockCount: number
    metaTitle: string | null
    metaDescription: string | null
    categoryId: string
    createdAt: Date
    updatedAt: Date
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  type GetVehicleGroupByPayload<T extends VehicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleGroupByOutputType[P]>
        }
      >
    >


  export type VehicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    brand?: boolean
    model?: boolean
    year?: boolean
    variant?: boolean
    cashPrice?: boolean
    downPayment?: boolean
    monthlyPayment?: boolean
    leaseTerm?: boolean
    transmission?: boolean
    fuelType?: boolean
    engineSize?: boolean
    horsepower?: boolean
    seatingCapacity?: boolean
    cargoSpace?: boolean
    features?: boolean
    specifications?: boolean
    description?: boolean
    videos?: boolean
    model3dUrl?: boolean
    thumbnailUrl?: boolean
    status?: boolean
    availability?: boolean
    featured?: boolean
    stockCount?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    images?: boolean | Vehicle$imagesArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    inquiries?: boolean | Vehicle$inquiriesArgs<ExtArgs>
    testDrives?: boolean | Vehicle$testDrivesArgs<ExtArgs>
    savedBy?: boolean | Vehicle$savedByArgs<ExtArgs>
    configurations?: boolean | Vehicle$configurationsArgs<ExtArgs>
    branchInventory?: boolean | Vehicle$branchInventoryArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    brand?: boolean
    model?: boolean
    year?: boolean
    variant?: boolean
    cashPrice?: boolean
    downPayment?: boolean
    monthlyPayment?: boolean
    leaseTerm?: boolean
    transmission?: boolean
    fuelType?: boolean
    engineSize?: boolean
    horsepower?: boolean
    seatingCapacity?: boolean
    cargoSpace?: boolean
    features?: boolean
    specifications?: boolean
    description?: boolean
    videos?: boolean
    model3dUrl?: boolean
    thumbnailUrl?: boolean
    status?: boolean
    availability?: boolean
    featured?: boolean
    stockCount?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectScalar = {
    id?: boolean
    slug?: boolean
    brand?: boolean
    model?: boolean
    year?: boolean
    variant?: boolean
    cashPrice?: boolean
    downPayment?: boolean
    monthlyPayment?: boolean
    leaseTerm?: boolean
    transmission?: boolean
    fuelType?: boolean
    engineSize?: boolean
    horsepower?: boolean
    seatingCapacity?: boolean
    cargoSpace?: boolean
    features?: boolean
    specifications?: boolean
    description?: boolean
    videos?: boolean
    model3dUrl?: boolean
    thumbnailUrl?: boolean
    status?: boolean
    availability?: boolean
    featured?: boolean
    stockCount?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VehicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | Vehicle$imagesArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    inquiries?: boolean | Vehicle$inquiriesArgs<ExtArgs>
    testDrives?: boolean | Vehicle$testDrivesArgs<ExtArgs>
    savedBy?: boolean | Vehicle$savedByArgs<ExtArgs>
    configurations?: boolean | Vehicle$configurationsArgs<ExtArgs>
    branchInventory?: boolean | Vehicle$branchInventoryArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $VehiclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vehicle"
    objects: {
      images: Prisma.$VehicleImagePayload<ExtArgs>[]
      category: Prisma.$CategoryPayload<ExtArgs>
      inquiries: Prisma.$InquiryPayload<ExtArgs>[]
      testDrives: Prisma.$TestDrivePayload<ExtArgs>[]
      savedBy: Prisma.$SavedVehiclePayload<ExtArgs>[]
      configurations: Prisma.$ConfigurationPayload<ExtArgs>[]
      branchInventory: Prisma.$BranchInventoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      brand: string
      model: string
      year: number
      variant: string | null
      cashPrice: Prisma.Decimal
      downPayment: Prisma.Decimal
      monthlyPayment: Prisma.Decimal
      leaseTerm: number
      transmission: string
      fuelType: string
      engineSize: string | null
      horsepower: number | null
      seatingCapacity: number
      cargoSpace: string | null
      features: Prisma.JsonValue
      specifications: Prisma.JsonValue
      description: string | null
      videos: string[]
      model3dUrl: string | null
      thumbnailUrl: string
      status: $Enums.VehicleStatus
      availability: string
      featured: boolean
      stockCount: number
      metaTitle: string | null
      metaDescription: string | null
      categoryId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vehicle"]>
    composites: {}
  }

  type VehicleGetPayload<S extends boolean | null | undefined | VehicleDefaultArgs> = $Result.GetResult<Prisma.$VehiclePayload, S>

  type VehicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VehicleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VehicleCountAggregateInputType | true
    }

  export interface VehicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vehicle'], meta: { name: 'Vehicle' } }
    /**
     * Find zero or one Vehicle that matches the filter.
     * @param {VehicleFindUniqueArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleFindUniqueArgs>(args: SelectSubset<T, VehicleFindUniqueArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vehicle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VehicleFindUniqueOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleFindFirstArgs>(args?: SelectSubset<T, VehicleFindFirstArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicle.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleFindManyArgs>(args?: SelectSubset<T, VehicleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vehicle.
     * @param {VehicleCreateArgs} args - Arguments to create a Vehicle.
     * @example
     * // Create one Vehicle
     * const Vehicle = await prisma.vehicle.create({
     *   data: {
     *     // ... data to create a Vehicle
     *   }
     * })
     * 
     */
    create<T extends VehicleCreateArgs>(args: SelectSubset<T, VehicleCreateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Vehicles.
     * @param {VehicleCreateManyArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleCreateManyArgs>(args?: SelectSubset<T, VehicleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicles and returns the data saved in the database.
     * @param {VehicleCreateManyAndReturnArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicles and only return the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Vehicle.
     * @param {VehicleDeleteArgs} args - Arguments to delete one Vehicle.
     * @example
     * // Delete one Vehicle
     * const Vehicle = await prisma.vehicle.delete({
     *   where: {
     *     // ... filter to delete one Vehicle
     *   }
     * })
     * 
     */
    delete<T extends VehicleDeleteArgs>(args: SelectSubset<T, VehicleDeleteArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vehicle.
     * @param {VehicleUpdateArgs} args - Arguments to update one Vehicle.
     * @example
     * // Update one Vehicle
     * const vehicle = await prisma.vehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleUpdateArgs>(args: SelectSubset<T, VehicleUpdateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Vehicles.
     * @param {VehicleDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleDeleteManyArgs>(args?: SelectSubset<T, VehicleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleUpdateManyArgs>(args: SelectSubset<T, VehicleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicle.
     * @param {VehicleUpsertArgs} args - Arguments to update or create a Vehicle.
     * @example
     * // Update or create a Vehicle
     * const vehicle = await prisma.vehicle.upsert({
     *   create: {
     *     // ... data to create a Vehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle we want to update
     *   }
     * })
     */
    upsert<T extends VehicleUpsertArgs>(args: SelectSubset<T, VehicleUpsertArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicle.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends VehicleCountArgs>(
      args?: Subset<T, VehicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleAggregateArgs>(args: Subset<T, VehicleAggregateArgs>): Prisma.PrismaPromise<GetVehicleAggregateType<T>>

    /**
     * Group by Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleGroupByArgs['orderBy'] }
        : { orderBy?: VehicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vehicle model
   */
  readonly fields: VehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    images<T extends Vehicle$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "findMany"> | Null>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    inquiries<T extends Vehicle$inquiriesArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$inquiriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findMany"> | Null>
    testDrives<T extends Vehicle$testDrivesArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$testDrivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestDrivePayload<ExtArgs>, T, "findMany"> | Null>
    savedBy<T extends Vehicle$savedByArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$savedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedVehiclePayload<ExtArgs>, T, "findMany"> | Null>
    configurations<T extends Vehicle$configurationsArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$configurationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findMany"> | Null>
    branchInventory<T extends Vehicle$branchInventoryArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$branchInventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchInventoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vehicle model
   */ 
  interface VehicleFieldRefs {
    readonly id: FieldRef<"Vehicle", 'String'>
    readonly slug: FieldRef<"Vehicle", 'String'>
    readonly brand: FieldRef<"Vehicle", 'String'>
    readonly model: FieldRef<"Vehicle", 'String'>
    readonly year: FieldRef<"Vehicle", 'Int'>
    readonly variant: FieldRef<"Vehicle", 'String'>
    readonly cashPrice: FieldRef<"Vehicle", 'Decimal'>
    readonly downPayment: FieldRef<"Vehicle", 'Decimal'>
    readonly monthlyPayment: FieldRef<"Vehicle", 'Decimal'>
    readonly leaseTerm: FieldRef<"Vehicle", 'Int'>
    readonly transmission: FieldRef<"Vehicle", 'String'>
    readonly fuelType: FieldRef<"Vehicle", 'String'>
    readonly engineSize: FieldRef<"Vehicle", 'String'>
    readonly horsepower: FieldRef<"Vehicle", 'Int'>
    readonly seatingCapacity: FieldRef<"Vehicle", 'Int'>
    readonly cargoSpace: FieldRef<"Vehicle", 'String'>
    readonly features: FieldRef<"Vehicle", 'Json'>
    readonly specifications: FieldRef<"Vehicle", 'Json'>
    readonly description: FieldRef<"Vehicle", 'String'>
    readonly videos: FieldRef<"Vehicle", 'String[]'>
    readonly model3dUrl: FieldRef<"Vehicle", 'String'>
    readonly thumbnailUrl: FieldRef<"Vehicle", 'String'>
    readonly status: FieldRef<"Vehicle", 'VehicleStatus'>
    readonly availability: FieldRef<"Vehicle", 'String'>
    readonly featured: FieldRef<"Vehicle", 'Boolean'>
    readonly stockCount: FieldRef<"Vehicle", 'Int'>
    readonly metaTitle: FieldRef<"Vehicle", 'String'>
    readonly metaDescription: FieldRef<"Vehicle", 'String'>
    readonly categoryId: FieldRef<"Vehicle", 'String'>
    readonly createdAt: FieldRef<"Vehicle", 'DateTime'>
    readonly updatedAt: FieldRef<"Vehicle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vehicle findUnique
   */
  export type VehicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findUniqueOrThrow
   */
  export type VehicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findFirst
   */
  export type VehicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findFirstOrThrow
   */
  export type VehicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findMany
   */
  export type VehicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicles to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle create
   */
  export type VehicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to create a Vehicle.
     */
    data: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
  }

  /**
   * Vehicle createMany
   */
  export type VehicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vehicle createManyAndReturn
   */
  export type VehicleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vehicle update
   */
  export type VehicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to update a Vehicle.
     */
    data: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
    /**
     * Choose, which Vehicle to update.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle updateMany
   */
  export type VehicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
  }

  /**
   * Vehicle upsert
   */
  export type VehicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The filter to search for the Vehicle to update in case it exists.
     */
    where: VehicleWhereUniqueInput
    /**
     * In case the Vehicle found by the `where` argument doesn't exist, create a new Vehicle with this data.
     */
    create: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
    /**
     * In case the Vehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
  }

  /**
   * Vehicle delete
   */
  export type VehicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter which Vehicle to delete.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle deleteMany
   */
  export type VehicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicles to delete
     */
    where?: VehicleWhereInput
  }

  /**
   * Vehicle.images
   */
  export type Vehicle$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
    where?: VehicleImageWhereInput
    orderBy?: VehicleImageOrderByWithRelationInput | VehicleImageOrderByWithRelationInput[]
    cursor?: VehicleImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleImageScalarFieldEnum | VehicleImageScalarFieldEnum[]
  }

  /**
   * Vehicle.inquiries
   */
  export type Vehicle$inquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    where?: InquiryWhereInput
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    cursor?: InquiryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Vehicle.testDrives
   */
  export type Vehicle$testDrivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestDrive
     */
    select?: TestDriveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestDriveInclude<ExtArgs> | null
    where?: TestDriveWhereInput
    orderBy?: TestDriveOrderByWithRelationInput | TestDriveOrderByWithRelationInput[]
    cursor?: TestDriveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestDriveScalarFieldEnum | TestDriveScalarFieldEnum[]
  }

  /**
   * Vehicle.savedBy
   */
  export type Vehicle$savedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedVehicle
     */
    select?: SavedVehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedVehicleInclude<ExtArgs> | null
    where?: SavedVehicleWhereInput
    orderBy?: SavedVehicleOrderByWithRelationInput | SavedVehicleOrderByWithRelationInput[]
    cursor?: SavedVehicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedVehicleScalarFieldEnum | SavedVehicleScalarFieldEnum[]
  }

  /**
   * Vehicle.configurations
   */
  export type Vehicle$configurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
    where?: ConfigurationWhereInput
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    cursor?: ConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }

  /**
   * Vehicle.branchInventory
   */
  export type Vehicle$branchInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchInventory
     */
    select?: BranchInventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInventoryInclude<ExtArgs> | null
    where?: BranchInventoryWhereInput
    orderBy?: BranchInventoryOrderByWithRelationInput | BranchInventoryOrderByWithRelationInput[]
    cursor?: BranchInventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchInventoryScalarFieldEnum | BranchInventoryScalarFieldEnum[]
  }

  /**
   * Vehicle without action
   */
  export type VehicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
  }


  /**
   * Model VehicleImage
   */

  export type AggregateVehicleImage = {
    _count: VehicleImageCountAggregateOutputType | null
    _avg: VehicleImageAvgAggregateOutputType | null
    _sum: VehicleImageSumAggregateOutputType | null
    _min: VehicleImageMinAggregateOutputType | null
    _max: VehicleImageMaxAggregateOutputType | null
  }

  export type VehicleImageAvgAggregateOutputType = {
    order: number | null
  }

  export type VehicleImageSumAggregateOutputType = {
    order: number | null
  }

  export type VehicleImageMinAggregateOutputType = {
    id: string | null
    url: string | null
    alt: string | null
    type: string | null
    order: number | null
    vehicleId: string | null
  }

  export type VehicleImageMaxAggregateOutputType = {
    id: string | null
    url: string | null
    alt: string | null
    type: string | null
    order: number | null
    vehicleId: string | null
  }

  export type VehicleImageCountAggregateOutputType = {
    id: number
    url: number
    alt: number
    type: number
    order: number
    vehicleId: number
    _all: number
  }


  export type VehicleImageAvgAggregateInputType = {
    order?: true
  }

  export type VehicleImageSumAggregateInputType = {
    order?: true
  }

  export type VehicleImageMinAggregateInputType = {
    id?: true
    url?: true
    alt?: true
    type?: true
    order?: true
    vehicleId?: true
  }

  export type VehicleImageMaxAggregateInputType = {
    id?: true
    url?: true
    alt?: true
    type?: true
    order?: true
    vehicleId?: true
  }

  export type VehicleImageCountAggregateInputType = {
    id?: true
    url?: true
    alt?: true
    type?: true
    order?: true
    vehicleId?: true
    _all?: true
  }

  export type VehicleImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleImage to aggregate.
     */
    where?: VehicleImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleImages to fetch.
     */
    orderBy?: VehicleImageOrderByWithRelationInput | VehicleImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleImages
    **/
    _count?: true | VehicleImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleImageMaxAggregateInputType
  }

  export type GetVehicleImageAggregateType<T extends VehicleImageAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicleImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicleImage[P]>
      : GetScalarType<T[P], AggregateVehicleImage[P]>
  }




  export type VehicleImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleImageWhereInput
    orderBy?: VehicleImageOrderByWithAggregationInput | VehicleImageOrderByWithAggregationInput[]
    by: VehicleImageScalarFieldEnum[] | VehicleImageScalarFieldEnum
    having?: VehicleImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleImageCountAggregateInputType | true
    _avg?: VehicleImageAvgAggregateInputType
    _sum?: VehicleImageSumAggregateInputType
    _min?: VehicleImageMinAggregateInputType
    _max?: VehicleImageMaxAggregateInputType
  }

  export type VehicleImageGroupByOutputType = {
    id: string
    url: string
    alt: string
    type: string
    order: number
    vehicleId: string
    _count: VehicleImageCountAggregateOutputType | null
    _avg: VehicleImageAvgAggregateOutputType | null
    _sum: VehicleImageSumAggregateOutputType | null
    _min: VehicleImageMinAggregateOutputType | null
    _max: VehicleImageMaxAggregateOutputType | null
  }

  type GetVehicleImageGroupByPayload<T extends VehicleImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleImageGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleImageGroupByOutputType[P]>
        }
      >
    >


  export type VehicleImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    alt?: boolean
    type?: boolean
    order?: boolean
    vehicleId?: boolean
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleImage"]>

  export type VehicleImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    alt?: boolean
    type?: boolean
    order?: boolean
    vehicleId?: boolean
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleImage"]>

  export type VehicleImageSelectScalar = {
    id?: boolean
    url?: boolean
    alt?: boolean
    type?: boolean
    order?: boolean
    vehicleId?: boolean
  }

  export type VehicleImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }
  export type VehicleImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }

  export type $VehicleImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehicleImage"
    objects: {
      vehicle: Prisma.$VehiclePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      alt: string
      type: string
      order: number
      vehicleId: string
    }, ExtArgs["result"]["vehicleImage"]>
    composites: {}
  }

  type VehicleImageGetPayload<S extends boolean | null | undefined | VehicleImageDefaultArgs> = $Result.GetResult<Prisma.$VehicleImagePayload, S>

  type VehicleImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VehicleImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VehicleImageCountAggregateInputType | true
    }

  export interface VehicleImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehicleImage'], meta: { name: 'VehicleImage' } }
    /**
     * Find zero or one VehicleImage that matches the filter.
     * @param {VehicleImageFindUniqueArgs} args - Arguments to find a VehicleImage
     * @example
     * // Get one VehicleImage
     * const vehicleImage = await prisma.vehicleImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleImageFindUniqueArgs>(args: SelectSubset<T, VehicleImageFindUniqueArgs<ExtArgs>>): Prisma__VehicleImageClient<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VehicleImage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VehicleImageFindUniqueOrThrowArgs} args - Arguments to find a VehicleImage
     * @example
     * // Get one VehicleImage
     * const vehicleImage = await prisma.vehicleImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleImageFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleImageClient<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VehicleImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleImageFindFirstArgs} args - Arguments to find a VehicleImage
     * @example
     * // Get one VehicleImage
     * const vehicleImage = await prisma.vehicleImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleImageFindFirstArgs>(args?: SelectSubset<T, VehicleImageFindFirstArgs<ExtArgs>>): Prisma__VehicleImageClient<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VehicleImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleImageFindFirstOrThrowArgs} args - Arguments to find a VehicleImage
     * @example
     * // Get one VehicleImage
     * const vehicleImage = await prisma.vehicleImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleImageFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleImageClient<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VehicleImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleImages
     * const vehicleImages = await prisma.vehicleImage.findMany()
     * 
     * // Get first 10 VehicleImages
     * const vehicleImages = await prisma.vehicleImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleImageWithIdOnly = await prisma.vehicleImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleImageFindManyArgs>(args?: SelectSubset<T, VehicleImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VehicleImage.
     * @param {VehicleImageCreateArgs} args - Arguments to create a VehicleImage.
     * @example
     * // Create one VehicleImage
     * const VehicleImage = await prisma.vehicleImage.create({
     *   data: {
     *     // ... data to create a VehicleImage
     *   }
     * })
     * 
     */
    create<T extends VehicleImageCreateArgs>(args: SelectSubset<T, VehicleImageCreateArgs<ExtArgs>>): Prisma__VehicleImageClient<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VehicleImages.
     * @param {VehicleImageCreateManyArgs} args - Arguments to create many VehicleImages.
     * @example
     * // Create many VehicleImages
     * const vehicleImage = await prisma.vehicleImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleImageCreateManyArgs>(args?: SelectSubset<T, VehicleImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VehicleImages and returns the data saved in the database.
     * @param {VehicleImageCreateManyAndReturnArgs} args - Arguments to create many VehicleImages.
     * @example
     * // Create many VehicleImages
     * const vehicleImage = await prisma.vehicleImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VehicleImages and only return the `id`
     * const vehicleImageWithIdOnly = await prisma.vehicleImage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleImageCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VehicleImage.
     * @param {VehicleImageDeleteArgs} args - Arguments to delete one VehicleImage.
     * @example
     * // Delete one VehicleImage
     * const VehicleImage = await prisma.vehicleImage.delete({
     *   where: {
     *     // ... filter to delete one VehicleImage
     *   }
     * })
     * 
     */
    delete<T extends VehicleImageDeleteArgs>(args: SelectSubset<T, VehicleImageDeleteArgs<ExtArgs>>): Prisma__VehicleImageClient<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VehicleImage.
     * @param {VehicleImageUpdateArgs} args - Arguments to update one VehicleImage.
     * @example
     * // Update one VehicleImage
     * const vehicleImage = await prisma.vehicleImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleImageUpdateArgs>(args: SelectSubset<T, VehicleImageUpdateArgs<ExtArgs>>): Prisma__VehicleImageClient<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VehicleImages.
     * @param {VehicleImageDeleteManyArgs} args - Arguments to filter VehicleImages to delete.
     * @example
     * // Delete a few VehicleImages
     * const { count } = await prisma.vehicleImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleImageDeleteManyArgs>(args?: SelectSubset<T, VehicleImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleImages
     * const vehicleImage = await prisma.vehicleImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleImageUpdateManyArgs>(args: SelectSubset<T, VehicleImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VehicleImage.
     * @param {VehicleImageUpsertArgs} args - Arguments to update or create a VehicleImage.
     * @example
     * // Update or create a VehicleImage
     * const vehicleImage = await prisma.vehicleImage.upsert({
     *   create: {
     *     // ... data to create a VehicleImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehicleImage we want to update
     *   }
     * })
     */
    upsert<T extends VehicleImageUpsertArgs>(args: SelectSubset<T, VehicleImageUpsertArgs<ExtArgs>>): Prisma__VehicleImageClient<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VehicleImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleImageCountArgs} args - Arguments to filter VehicleImages to count.
     * @example
     * // Count the number of VehicleImages
     * const count = await prisma.vehicleImage.count({
     *   where: {
     *     // ... the filter for the VehicleImages we want to count
     *   }
     * })
    **/
    count<T extends VehicleImageCountArgs>(
      args?: Subset<T, VehicleImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehicleImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleImageAggregateArgs>(args: Subset<T, VehicleImageAggregateArgs>): Prisma.PrismaPromise<GetVehicleImageAggregateType<T>>

    /**
     * Group by VehicleImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleImageGroupByArgs['orderBy'] }
        : { orderBy?: VehicleImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehicleImage model
   */
  readonly fields: VehicleImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehicleImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehicleImage model
   */ 
  interface VehicleImageFieldRefs {
    readonly id: FieldRef<"VehicleImage", 'String'>
    readonly url: FieldRef<"VehicleImage", 'String'>
    readonly alt: FieldRef<"VehicleImage", 'String'>
    readonly type: FieldRef<"VehicleImage", 'String'>
    readonly order: FieldRef<"VehicleImage", 'Int'>
    readonly vehicleId: FieldRef<"VehicleImage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VehicleImage findUnique
   */
  export type VehicleImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
    /**
     * Filter, which VehicleImage to fetch.
     */
    where: VehicleImageWhereUniqueInput
  }

  /**
   * VehicleImage findUniqueOrThrow
   */
  export type VehicleImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
    /**
     * Filter, which VehicleImage to fetch.
     */
    where: VehicleImageWhereUniqueInput
  }

  /**
   * VehicleImage findFirst
   */
  export type VehicleImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
    /**
     * Filter, which VehicleImage to fetch.
     */
    where?: VehicleImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleImages to fetch.
     */
    orderBy?: VehicleImageOrderByWithRelationInput | VehicleImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleImages.
     */
    cursor?: VehicleImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleImages.
     */
    distinct?: VehicleImageScalarFieldEnum | VehicleImageScalarFieldEnum[]
  }

  /**
   * VehicleImage findFirstOrThrow
   */
  export type VehicleImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
    /**
     * Filter, which VehicleImage to fetch.
     */
    where?: VehicleImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleImages to fetch.
     */
    orderBy?: VehicleImageOrderByWithRelationInput | VehicleImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleImages.
     */
    cursor?: VehicleImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleImages.
     */
    distinct?: VehicleImageScalarFieldEnum | VehicleImageScalarFieldEnum[]
  }

  /**
   * VehicleImage findMany
   */
  export type VehicleImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
    /**
     * Filter, which VehicleImages to fetch.
     */
    where?: VehicleImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleImages to fetch.
     */
    orderBy?: VehicleImageOrderByWithRelationInput | VehicleImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleImages.
     */
    cursor?: VehicleImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleImages.
     */
    skip?: number
    distinct?: VehicleImageScalarFieldEnum | VehicleImageScalarFieldEnum[]
  }

  /**
   * VehicleImage create
   */
  export type VehicleImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
    /**
     * The data needed to create a VehicleImage.
     */
    data: XOR<VehicleImageCreateInput, VehicleImageUncheckedCreateInput>
  }

  /**
   * VehicleImage createMany
   */
  export type VehicleImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleImages.
     */
    data: VehicleImageCreateManyInput | VehicleImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleImage createManyAndReturn
   */
  export type VehicleImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VehicleImages.
     */
    data: VehicleImageCreateManyInput | VehicleImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleImage update
   */
  export type VehicleImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
    /**
     * The data needed to update a VehicleImage.
     */
    data: XOR<VehicleImageUpdateInput, VehicleImageUncheckedUpdateInput>
    /**
     * Choose, which VehicleImage to update.
     */
    where: VehicleImageWhereUniqueInput
  }

  /**
   * VehicleImage updateMany
   */
  export type VehicleImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleImages.
     */
    data: XOR<VehicleImageUpdateManyMutationInput, VehicleImageUncheckedUpdateManyInput>
    /**
     * Filter which VehicleImages to update
     */
    where?: VehicleImageWhereInput
  }

  /**
   * VehicleImage upsert
   */
  export type VehicleImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
    /**
     * The filter to search for the VehicleImage to update in case it exists.
     */
    where: VehicleImageWhereUniqueInput
    /**
     * In case the VehicleImage found by the `where` argument doesn't exist, create a new VehicleImage with this data.
     */
    create: XOR<VehicleImageCreateInput, VehicleImageUncheckedCreateInput>
    /**
     * In case the VehicleImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleImageUpdateInput, VehicleImageUncheckedUpdateInput>
  }

  /**
   * VehicleImage delete
   */
  export type VehicleImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
    /**
     * Filter which VehicleImage to delete.
     */
    where: VehicleImageWhereUniqueInput
  }

  /**
   * VehicleImage deleteMany
   */
  export type VehicleImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleImages to delete
     */
    where?: VehicleImageWhereInput
  }

  /**
   * VehicleImage without action
   */
  export type VehicleImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    order: number | null
  }

  export type CategorySumAggregateOutputType = {
    order: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    icon: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    order?: true
  }

  export type CategorySumAggregateInputType = {
    order?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    icon: string | null
    order: number
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicles?: boolean | Category$vehiclesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicles?: boolean | Category$vehiclesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      vehicles: Prisma.$VehiclePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      icon: string | null
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicles<T extends Category$vehiclesArgs<ExtArgs> = {}>(args?: Subset<T, Category$vehiclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly icon: FieldRef<"Category", 'String'>
    readonly order: FieldRef<"Category", 'Int'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category.vehicles
   */
  export type Category$vehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    cursor?: VehicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    clerkId: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    avatar: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    clerkId: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    avatar: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    clerkId: number
    email: number
    firstName: number
    lastName: number
    phone: number
    avatar: number
    preferences: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    clerkId?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    clerkId?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    clerkId?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    avatar?: true
    preferences?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    clerkId: string
    email: string
    firstName: string
    lastName: string
    phone: string | null
    avatar: string | null
    preferences: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clerkId?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    avatar?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    savedVehicles?: boolean | User$savedVehiclesArgs<ExtArgs>
    configurations?: boolean | User$configurationsArgs<ExtArgs>
    inquiries?: boolean | User$inquiriesArgs<ExtArgs>
    testDrives?: boolean | User$testDrivesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clerkId?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    avatar?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    clerkId?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    avatar?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    savedVehicles?: boolean | User$savedVehiclesArgs<ExtArgs>
    configurations?: boolean | User$configurationsArgs<ExtArgs>
    inquiries?: boolean | User$inquiriesArgs<ExtArgs>
    testDrives?: boolean | User$testDrivesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      savedVehicles: Prisma.$SavedVehiclePayload<ExtArgs>[]
      configurations: Prisma.$ConfigurationPayload<ExtArgs>[]
      inquiries: Prisma.$InquiryPayload<ExtArgs>[]
      testDrives: Prisma.$TestDrivePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clerkId: string
      email: string
      firstName: string
      lastName: string
      phone: string | null
      avatar: string | null
      preferences: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    savedVehicles<T extends User$savedVehiclesArgs<ExtArgs> = {}>(args?: Subset<T, User$savedVehiclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedVehiclePayload<ExtArgs>, T, "findMany"> | Null>
    configurations<T extends User$configurationsArgs<ExtArgs> = {}>(args?: Subset<T, User$configurationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findMany"> | Null>
    inquiries<T extends User$inquiriesArgs<ExtArgs> = {}>(args?: Subset<T, User$inquiriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findMany"> | Null>
    testDrives<T extends User$testDrivesArgs<ExtArgs> = {}>(args?: Subset<T, User$testDrivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestDrivePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly clerkId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly preferences: FieldRef<"User", 'Json'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.savedVehicles
   */
  export type User$savedVehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedVehicle
     */
    select?: SavedVehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedVehicleInclude<ExtArgs> | null
    where?: SavedVehicleWhereInput
    orderBy?: SavedVehicleOrderByWithRelationInput | SavedVehicleOrderByWithRelationInput[]
    cursor?: SavedVehicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedVehicleScalarFieldEnum | SavedVehicleScalarFieldEnum[]
  }

  /**
   * User.configurations
   */
  export type User$configurationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
    where?: ConfigurationWhereInput
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    cursor?: ConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }

  /**
   * User.inquiries
   */
  export type User$inquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    where?: InquiryWhereInput
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    cursor?: InquiryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * User.testDrives
   */
  export type User$testDrivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestDrive
     */
    select?: TestDriveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestDriveInclude<ExtArgs> | null
    where?: TestDriveWhereInput
    orderBy?: TestDriveOrderByWithRelationInput | TestDriveOrderByWithRelationInput[]
    cursor?: TestDriveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestDriveScalarFieldEnum | TestDriveScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model SavedVehicle
   */

  export type AggregateSavedVehicle = {
    _count: SavedVehicleCountAggregateOutputType | null
    _min: SavedVehicleMinAggregateOutputType | null
    _max: SavedVehicleMaxAggregateOutputType | null
  }

  export type SavedVehicleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    vehicleId: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type SavedVehicleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    vehicleId: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type SavedVehicleCountAggregateOutputType = {
    id: number
    userId: number
    vehicleId: number
    notes: number
    createdAt: number
    _all: number
  }


  export type SavedVehicleMinAggregateInputType = {
    id?: true
    userId?: true
    vehicleId?: true
    notes?: true
    createdAt?: true
  }

  export type SavedVehicleMaxAggregateInputType = {
    id?: true
    userId?: true
    vehicleId?: true
    notes?: true
    createdAt?: true
  }

  export type SavedVehicleCountAggregateInputType = {
    id?: true
    userId?: true
    vehicleId?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type SavedVehicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedVehicle to aggregate.
     */
    where?: SavedVehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedVehicles to fetch.
     */
    orderBy?: SavedVehicleOrderByWithRelationInput | SavedVehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SavedVehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedVehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedVehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SavedVehicles
    **/
    _count?: true | SavedVehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SavedVehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SavedVehicleMaxAggregateInputType
  }

  export type GetSavedVehicleAggregateType<T extends SavedVehicleAggregateArgs> = {
        [P in keyof T & keyof AggregateSavedVehicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSavedVehicle[P]>
      : GetScalarType<T[P], AggregateSavedVehicle[P]>
  }




  export type SavedVehicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedVehicleWhereInput
    orderBy?: SavedVehicleOrderByWithAggregationInput | SavedVehicleOrderByWithAggregationInput[]
    by: SavedVehicleScalarFieldEnum[] | SavedVehicleScalarFieldEnum
    having?: SavedVehicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SavedVehicleCountAggregateInputType | true
    _min?: SavedVehicleMinAggregateInputType
    _max?: SavedVehicleMaxAggregateInputType
  }

  export type SavedVehicleGroupByOutputType = {
    id: string
    userId: string
    vehicleId: string
    notes: string | null
    createdAt: Date
    _count: SavedVehicleCountAggregateOutputType | null
    _min: SavedVehicleMinAggregateOutputType | null
    _max: SavedVehicleMaxAggregateOutputType | null
  }

  type GetSavedVehicleGroupByPayload<T extends SavedVehicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SavedVehicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SavedVehicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SavedVehicleGroupByOutputType[P]>
            : GetScalarType<T[P], SavedVehicleGroupByOutputType[P]>
        }
      >
    >


  export type SavedVehicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vehicleId?: boolean
    notes?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedVehicle"]>

  export type SavedVehicleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vehicleId?: boolean
    notes?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedVehicle"]>

  export type SavedVehicleSelectScalar = {
    id?: boolean
    userId?: boolean
    vehicleId?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type SavedVehicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }
  export type SavedVehicleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }

  export type $SavedVehiclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SavedVehicle"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      vehicle: Prisma.$VehiclePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      vehicleId: string
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["savedVehicle"]>
    composites: {}
  }

  type SavedVehicleGetPayload<S extends boolean | null | undefined | SavedVehicleDefaultArgs> = $Result.GetResult<Prisma.$SavedVehiclePayload, S>

  type SavedVehicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SavedVehicleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SavedVehicleCountAggregateInputType | true
    }

  export interface SavedVehicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SavedVehicle'], meta: { name: 'SavedVehicle' } }
    /**
     * Find zero or one SavedVehicle that matches the filter.
     * @param {SavedVehicleFindUniqueArgs} args - Arguments to find a SavedVehicle
     * @example
     * // Get one SavedVehicle
     * const savedVehicle = await prisma.savedVehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SavedVehicleFindUniqueArgs>(args: SelectSubset<T, SavedVehicleFindUniqueArgs<ExtArgs>>): Prisma__SavedVehicleClient<$Result.GetResult<Prisma.$SavedVehiclePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SavedVehicle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SavedVehicleFindUniqueOrThrowArgs} args - Arguments to find a SavedVehicle
     * @example
     * // Get one SavedVehicle
     * const savedVehicle = await prisma.savedVehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SavedVehicleFindUniqueOrThrowArgs>(args: SelectSubset<T, SavedVehicleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SavedVehicleClient<$Result.GetResult<Prisma.$SavedVehiclePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SavedVehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedVehicleFindFirstArgs} args - Arguments to find a SavedVehicle
     * @example
     * // Get one SavedVehicle
     * const savedVehicle = await prisma.savedVehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SavedVehicleFindFirstArgs>(args?: SelectSubset<T, SavedVehicleFindFirstArgs<ExtArgs>>): Prisma__SavedVehicleClient<$Result.GetResult<Prisma.$SavedVehiclePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SavedVehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedVehicleFindFirstOrThrowArgs} args - Arguments to find a SavedVehicle
     * @example
     * // Get one SavedVehicle
     * const savedVehicle = await prisma.savedVehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SavedVehicleFindFirstOrThrowArgs>(args?: SelectSubset<T, SavedVehicleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SavedVehicleClient<$Result.GetResult<Prisma.$SavedVehiclePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SavedVehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedVehicleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavedVehicles
     * const savedVehicles = await prisma.savedVehicle.findMany()
     * 
     * // Get first 10 SavedVehicles
     * const savedVehicles = await prisma.savedVehicle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const savedVehicleWithIdOnly = await prisma.savedVehicle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SavedVehicleFindManyArgs>(args?: SelectSubset<T, SavedVehicleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedVehiclePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SavedVehicle.
     * @param {SavedVehicleCreateArgs} args - Arguments to create a SavedVehicle.
     * @example
     * // Create one SavedVehicle
     * const SavedVehicle = await prisma.savedVehicle.create({
     *   data: {
     *     // ... data to create a SavedVehicle
     *   }
     * })
     * 
     */
    create<T extends SavedVehicleCreateArgs>(args: SelectSubset<T, SavedVehicleCreateArgs<ExtArgs>>): Prisma__SavedVehicleClient<$Result.GetResult<Prisma.$SavedVehiclePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SavedVehicles.
     * @param {SavedVehicleCreateManyArgs} args - Arguments to create many SavedVehicles.
     * @example
     * // Create many SavedVehicles
     * const savedVehicle = await prisma.savedVehicle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SavedVehicleCreateManyArgs>(args?: SelectSubset<T, SavedVehicleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SavedVehicles and returns the data saved in the database.
     * @param {SavedVehicleCreateManyAndReturnArgs} args - Arguments to create many SavedVehicles.
     * @example
     * // Create many SavedVehicles
     * const savedVehicle = await prisma.savedVehicle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SavedVehicles and only return the `id`
     * const savedVehicleWithIdOnly = await prisma.savedVehicle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SavedVehicleCreateManyAndReturnArgs>(args?: SelectSubset<T, SavedVehicleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedVehiclePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SavedVehicle.
     * @param {SavedVehicleDeleteArgs} args - Arguments to delete one SavedVehicle.
     * @example
     * // Delete one SavedVehicle
     * const SavedVehicle = await prisma.savedVehicle.delete({
     *   where: {
     *     // ... filter to delete one SavedVehicle
     *   }
     * })
     * 
     */
    delete<T extends SavedVehicleDeleteArgs>(args: SelectSubset<T, SavedVehicleDeleteArgs<ExtArgs>>): Prisma__SavedVehicleClient<$Result.GetResult<Prisma.$SavedVehiclePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SavedVehicle.
     * @param {SavedVehicleUpdateArgs} args - Arguments to update one SavedVehicle.
     * @example
     * // Update one SavedVehicle
     * const savedVehicle = await prisma.savedVehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SavedVehicleUpdateArgs>(args: SelectSubset<T, SavedVehicleUpdateArgs<ExtArgs>>): Prisma__SavedVehicleClient<$Result.GetResult<Prisma.$SavedVehiclePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SavedVehicles.
     * @param {SavedVehicleDeleteManyArgs} args - Arguments to filter SavedVehicles to delete.
     * @example
     * // Delete a few SavedVehicles
     * const { count } = await prisma.savedVehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SavedVehicleDeleteManyArgs>(args?: SelectSubset<T, SavedVehicleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedVehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedVehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavedVehicles
     * const savedVehicle = await prisma.savedVehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SavedVehicleUpdateManyArgs>(args: SelectSubset<T, SavedVehicleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SavedVehicle.
     * @param {SavedVehicleUpsertArgs} args - Arguments to update or create a SavedVehicle.
     * @example
     * // Update or create a SavedVehicle
     * const savedVehicle = await prisma.savedVehicle.upsert({
     *   create: {
     *     // ... data to create a SavedVehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavedVehicle we want to update
     *   }
     * })
     */
    upsert<T extends SavedVehicleUpsertArgs>(args: SelectSubset<T, SavedVehicleUpsertArgs<ExtArgs>>): Prisma__SavedVehicleClient<$Result.GetResult<Prisma.$SavedVehiclePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SavedVehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedVehicleCountArgs} args - Arguments to filter SavedVehicles to count.
     * @example
     * // Count the number of SavedVehicles
     * const count = await prisma.savedVehicle.count({
     *   where: {
     *     // ... the filter for the SavedVehicles we want to count
     *   }
     * })
    **/
    count<T extends SavedVehicleCountArgs>(
      args?: Subset<T, SavedVehicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SavedVehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SavedVehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedVehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavedVehicleAggregateArgs>(args: Subset<T, SavedVehicleAggregateArgs>): Prisma.PrismaPromise<GetSavedVehicleAggregateType<T>>

    /**
     * Group by SavedVehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedVehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SavedVehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SavedVehicleGroupByArgs['orderBy'] }
        : { orderBy?: SavedVehicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SavedVehicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavedVehicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SavedVehicle model
   */
  readonly fields: SavedVehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SavedVehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SavedVehicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SavedVehicle model
   */ 
  interface SavedVehicleFieldRefs {
    readonly id: FieldRef<"SavedVehicle", 'String'>
    readonly userId: FieldRef<"SavedVehicle", 'String'>
    readonly vehicleId: FieldRef<"SavedVehicle", 'String'>
    readonly notes: FieldRef<"SavedVehicle", 'String'>
    readonly createdAt: FieldRef<"SavedVehicle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SavedVehicle findUnique
   */
  export type SavedVehicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedVehicle
     */
    select?: SavedVehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedVehicleInclude<ExtArgs> | null
    /**
     * Filter, which SavedVehicle to fetch.
     */
    where: SavedVehicleWhereUniqueInput
  }

  /**
   * SavedVehicle findUniqueOrThrow
   */
  export type SavedVehicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedVehicle
     */
    select?: SavedVehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedVehicleInclude<ExtArgs> | null
    /**
     * Filter, which SavedVehicle to fetch.
     */
    where: SavedVehicleWhereUniqueInput
  }

  /**
   * SavedVehicle findFirst
   */
  export type SavedVehicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedVehicle
     */
    select?: SavedVehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedVehicleInclude<ExtArgs> | null
    /**
     * Filter, which SavedVehicle to fetch.
     */
    where?: SavedVehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedVehicles to fetch.
     */
    orderBy?: SavedVehicleOrderByWithRelationInput | SavedVehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedVehicles.
     */
    cursor?: SavedVehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedVehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedVehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedVehicles.
     */
    distinct?: SavedVehicleScalarFieldEnum | SavedVehicleScalarFieldEnum[]
  }

  /**
   * SavedVehicle findFirstOrThrow
   */
  export type SavedVehicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedVehicle
     */
    select?: SavedVehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedVehicleInclude<ExtArgs> | null
    /**
     * Filter, which SavedVehicle to fetch.
     */
    where?: SavedVehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedVehicles to fetch.
     */
    orderBy?: SavedVehicleOrderByWithRelationInput | SavedVehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedVehicles.
     */
    cursor?: SavedVehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedVehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedVehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedVehicles.
     */
    distinct?: SavedVehicleScalarFieldEnum | SavedVehicleScalarFieldEnum[]
  }

  /**
   * SavedVehicle findMany
   */
  export type SavedVehicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedVehicle
     */
    select?: SavedVehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedVehicleInclude<ExtArgs> | null
    /**
     * Filter, which SavedVehicles to fetch.
     */
    where?: SavedVehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedVehicles to fetch.
     */
    orderBy?: SavedVehicleOrderByWithRelationInput | SavedVehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SavedVehicles.
     */
    cursor?: SavedVehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedVehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedVehicles.
     */
    skip?: number
    distinct?: SavedVehicleScalarFieldEnum | SavedVehicleScalarFieldEnum[]
  }

  /**
   * SavedVehicle create
   */
  export type SavedVehicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedVehicle
     */
    select?: SavedVehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedVehicleInclude<ExtArgs> | null
    /**
     * The data needed to create a SavedVehicle.
     */
    data: XOR<SavedVehicleCreateInput, SavedVehicleUncheckedCreateInput>
  }

  /**
   * SavedVehicle createMany
   */
  export type SavedVehicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SavedVehicles.
     */
    data: SavedVehicleCreateManyInput | SavedVehicleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SavedVehicle createManyAndReturn
   */
  export type SavedVehicleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedVehicle
     */
    select?: SavedVehicleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SavedVehicles.
     */
    data: SavedVehicleCreateManyInput | SavedVehicleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedVehicleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedVehicle update
   */
  export type SavedVehicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedVehicle
     */
    select?: SavedVehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedVehicleInclude<ExtArgs> | null
    /**
     * The data needed to update a SavedVehicle.
     */
    data: XOR<SavedVehicleUpdateInput, SavedVehicleUncheckedUpdateInput>
    /**
     * Choose, which SavedVehicle to update.
     */
    where: SavedVehicleWhereUniqueInput
  }

  /**
   * SavedVehicle updateMany
   */
  export type SavedVehicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SavedVehicles.
     */
    data: XOR<SavedVehicleUpdateManyMutationInput, SavedVehicleUncheckedUpdateManyInput>
    /**
     * Filter which SavedVehicles to update
     */
    where?: SavedVehicleWhereInput
  }

  /**
   * SavedVehicle upsert
   */
  export type SavedVehicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedVehicle
     */
    select?: SavedVehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedVehicleInclude<ExtArgs> | null
    /**
     * The filter to search for the SavedVehicle to update in case it exists.
     */
    where: SavedVehicleWhereUniqueInput
    /**
     * In case the SavedVehicle found by the `where` argument doesn't exist, create a new SavedVehicle with this data.
     */
    create: XOR<SavedVehicleCreateInput, SavedVehicleUncheckedCreateInput>
    /**
     * In case the SavedVehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SavedVehicleUpdateInput, SavedVehicleUncheckedUpdateInput>
  }

  /**
   * SavedVehicle delete
   */
  export type SavedVehicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedVehicle
     */
    select?: SavedVehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedVehicleInclude<ExtArgs> | null
    /**
     * Filter which SavedVehicle to delete.
     */
    where: SavedVehicleWhereUniqueInput
  }

  /**
   * SavedVehicle deleteMany
   */
  export type SavedVehicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedVehicles to delete
     */
    where?: SavedVehicleWhereInput
  }

  /**
   * SavedVehicle without action
   */
  export type SavedVehicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedVehicle
     */
    select?: SavedVehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedVehicleInclude<ExtArgs> | null
  }


  /**
   * Model Configuration
   */

  export type AggregateConfiguration = {
    _count: ConfigurationCountAggregateOutputType | null
    _avg: ConfigurationAvgAggregateOutputType | null
    _sum: ConfigurationSumAggregateOutputType | null
    _min: ConfigurationMinAggregateOutputType | null
    _max: ConfigurationMaxAggregateOutputType | null
  }

  export type ConfigurationAvgAggregateOutputType = {
    totalPrice: Decimal | null
  }

  export type ConfigurationSumAggregateOutputType = {
    totalPrice: Decimal | null
  }

  export type ConfigurationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    vehicleId: string | null
    color: string | null
    colorHex: string | null
    wheels: string | null
    interior: string | null
    totalPrice: Decimal | null
    shared: boolean | null
    shareToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfigurationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    vehicleId: string | null
    color: string | null
    colorHex: string | null
    wheels: string | null
    interior: string | null
    totalPrice: Decimal | null
    shared: boolean | null
    shareToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfigurationCountAggregateOutputType = {
    id: number
    userId: number
    vehicleId: number
    color: number
    colorHex: number
    wheels: number
    interior: number
    packages: number
    accessories: number
    totalPrice: number
    shared: number
    shareToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConfigurationAvgAggregateInputType = {
    totalPrice?: true
  }

  export type ConfigurationSumAggregateInputType = {
    totalPrice?: true
  }

  export type ConfigurationMinAggregateInputType = {
    id?: true
    userId?: true
    vehicleId?: true
    color?: true
    colorHex?: true
    wheels?: true
    interior?: true
    totalPrice?: true
    shared?: true
    shareToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfigurationMaxAggregateInputType = {
    id?: true
    userId?: true
    vehicleId?: true
    color?: true
    colorHex?: true
    wheels?: true
    interior?: true
    totalPrice?: true
    shared?: true
    shareToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfigurationCountAggregateInputType = {
    id?: true
    userId?: true
    vehicleId?: true
    color?: true
    colorHex?: true
    wheels?: true
    interior?: true
    packages?: true
    accessories?: true
    totalPrice?: true
    shared?: true
    shareToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConfigurationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Configuration to aggregate.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Configurations
    **/
    _count?: true | ConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfigurationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfigurationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigurationMaxAggregateInputType
  }

  export type GetConfigurationAggregateType<T extends ConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfiguration[P]>
      : GetScalarType<T[P], AggregateConfiguration[P]>
  }




  export type ConfigurationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigurationWhereInput
    orderBy?: ConfigurationOrderByWithAggregationInput | ConfigurationOrderByWithAggregationInput[]
    by: ConfigurationScalarFieldEnum[] | ConfigurationScalarFieldEnum
    having?: ConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigurationCountAggregateInputType | true
    _avg?: ConfigurationAvgAggregateInputType
    _sum?: ConfigurationSumAggregateInputType
    _min?: ConfigurationMinAggregateInputType
    _max?: ConfigurationMaxAggregateInputType
  }

  export type ConfigurationGroupByOutputType = {
    id: string
    userId: string
    vehicleId: string
    color: string
    colorHex: string
    wheels: string | null
    interior: string | null
    packages: JsonValue
    accessories: JsonValue
    totalPrice: Decimal
    shared: boolean
    shareToken: string | null
    createdAt: Date
    updatedAt: Date
    _count: ConfigurationCountAggregateOutputType | null
    _avg: ConfigurationAvgAggregateOutputType | null
    _sum: ConfigurationSumAggregateOutputType | null
    _min: ConfigurationMinAggregateOutputType | null
    _max: ConfigurationMaxAggregateOutputType | null
  }

  type GetConfigurationGroupByPayload<T extends ConfigurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type ConfigurationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vehicleId?: boolean
    color?: boolean
    colorHex?: boolean
    wheels?: boolean
    interior?: boolean
    packages?: boolean
    accessories?: boolean
    totalPrice?: boolean
    shared?: boolean
    shareToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configuration"]>

  export type ConfigurationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vehicleId?: boolean
    color?: boolean
    colorHex?: boolean
    wheels?: boolean
    interior?: boolean
    packages?: boolean
    accessories?: boolean
    totalPrice?: boolean
    shared?: boolean
    shareToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configuration"]>

  export type ConfigurationSelectScalar = {
    id?: boolean
    userId?: boolean
    vehicleId?: boolean
    color?: boolean
    colorHex?: boolean
    wheels?: boolean
    interior?: boolean
    packages?: boolean
    accessories?: boolean
    totalPrice?: boolean
    shared?: boolean
    shareToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConfigurationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }
  export type ConfigurationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }

  export type $ConfigurationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Configuration"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      vehicle: Prisma.$VehiclePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      vehicleId: string
      color: string
      colorHex: string
      wheels: string | null
      interior: string | null
      packages: Prisma.JsonValue
      accessories: Prisma.JsonValue
      totalPrice: Prisma.Decimal
      shared: boolean
      shareToken: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["configuration"]>
    composites: {}
  }

  type ConfigurationGetPayload<S extends boolean | null | undefined | ConfigurationDefaultArgs> = $Result.GetResult<Prisma.$ConfigurationPayload, S>

  type ConfigurationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConfigurationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConfigurationCountAggregateInputType | true
    }

  export interface ConfigurationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Configuration'], meta: { name: 'Configuration' } }
    /**
     * Find zero or one Configuration that matches the filter.
     * @param {ConfigurationFindUniqueArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfigurationFindUniqueArgs>(args: SelectSubset<T, ConfigurationFindUniqueArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Configuration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConfigurationFindUniqueOrThrowArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfigurationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfigurationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Configuration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationFindFirstArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfigurationFindFirstArgs>(args?: SelectSubset<T, ConfigurationFindFirstArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Configuration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationFindFirstOrThrowArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfigurationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfigurationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Configurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configurations
     * const configurations = await prisma.configuration.findMany()
     * 
     * // Get first 10 Configurations
     * const configurations = await prisma.configuration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configurationWithIdOnly = await prisma.configuration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfigurationFindManyArgs>(args?: SelectSubset<T, ConfigurationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Configuration.
     * @param {ConfigurationCreateArgs} args - Arguments to create a Configuration.
     * @example
     * // Create one Configuration
     * const Configuration = await prisma.configuration.create({
     *   data: {
     *     // ... data to create a Configuration
     *   }
     * })
     * 
     */
    create<T extends ConfigurationCreateArgs>(args: SelectSubset<T, ConfigurationCreateArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Configurations.
     * @param {ConfigurationCreateManyArgs} args - Arguments to create many Configurations.
     * @example
     * // Create many Configurations
     * const configuration = await prisma.configuration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfigurationCreateManyArgs>(args?: SelectSubset<T, ConfigurationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Configurations and returns the data saved in the database.
     * @param {ConfigurationCreateManyAndReturnArgs} args - Arguments to create many Configurations.
     * @example
     * // Create many Configurations
     * const configuration = await prisma.configuration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Configurations and only return the `id`
     * const configurationWithIdOnly = await prisma.configuration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConfigurationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConfigurationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Configuration.
     * @param {ConfigurationDeleteArgs} args - Arguments to delete one Configuration.
     * @example
     * // Delete one Configuration
     * const Configuration = await prisma.configuration.delete({
     *   where: {
     *     // ... filter to delete one Configuration
     *   }
     * })
     * 
     */
    delete<T extends ConfigurationDeleteArgs>(args: SelectSubset<T, ConfigurationDeleteArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Configuration.
     * @param {ConfigurationUpdateArgs} args - Arguments to update one Configuration.
     * @example
     * // Update one Configuration
     * const configuration = await prisma.configuration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfigurationUpdateArgs>(args: SelectSubset<T, ConfigurationUpdateArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Configurations.
     * @param {ConfigurationDeleteManyArgs} args - Arguments to filter Configurations to delete.
     * @example
     * // Delete a few Configurations
     * const { count } = await prisma.configuration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfigurationDeleteManyArgs>(args?: SelectSubset<T, ConfigurationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configurations
     * const configuration = await prisma.configuration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfigurationUpdateManyArgs>(args: SelectSubset<T, ConfigurationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Configuration.
     * @param {ConfigurationUpsertArgs} args - Arguments to update or create a Configuration.
     * @example
     * // Update or create a Configuration
     * const configuration = await prisma.configuration.upsert({
     *   create: {
     *     // ... data to create a Configuration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Configuration we want to update
     *   }
     * })
     */
    upsert<T extends ConfigurationUpsertArgs>(args: SelectSubset<T, ConfigurationUpsertArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationCountArgs} args - Arguments to filter Configurations to count.
     * @example
     * // Count the number of Configurations
     * const count = await prisma.configuration.count({
     *   where: {
     *     // ... the filter for the Configurations we want to count
     *   }
     * })
    **/
    count<T extends ConfigurationCountArgs>(
      args?: Subset<T, ConfigurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Configuration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigurationAggregateArgs>(args: Subset<T, ConfigurationAggregateArgs>): Prisma.PrismaPromise<GetConfigurationAggregateType<T>>

    /**
     * Group by Configuration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: ConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Configuration model
   */
  readonly fields: ConfigurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Configuration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfigurationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Configuration model
   */ 
  interface ConfigurationFieldRefs {
    readonly id: FieldRef<"Configuration", 'String'>
    readonly userId: FieldRef<"Configuration", 'String'>
    readonly vehicleId: FieldRef<"Configuration", 'String'>
    readonly color: FieldRef<"Configuration", 'String'>
    readonly colorHex: FieldRef<"Configuration", 'String'>
    readonly wheels: FieldRef<"Configuration", 'String'>
    readonly interior: FieldRef<"Configuration", 'String'>
    readonly packages: FieldRef<"Configuration", 'Json'>
    readonly accessories: FieldRef<"Configuration", 'Json'>
    readonly totalPrice: FieldRef<"Configuration", 'Decimal'>
    readonly shared: FieldRef<"Configuration", 'Boolean'>
    readonly shareToken: FieldRef<"Configuration", 'String'>
    readonly createdAt: FieldRef<"Configuration", 'DateTime'>
    readonly updatedAt: FieldRef<"Configuration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Configuration findUnique
   */
  export type ConfigurationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where: ConfigurationWhereUniqueInput
  }

  /**
   * Configuration findUniqueOrThrow
   */
  export type ConfigurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where: ConfigurationWhereUniqueInput
  }

  /**
   * Configuration findFirst
   */
  export type ConfigurationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Configurations.
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Configurations.
     */
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }

  /**
   * Configuration findFirstOrThrow
   */
  export type ConfigurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Configurations.
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Configurations.
     */
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }

  /**
   * Configuration findMany
   */
  export type ConfigurationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which Configurations to fetch.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Configurations.
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }

  /**
   * Configuration create
   */
  export type ConfigurationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * The data needed to create a Configuration.
     */
    data: XOR<ConfigurationCreateInput, ConfigurationUncheckedCreateInput>
  }

  /**
   * Configuration createMany
   */
  export type ConfigurationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Configurations.
     */
    data: ConfigurationCreateManyInput | ConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Configuration createManyAndReturn
   */
  export type ConfigurationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Configurations.
     */
    data: ConfigurationCreateManyInput | ConfigurationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Configuration update
   */
  export type ConfigurationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * The data needed to update a Configuration.
     */
    data: XOR<ConfigurationUpdateInput, ConfigurationUncheckedUpdateInput>
    /**
     * Choose, which Configuration to update.
     */
    where: ConfigurationWhereUniqueInput
  }

  /**
   * Configuration updateMany
   */
  export type ConfigurationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Configurations.
     */
    data: XOR<ConfigurationUpdateManyMutationInput, ConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which Configurations to update
     */
    where?: ConfigurationWhereInput
  }

  /**
   * Configuration upsert
   */
  export type ConfigurationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * The filter to search for the Configuration to update in case it exists.
     */
    where: ConfigurationWhereUniqueInput
    /**
     * In case the Configuration found by the `where` argument doesn't exist, create a new Configuration with this data.
     */
    create: XOR<ConfigurationCreateInput, ConfigurationUncheckedCreateInput>
    /**
     * In case the Configuration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfigurationUpdateInput, ConfigurationUncheckedUpdateInput>
  }

  /**
   * Configuration delete
   */
  export type ConfigurationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * Filter which Configuration to delete.
     */
    where: ConfigurationWhereUniqueInput
  }

  /**
   * Configuration deleteMany
   */
  export type ConfigurationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Configurations to delete
     */
    where?: ConfigurationWhereInput
  }

  /**
   * Configuration without action
   */
  export type ConfigurationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
  }


  /**
   * Model TestDrive
   */

  export type AggregateTestDrive = {
    _count: TestDriveCountAggregateOutputType | null
    _min: TestDriveMinAggregateOutputType | null
    _max: TestDriveMaxAggregateOutputType | null
  }

  export type TestDriveMinAggregateOutputType = {
    id: string | null
    userId: string | null
    vehicleId: string | null
    preferredDate: Date | null
    preferredTime: string | null
    location: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    status: $Enums.BookingStatus | null
    notes: string | null
    adminNotes: string | null
    confirmedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestDriveMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    vehicleId: string | null
    preferredDate: Date | null
    preferredTime: string | null
    location: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    status: $Enums.BookingStatus | null
    notes: string | null
    adminNotes: string | null
    confirmedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestDriveCountAggregateOutputType = {
    id: number
    userId: number
    vehicleId: number
    preferredDate: number
    preferredTime: number
    location: number
    firstName: number
    lastName: number
    email: number
    phone: number
    status: number
    notes: number
    adminNotes: number
    confirmedAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TestDriveMinAggregateInputType = {
    id?: true
    userId?: true
    vehicleId?: true
    preferredDate?: true
    preferredTime?: true
    location?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    status?: true
    notes?: true
    adminNotes?: true
    confirmedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestDriveMaxAggregateInputType = {
    id?: true
    userId?: true
    vehicleId?: true
    preferredDate?: true
    preferredTime?: true
    location?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    status?: true
    notes?: true
    adminNotes?: true
    confirmedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestDriveCountAggregateInputType = {
    id?: true
    userId?: true
    vehicleId?: true
    preferredDate?: true
    preferredTime?: true
    location?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    status?: true
    notes?: true
    adminNotes?: true
    confirmedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestDriveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestDrive to aggregate.
     */
    where?: TestDriveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestDrives to fetch.
     */
    orderBy?: TestDriveOrderByWithRelationInput | TestDriveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestDriveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestDrives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestDrives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestDrives
    **/
    _count?: true | TestDriveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestDriveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestDriveMaxAggregateInputType
  }

  export type GetTestDriveAggregateType<T extends TestDriveAggregateArgs> = {
        [P in keyof T & keyof AggregateTestDrive]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestDrive[P]>
      : GetScalarType<T[P], AggregateTestDrive[P]>
  }




  export type TestDriveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestDriveWhereInput
    orderBy?: TestDriveOrderByWithAggregationInput | TestDriveOrderByWithAggregationInput[]
    by: TestDriveScalarFieldEnum[] | TestDriveScalarFieldEnum
    having?: TestDriveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestDriveCountAggregateInputType | true
    _min?: TestDriveMinAggregateInputType
    _max?: TestDriveMaxAggregateInputType
  }

  export type TestDriveGroupByOutputType = {
    id: string
    userId: string
    vehicleId: string
    preferredDate: Date
    preferredTime: string
    location: string
    firstName: string
    lastName: string
    email: string
    phone: string
    status: $Enums.BookingStatus
    notes: string | null
    adminNotes: string | null
    confirmedAt: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TestDriveCountAggregateOutputType | null
    _min: TestDriveMinAggregateOutputType | null
    _max: TestDriveMaxAggregateOutputType | null
  }

  type GetTestDriveGroupByPayload<T extends TestDriveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestDriveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestDriveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestDriveGroupByOutputType[P]>
            : GetScalarType<T[P], TestDriveGroupByOutputType[P]>
        }
      >
    >


  export type TestDriveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vehicleId?: boolean
    preferredDate?: boolean
    preferredTime?: boolean
    location?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    notes?: boolean
    adminNotes?: boolean
    confirmedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testDrive"]>

  export type TestDriveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vehicleId?: boolean
    preferredDate?: boolean
    preferredTime?: boolean
    location?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    notes?: boolean
    adminNotes?: boolean
    confirmedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testDrive"]>

  export type TestDriveSelectScalar = {
    id?: boolean
    userId?: boolean
    vehicleId?: boolean
    preferredDate?: boolean
    preferredTime?: boolean
    location?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    notes?: boolean
    adminNotes?: boolean
    confirmedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TestDriveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }
  export type TestDriveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }

  export type $TestDrivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestDrive"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      vehicle: Prisma.$VehiclePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      vehicleId: string
      preferredDate: Date
      preferredTime: string
      location: string
      firstName: string
      lastName: string
      email: string
      phone: string
      status: $Enums.BookingStatus
      notes: string | null
      adminNotes: string | null
      confirmedAt: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testDrive"]>
    composites: {}
  }

  type TestDriveGetPayload<S extends boolean | null | undefined | TestDriveDefaultArgs> = $Result.GetResult<Prisma.$TestDrivePayload, S>

  type TestDriveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TestDriveFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TestDriveCountAggregateInputType | true
    }

  export interface TestDriveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestDrive'], meta: { name: 'TestDrive' } }
    /**
     * Find zero or one TestDrive that matches the filter.
     * @param {TestDriveFindUniqueArgs} args - Arguments to find a TestDrive
     * @example
     * // Get one TestDrive
     * const testDrive = await prisma.testDrive.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestDriveFindUniqueArgs>(args: SelectSubset<T, TestDriveFindUniqueArgs<ExtArgs>>): Prisma__TestDriveClient<$Result.GetResult<Prisma.$TestDrivePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TestDrive that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TestDriveFindUniqueOrThrowArgs} args - Arguments to find a TestDrive
     * @example
     * // Get one TestDrive
     * const testDrive = await prisma.testDrive.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestDriveFindUniqueOrThrowArgs>(args: SelectSubset<T, TestDriveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestDriveClient<$Result.GetResult<Prisma.$TestDrivePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TestDrive that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestDriveFindFirstArgs} args - Arguments to find a TestDrive
     * @example
     * // Get one TestDrive
     * const testDrive = await prisma.testDrive.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestDriveFindFirstArgs>(args?: SelectSubset<T, TestDriveFindFirstArgs<ExtArgs>>): Prisma__TestDriveClient<$Result.GetResult<Prisma.$TestDrivePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TestDrive that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestDriveFindFirstOrThrowArgs} args - Arguments to find a TestDrive
     * @example
     * // Get one TestDrive
     * const testDrive = await prisma.testDrive.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestDriveFindFirstOrThrowArgs>(args?: SelectSubset<T, TestDriveFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestDriveClient<$Result.GetResult<Prisma.$TestDrivePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TestDrives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestDriveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestDrives
     * const testDrives = await prisma.testDrive.findMany()
     * 
     * // Get first 10 TestDrives
     * const testDrives = await prisma.testDrive.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testDriveWithIdOnly = await prisma.testDrive.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestDriveFindManyArgs>(args?: SelectSubset<T, TestDriveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestDrivePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TestDrive.
     * @param {TestDriveCreateArgs} args - Arguments to create a TestDrive.
     * @example
     * // Create one TestDrive
     * const TestDrive = await prisma.testDrive.create({
     *   data: {
     *     // ... data to create a TestDrive
     *   }
     * })
     * 
     */
    create<T extends TestDriveCreateArgs>(args: SelectSubset<T, TestDriveCreateArgs<ExtArgs>>): Prisma__TestDriveClient<$Result.GetResult<Prisma.$TestDrivePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TestDrives.
     * @param {TestDriveCreateManyArgs} args - Arguments to create many TestDrives.
     * @example
     * // Create many TestDrives
     * const testDrive = await prisma.testDrive.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestDriveCreateManyArgs>(args?: SelectSubset<T, TestDriveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestDrives and returns the data saved in the database.
     * @param {TestDriveCreateManyAndReturnArgs} args - Arguments to create many TestDrives.
     * @example
     * // Create many TestDrives
     * const testDrive = await prisma.testDrive.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestDrives and only return the `id`
     * const testDriveWithIdOnly = await prisma.testDrive.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestDriveCreateManyAndReturnArgs>(args?: SelectSubset<T, TestDriveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestDrivePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TestDrive.
     * @param {TestDriveDeleteArgs} args - Arguments to delete one TestDrive.
     * @example
     * // Delete one TestDrive
     * const TestDrive = await prisma.testDrive.delete({
     *   where: {
     *     // ... filter to delete one TestDrive
     *   }
     * })
     * 
     */
    delete<T extends TestDriveDeleteArgs>(args: SelectSubset<T, TestDriveDeleteArgs<ExtArgs>>): Prisma__TestDriveClient<$Result.GetResult<Prisma.$TestDrivePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TestDrive.
     * @param {TestDriveUpdateArgs} args - Arguments to update one TestDrive.
     * @example
     * // Update one TestDrive
     * const testDrive = await prisma.testDrive.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestDriveUpdateArgs>(args: SelectSubset<T, TestDriveUpdateArgs<ExtArgs>>): Prisma__TestDriveClient<$Result.GetResult<Prisma.$TestDrivePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TestDrives.
     * @param {TestDriveDeleteManyArgs} args - Arguments to filter TestDrives to delete.
     * @example
     * // Delete a few TestDrives
     * const { count } = await prisma.testDrive.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestDriveDeleteManyArgs>(args?: SelectSubset<T, TestDriveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestDrives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestDriveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestDrives
     * const testDrive = await prisma.testDrive.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestDriveUpdateManyArgs>(args: SelectSubset<T, TestDriveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TestDrive.
     * @param {TestDriveUpsertArgs} args - Arguments to update or create a TestDrive.
     * @example
     * // Update or create a TestDrive
     * const testDrive = await prisma.testDrive.upsert({
     *   create: {
     *     // ... data to create a TestDrive
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestDrive we want to update
     *   }
     * })
     */
    upsert<T extends TestDriveUpsertArgs>(args: SelectSubset<T, TestDriveUpsertArgs<ExtArgs>>): Prisma__TestDriveClient<$Result.GetResult<Prisma.$TestDrivePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TestDrives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestDriveCountArgs} args - Arguments to filter TestDrives to count.
     * @example
     * // Count the number of TestDrives
     * const count = await prisma.testDrive.count({
     *   where: {
     *     // ... the filter for the TestDrives we want to count
     *   }
     * })
    **/
    count<T extends TestDriveCountArgs>(
      args?: Subset<T, TestDriveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestDriveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestDrive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestDriveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestDriveAggregateArgs>(args: Subset<T, TestDriveAggregateArgs>): Prisma.PrismaPromise<GetTestDriveAggregateType<T>>

    /**
     * Group by TestDrive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestDriveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestDriveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestDriveGroupByArgs['orderBy'] }
        : { orderBy?: TestDriveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestDriveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestDriveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestDrive model
   */
  readonly fields: TestDriveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestDrive.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestDriveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestDrive model
   */ 
  interface TestDriveFieldRefs {
    readonly id: FieldRef<"TestDrive", 'String'>
    readonly userId: FieldRef<"TestDrive", 'String'>
    readonly vehicleId: FieldRef<"TestDrive", 'String'>
    readonly preferredDate: FieldRef<"TestDrive", 'DateTime'>
    readonly preferredTime: FieldRef<"TestDrive", 'String'>
    readonly location: FieldRef<"TestDrive", 'String'>
    readonly firstName: FieldRef<"TestDrive", 'String'>
    readonly lastName: FieldRef<"TestDrive", 'String'>
    readonly email: FieldRef<"TestDrive", 'String'>
    readonly phone: FieldRef<"TestDrive", 'String'>
    readonly status: FieldRef<"TestDrive", 'BookingStatus'>
    readonly notes: FieldRef<"TestDrive", 'String'>
    readonly adminNotes: FieldRef<"TestDrive", 'String'>
    readonly confirmedAt: FieldRef<"TestDrive", 'DateTime'>
    readonly completedAt: FieldRef<"TestDrive", 'DateTime'>
    readonly createdAt: FieldRef<"TestDrive", 'DateTime'>
    readonly updatedAt: FieldRef<"TestDrive", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TestDrive findUnique
   */
  export type TestDriveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestDrive
     */
    select?: TestDriveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestDriveInclude<ExtArgs> | null
    /**
     * Filter, which TestDrive to fetch.
     */
    where: TestDriveWhereUniqueInput
  }

  /**
   * TestDrive findUniqueOrThrow
   */
  export type TestDriveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestDrive
     */
    select?: TestDriveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestDriveInclude<ExtArgs> | null
    /**
     * Filter, which TestDrive to fetch.
     */
    where: TestDriveWhereUniqueInput
  }

  /**
   * TestDrive findFirst
   */
  export type TestDriveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestDrive
     */
    select?: TestDriveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestDriveInclude<ExtArgs> | null
    /**
     * Filter, which TestDrive to fetch.
     */
    where?: TestDriveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestDrives to fetch.
     */
    orderBy?: TestDriveOrderByWithRelationInput | TestDriveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestDrives.
     */
    cursor?: TestDriveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestDrives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestDrives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestDrives.
     */
    distinct?: TestDriveScalarFieldEnum | TestDriveScalarFieldEnum[]
  }

  /**
   * TestDrive findFirstOrThrow
   */
  export type TestDriveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestDrive
     */
    select?: TestDriveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestDriveInclude<ExtArgs> | null
    /**
     * Filter, which TestDrive to fetch.
     */
    where?: TestDriveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestDrives to fetch.
     */
    orderBy?: TestDriveOrderByWithRelationInput | TestDriveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestDrives.
     */
    cursor?: TestDriveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestDrives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestDrives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestDrives.
     */
    distinct?: TestDriveScalarFieldEnum | TestDriveScalarFieldEnum[]
  }

  /**
   * TestDrive findMany
   */
  export type TestDriveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestDrive
     */
    select?: TestDriveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestDriveInclude<ExtArgs> | null
    /**
     * Filter, which TestDrives to fetch.
     */
    where?: TestDriveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestDrives to fetch.
     */
    orderBy?: TestDriveOrderByWithRelationInput | TestDriveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestDrives.
     */
    cursor?: TestDriveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestDrives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestDrives.
     */
    skip?: number
    distinct?: TestDriveScalarFieldEnum | TestDriveScalarFieldEnum[]
  }

  /**
   * TestDrive create
   */
  export type TestDriveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestDrive
     */
    select?: TestDriveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestDriveInclude<ExtArgs> | null
    /**
     * The data needed to create a TestDrive.
     */
    data: XOR<TestDriveCreateInput, TestDriveUncheckedCreateInput>
  }

  /**
   * TestDrive createMany
   */
  export type TestDriveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestDrives.
     */
    data: TestDriveCreateManyInput | TestDriveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestDrive createManyAndReturn
   */
  export type TestDriveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestDrive
     */
    select?: TestDriveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TestDrives.
     */
    data: TestDriveCreateManyInput | TestDriveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestDriveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestDrive update
   */
  export type TestDriveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestDrive
     */
    select?: TestDriveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestDriveInclude<ExtArgs> | null
    /**
     * The data needed to update a TestDrive.
     */
    data: XOR<TestDriveUpdateInput, TestDriveUncheckedUpdateInput>
    /**
     * Choose, which TestDrive to update.
     */
    where: TestDriveWhereUniqueInput
  }

  /**
   * TestDrive updateMany
   */
  export type TestDriveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestDrives.
     */
    data: XOR<TestDriveUpdateManyMutationInput, TestDriveUncheckedUpdateManyInput>
    /**
     * Filter which TestDrives to update
     */
    where?: TestDriveWhereInput
  }

  /**
   * TestDrive upsert
   */
  export type TestDriveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestDrive
     */
    select?: TestDriveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestDriveInclude<ExtArgs> | null
    /**
     * The filter to search for the TestDrive to update in case it exists.
     */
    where: TestDriveWhereUniqueInput
    /**
     * In case the TestDrive found by the `where` argument doesn't exist, create a new TestDrive with this data.
     */
    create: XOR<TestDriveCreateInput, TestDriveUncheckedCreateInput>
    /**
     * In case the TestDrive was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestDriveUpdateInput, TestDriveUncheckedUpdateInput>
  }

  /**
   * TestDrive delete
   */
  export type TestDriveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestDrive
     */
    select?: TestDriveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestDriveInclude<ExtArgs> | null
    /**
     * Filter which TestDrive to delete.
     */
    where: TestDriveWhereUniqueInput
  }

  /**
   * TestDrive deleteMany
   */
  export type TestDriveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestDrives to delete
     */
    where?: TestDriveWhereInput
  }

  /**
   * TestDrive without action
   */
  export type TestDriveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestDrive
     */
    select?: TestDriveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestDriveInclude<ExtArgs> | null
  }


  /**
   * Model Inquiry
   */

  export type AggregateInquiry = {
    _count: InquiryCountAggregateOutputType | null
    _min: InquiryMinAggregateOutputType | null
    _max: InquiryMaxAggregateOutputType | null
  }

  export type InquiryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    vehicleId: string | null
    type: $Enums.InquiryType | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    subject: string | null
    message: string | null
    status: $Enums.InquiryStatus | null
    assignedTo: string | null
    response: string | null
    respondedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InquiryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    vehicleId: string | null
    type: $Enums.InquiryType | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    subject: string | null
    message: string | null
    status: $Enums.InquiryStatus | null
    assignedTo: string | null
    response: string | null
    respondedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InquiryCountAggregateOutputType = {
    id: number
    userId: number
    vehicleId: number
    type: number
    firstName: number
    lastName: number
    email: number
    phone: number
    subject: number
    message: number
    status: number
    assignedTo: number
    response: number
    respondedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InquiryMinAggregateInputType = {
    id?: true
    userId?: true
    vehicleId?: true
    type?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    status?: true
    assignedTo?: true
    response?: true
    respondedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InquiryMaxAggregateInputType = {
    id?: true
    userId?: true
    vehicleId?: true
    type?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    status?: true
    assignedTo?: true
    response?: true
    respondedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InquiryCountAggregateInputType = {
    id?: true
    userId?: true
    vehicleId?: true
    type?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    status?: true
    assignedTo?: true
    response?: true
    respondedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InquiryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inquiry to aggregate.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inquiries
    **/
    _count?: true | InquiryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InquiryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InquiryMaxAggregateInputType
  }

  export type GetInquiryAggregateType<T extends InquiryAggregateArgs> = {
        [P in keyof T & keyof AggregateInquiry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInquiry[P]>
      : GetScalarType<T[P], AggregateInquiry[P]>
  }




  export type InquiryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryWhereInput
    orderBy?: InquiryOrderByWithAggregationInput | InquiryOrderByWithAggregationInput[]
    by: InquiryScalarFieldEnum[] | InquiryScalarFieldEnum
    having?: InquiryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InquiryCountAggregateInputType | true
    _min?: InquiryMinAggregateInputType
    _max?: InquiryMaxAggregateInputType
  }

  export type InquiryGroupByOutputType = {
    id: string
    userId: string | null
    vehicleId: string | null
    type: $Enums.InquiryType
    firstName: string
    lastName: string
    email: string
    phone: string
    subject: string | null
    message: string
    status: $Enums.InquiryStatus
    assignedTo: string | null
    response: string | null
    respondedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: InquiryCountAggregateOutputType | null
    _min: InquiryMinAggregateOutputType | null
    _max: InquiryMaxAggregateOutputType | null
  }

  type GetInquiryGroupByPayload<T extends InquiryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InquiryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InquiryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InquiryGroupByOutputType[P]>
            : GetScalarType<T[P], InquiryGroupByOutputType[P]>
        }
      >
    >


  export type InquirySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vehicleId?: boolean
    type?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    assignedTo?: boolean
    response?: boolean
    respondedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Inquiry$userArgs<ExtArgs>
    vehicle?: boolean | Inquiry$vehicleArgs<ExtArgs>
  }, ExtArgs["result"]["inquiry"]>

  export type InquirySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vehicleId?: boolean
    type?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    assignedTo?: boolean
    response?: boolean
    respondedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Inquiry$userArgs<ExtArgs>
    vehicle?: boolean | Inquiry$vehicleArgs<ExtArgs>
  }, ExtArgs["result"]["inquiry"]>

  export type InquirySelectScalar = {
    id?: boolean
    userId?: boolean
    vehicleId?: boolean
    type?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    assignedTo?: boolean
    response?: boolean
    respondedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InquiryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Inquiry$userArgs<ExtArgs>
    vehicle?: boolean | Inquiry$vehicleArgs<ExtArgs>
  }
  export type InquiryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Inquiry$userArgs<ExtArgs>
    vehicle?: boolean | Inquiry$vehicleArgs<ExtArgs>
  }

  export type $InquiryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inquiry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      vehicle: Prisma.$VehiclePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      vehicleId: string | null
      type: $Enums.InquiryType
      firstName: string
      lastName: string
      email: string
      phone: string
      subject: string | null
      message: string
      status: $Enums.InquiryStatus
      assignedTo: string | null
      response: string | null
      respondedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inquiry"]>
    composites: {}
  }

  type InquiryGetPayload<S extends boolean | null | undefined | InquiryDefaultArgs> = $Result.GetResult<Prisma.$InquiryPayload, S>

  type InquiryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InquiryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InquiryCountAggregateInputType | true
    }

  export interface InquiryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inquiry'], meta: { name: 'Inquiry' } }
    /**
     * Find zero or one Inquiry that matches the filter.
     * @param {InquiryFindUniqueArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InquiryFindUniqueArgs>(args: SelectSubset<T, InquiryFindUniqueArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Inquiry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InquiryFindUniqueOrThrowArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InquiryFindUniqueOrThrowArgs>(args: SelectSubset<T, InquiryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Inquiry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindFirstArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InquiryFindFirstArgs>(args?: SelectSubset<T, InquiryFindFirstArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Inquiry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindFirstOrThrowArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InquiryFindFirstOrThrowArgs>(args?: SelectSubset<T, InquiryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Inquiries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inquiries
     * const inquiries = await prisma.inquiry.findMany()
     * 
     * // Get first 10 Inquiries
     * const inquiries = await prisma.inquiry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inquiryWithIdOnly = await prisma.inquiry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InquiryFindManyArgs>(args?: SelectSubset<T, InquiryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Inquiry.
     * @param {InquiryCreateArgs} args - Arguments to create a Inquiry.
     * @example
     * // Create one Inquiry
     * const Inquiry = await prisma.inquiry.create({
     *   data: {
     *     // ... data to create a Inquiry
     *   }
     * })
     * 
     */
    create<T extends InquiryCreateArgs>(args: SelectSubset<T, InquiryCreateArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Inquiries.
     * @param {InquiryCreateManyArgs} args - Arguments to create many Inquiries.
     * @example
     * // Create many Inquiries
     * const inquiry = await prisma.inquiry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InquiryCreateManyArgs>(args?: SelectSubset<T, InquiryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inquiries and returns the data saved in the database.
     * @param {InquiryCreateManyAndReturnArgs} args - Arguments to create many Inquiries.
     * @example
     * // Create many Inquiries
     * const inquiry = await prisma.inquiry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inquiries and only return the `id`
     * const inquiryWithIdOnly = await prisma.inquiry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InquiryCreateManyAndReturnArgs>(args?: SelectSubset<T, InquiryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Inquiry.
     * @param {InquiryDeleteArgs} args - Arguments to delete one Inquiry.
     * @example
     * // Delete one Inquiry
     * const Inquiry = await prisma.inquiry.delete({
     *   where: {
     *     // ... filter to delete one Inquiry
     *   }
     * })
     * 
     */
    delete<T extends InquiryDeleteArgs>(args: SelectSubset<T, InquiryDeleteArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Inquiry.
     * @param {InquiryUpdateArgs} args - Arguments to update one Inquiry.
     * @example
     * // Update one Inquiry
     * const inquiry = await prisma.inquiry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InquiryUpdateArgs>(args: SelectSubset<T, InquiryUpdateArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Inquiries.
     * @param {InquiryDeleteManyArgs} args - Arguments to filter Inquiries to delete.
     * @example
     * // Delete a few Inquiries
     * const { count } = await prisma.inquiry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InquiryDeleteManyArgs>(args?: SelectSubset<T, InquiryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inquiries
     * const inquiry = await prisma.inquiry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InquiryUpdateManyArgs>(args: SelectSubset<T, InquiryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inquiry.
     * @param {InquiryUpsertArgs} args - Arguments to update or create a Inquiry.
     * @example
     * // Update or create a Inquiry
     * const inquiry = await prisma.inquiry.upsert({
     *   create: {
     *     // ... data to create a Inquiry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inquiry we want to update
     *   }
     * })
     */
    upsert<T extends InquiryUpsertArgs>(args: SelectSubset<T, InquiryUpsertArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryCountArgs} args - Arguments to filter Inquiries to count.
     * @example
     * // Count the number of Inquiries
     * const count = await prisma.inquiry.count({
     *   where: {
     *     // ... the filter for the Inquiries we want to count
     *   }
     * })
    **/
    count<T extends InquiryCountArgs>(
      args?: Subset<T, InquiryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InquiryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InquiryAggregateArgs>(args: Subset<T, InquiryAggregateArgs>): Prisma.PrismaPromise<GetInquiryAggregateType<T>>

    /**
     * Group by Inquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InquiryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InquiryGroupByArgs['orderBy'] }
        : { orderBy?: InquiryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InquiryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInquiryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inquiry model
   */
  readonly fields: InquiryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inquiry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InquiryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Inquiry$userArgs<ExtArgs> = {}>(args?: Subset<T, Inquiry$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    vehicle<T extends Inquiry$vehicleArgs<ExtArgs> = {}>(args?: Subset<T, Inquiry$vehicleArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inquiry model
   */ 
  interface InquiryFieldRefs {
    readonly id: FieldRef<"Inquiry", 'String'>
    readonly userId: FieldRef<"Inquiry", 'String'>
    readonly vehicleId: FieldRef<"Inquiry", 'String'>
    readonly type: FieldRef<"Inquiry", 'InquiryType'>
    readonly firstName: FieldRef<"Inquiry", 'String'>
    readonly lastName: FieldRef<"Inquiry", 'String'>
    readonly email: FieldRef<"Inquiry", 'String'>
    readonly phone: FieldRef<"Inquiry", 'String'>
    readonly subject: FieldRef<"Inquiry", 'String'>
    readonly message: FieldRef<"Inquiry", 'String'>
    readonly status: FieldRef<"Inquiry", 'InquiryStatus'>
    readonly assignedTo: FieldRef<"Inquiry", 'String'>
    readonly response: FieldRef<"Inquiry", 'String'>
    readonly respondedAt: FieldRef<"Inquiry", 'DateTime'>
    readonly createdAt: FieldRef<"Inquiry", 'DateTime'>
    readonly updatedAt: FieldRef<"Inquiry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inquiry findUnique
   */
  export type InquiryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry findUniqueOrThrow
   */
  export type InquiryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry findFirst
   */
  export type InquiryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inquiries.
     */
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry findFirstOrThrow
   */
  export type InquiryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inquiries.
     */
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry findMany
   */
  export type InquiryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiries to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry create
   */
  export type InquiryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inquiry.
     */
    data: XOR<InquiryCreateInput, InquiryUncheckedCreateInput>
  }

  /**
   * Inquiry createMany
   */
  export type InquiryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inquiries.
     */
    data: InquiryCreateManyInput | InquiryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inquiry createManyAndReturn
   */
  export type InquiryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Inquiries.
     */
    data: InquiryCreateManyInput | InquiryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inquiry update
   */
  export type InquiryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inquiry.
     */
    data: XOR<InquiryUpdateInput, InquiryUncheckedUpdateInput>
    /**
     * Choose, which Inquiry to update.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry updateMany
   */
  export type InquiryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inquiries.
     */
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyInput>
    /**
     * Filter which Inquiries to update
     */
    where?: InquiryWhereInput
  }

  /**
   * Inquiry upsert
   */
  export type InquiryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inquiry to update in case it exists.
     */
    where: InquiryWhereUniqueInput
    /**
     * In case the Inquiry found by the `where` argument doesn't exist, create a new Inquiry with this data.
     */
    create: XOR<InquiryCreateInput, InquiryUncheckedCreateInput>
    /**
     * In case the Inquiry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InquiryUpdateInput, InquiryUncheckedUpdateInput>
  }

  /**
   * Inquiry delete
   */
  export type InquiryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter which Inquiry to delete.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry deleteMany
   */
  export type InquiryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inquiries to delete
     */
    where?: InquiryWhereInput
  }

  /**
   * Inquiry.user
   */
  export type Inquiry$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Inquiry.vehicle
   */
  export type Inquiry$vehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    where?: VehicleWhereInput
  }

  /**
   * Inquiry without action
   */
  export type InquiryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
  }


  /**
   * Model FinancingApplication
   */

  export type AggregateFinancingApplication = {
    _count: FinancingApplicationCountAggregateOutputType | null
    _avg: FinancingApplicationAvgAggregateOutputType | null
    _sum: FinancingApplicationSumAggregateOutputType | null
    _min: FinancingApplicationMinAggregateOutputType | null
    _max: FinancingApplicationMaxAggregateOutputType | null
  }

  export type FinancingApplicationAvgAggregateOutputType = {
    monthlyIncome: Decimal | null
    yearsEmployed: number | null
    downPayment: Decimal | null
    loanTerm: number | null
    estimatedMonthly: Decimal | null
    approvedAmount: Decimal | null
    approvedTerm: number | null
  }

  export type FinancingApplicationSumAggregateOutputType = {
    monthlyIncome: Decimal | null
    yearsEmployed: number | null
    downPayment: Decimal | null
    loanTerm: number | null
    estimatedMonthly: Decimal | null
    approvedAmount: Decimal | null
    approvedTerm: number | null
  }

  export type FinancingApplicationMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    birthDate: Date | null
    civilStatus: string | null
    address: string | null
    employmentStatus: string | null
    monthlyIncome: Decimal | null
    employer: string | null
    yearsEmployed: number | null
    vehicleId: string | null
    vehicleName: string | null
    downPayment: Decimal | null
    loanTerm: number | null
    estimatedMonthly: Decimal | null
    status: $Enums.ApplicationStatus | null
    approvedAmount: Decimal | null
    approvedTerm: number | null
    applicantNotes: string | null
    adminNotes: string | null
    submittedAt: Date | null
    reviewedAt: Date | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FinancingApplicationMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    birthDate: Date | null
    civilStatus: string | null
    address: string | null
    employmentStatus: string | null
    monthlyIncome: Decimal | null
    employer: string | null
    yearsEmployed: number | null
    vehicleId: string | null
    vehicleName: string | null
    downPayment: Decimal | null
    loanTerm: number | null
    estimatedMonthly: Decimal | null
    status: $Enums.ApplicationStatus | null
    approvedAmount: Decimal | null
    approvedTerm: number | null
    applicantNotes: string | null
    adminNotes: string | null
    submittedAt: Date | null
    reviewedAt: Date | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FinancingApplicationCountAggregateOutputType = {
    id: number
    firstName: number
    middleName: number
    lastName: number
    email: number
    phone: number
    birthDate: number
    civilStatus: number
    address: number
    employmentStatus: number
    monthlyIncome: number
    employer: number
    yearsEmployed: number
    vehicleId: number
    vehicleName: number
    downPayment: number
    loanTerm: number
    estimatedMonthly: number
    validIds: number
    proofOfIncome: number
    proofOfBilling: number
    status: number
    approvedAmount: number
    approvedTerm: number
    applicantNotes: number
    adminNotes: number
    submittedAt: number
    reviewedAt: number
    approvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FinancingApplicationAvgAggregateInputType = {
    monthlyIncome?: true
    yearsEmployed?: true
    downPayment?: true
    loanTerm?: true
    estimatedMonthly?: true
    approvedAmount?: true
    approvedTerm?: true
  }

  export type FinancingApplicationSumAggregateInputType = {
    monthlyIncome?: true
    yearsEmployed?: true
    downPayment?: true
    loanTerm?: true
    estimatedMonthly?: true
    approvedAmount?: true
    approvedTerm?: true
  }

  export type FinancingApplicationMinAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    email?: true
    phone?: true
    birthDate?: true
    civilStatus?: true
    address?: true
    employmentStatus?: true
    monthlyIncome?: true
    employer?: true
    yearsEmployed?: true
    vehicleId?: true
    vehicleName?: true
    downPayment?: true
    loanTerm?: true
    estimatedMonthly?: true
    status?: true
    approvedAmount?: true
    approvedTerm?: true
    applicantNotes?: true
    adminNotes?: true
    submittedAt?: true
    reviewedAt?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FinancingApplicationMaxAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    email?: true
    phone?: true
    birthDate?: true
    civilStatus?: true
    address?: true
    employmentStatus?: true
    monthlyIncome?: true
    employer?: true
    yearsEmployed?: true
    vehicleId?: true
    vehicleName?: true
    downPayment?: true
    loanTerm?: true
    estimatedMonthly?: true
    status?: true
    approvedAmount?: true
    approvedTerm?: true
    applicantNotes?: true
    adminNotes?: true
    submittedAt?: true
    reviewedAt?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FinancingApplicationCountAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    email?: true
    phone?: true
    birthDate?: true
    civilStatus?: true
    address?: true
    employmentStatus?: true
    monthlyIncome?: true
    employer?: true
    yearsEmployed?: true
    vehicleId?: true
    vehicleName?: true
    downPayment?: true
    loanTerm?: true
    estimatedMonthly?: true
    validIds?: true
    proofOfIncome?: true
    proofOfBilling?: true
    status?: true
    approvedAmount?: true
    approvedTerm?: true
    applicantNotes?: true
    adminNotes?: true
    submittedAt?: true
    reviewedAt?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FinancingApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancingApplication to aggregate.
     */
    where?: FinancingApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancingApplications to fetch.
     */
    orderBy?: FinancingApplicationOrderByWithRelationInput | FinancingApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinancingApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancingApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancingApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinancingApplications
    **/
    _count?: true | FinancingApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinancingApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinancingApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancingApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancingApplicationMaxAggregateInputType
  }

  export type GetFinancingApplicationAggregateType<T extends FinancingApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancingApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancingApplication[P]>
      : GetScalarType<T[P], AggregateFinancingApplication[P]>
  }




  export type FinancingApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancingApplicationWhereInput
    orderBy?: FinancingApplicationOrderByWithAggregationInput | FinancingApplicationOrderByWithAggregationInput[]
    by: FinancingApplicationScalarFieldEnum[] | FinancingApplicationScalarFieldEnum
    having?: FinancingApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancingApplicationCountAggregateInputType | true
    _avg?: FinancingApplicationAvgAggregateInputType
    _sum?: FinancingApplicationSumAggregateInputType
    _min?: FinancingApplicationMinAggregateInputType
    _max?: FinancingApplicationMaxAggregateInputType
  }

  export type FinancingApplicationGroupByOutputType = {
    id: string
    firstName: string
    middleName: string | null
    lastName: string
    email: string
    phone: string
    birthDate: Date
    civilStatus: string
    address: string
    employmentStatus: string
    monthlyIncome: Decimal
    employer: string | null
    yearsEmployed: number | null
    vehicleId: string
    vehicleName: string
    downPayment: Decimal
    loanTerm: number
    estimatedMonthly: Decimal
    validIds: JsonValue
    proofOfIncome: JsonValue
    proofOfBilling: JsonValue
    status: $Enums.ApplicationStatus
    approvedAmount: Decimal | null
    approvedTerm: number | null
    applicantNotes: string | null
    adminNotes: string | null
    submittedAt: Date
    reviewedAt: Date | null
    approvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: FinancingApplicationCountAggregateOutputType | null
    _avg: FinancingApplicationAvgAggregateOutputType | null
    _sum: FinancingApplicationSumAggregateOutputType | null
    _min: FinancingApplicationMinAggregateOutputType | null
    _max: FinancingApplicationMaxAggregateOutputType | null
  }

  type GetFinancingApplicationGroupByPayload<T extends FinancingApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancingApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancingApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancingApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], FinancingApplicationGroupByOutputType[P]>
        }
      >
    >


  export type FinancingApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    birthDate?: boolean
    civilStatus?: boolean
    address?: boolean
    employmentStatus?: boolean
    monthlyIncome?: boolean
    employer?: boolean
    yearsEmployed?: boolean
    vehicleId?: boolean
    vehicleName?: boolean
    downPayment?: boolean
    loanTerm?: boolean
    estimatedMonthly?: boolean
    validIds?: boolean
    proofOfIncome?: boolean
    proofOfBilling?: boolean
    status?: boolean
    approvedAmount?: boolean
    approvedTerm?: boolean
    applicantNotes?: boolean
    adminNotes?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["financingApplication"]>

  export type FinancingApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    birthDate?: boolean
    civilStatus?: boolean
    address?: boolean
    employmentStatus?: boolean
    monthlyIncome?: boolean
    employer?: boolean
    yearsEmployed?: boolean
    vehicleId?: boolean
    vehicleName?: boolean
    downPayment?: boolean
    loanTerm?: boolean
    estimatedMonthly?: boolean
    validIds?: boolean
    proofOfIncome?: boolean
    proofOfBilling?: boolean
    status?: boolean
    approvedAmount?: boolean
    approvedTerm?: boolean
    applicantNotes?: boolean
    adminNotes?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["financingApplication"]>

  export type FinancingApplicationSelectScalar = {
    id?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    birthDate?: boolean
    civilStatus?: boolean
    address?: boolean
    employmentStatus?: boolean
    monthlyIncome?: boolean
    employer?: boolean
    yearsEmployed?: boolean
    vehicleId?: boolean
    vehicleName?: boolean
    downPayment?: boolean
    loanTerm?: boolean
    estimatedMonthly?: boolean
    validIds?: boolean
    proofOfIncome?: boolean
    proofOfBilling?: boolean
    status?: boolean
    approvedAmount?: boolean
    approvedTerm?: boolean
    applicantNotes?: boolean
    adminNotes?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $FinancingApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinancingApplication"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      middleName: string | null
      lastName: string
      email: string
      phone: string
      birthDate: Date
      civilStatus: string
      address: string
      employmentStatus: string
      monthlyIncome: Prisma.Decimal
      employer: string | null
      yearsEmployed: number | null
      vehicleId: string
      vehicleName: string
      downPayment: Prisma.Decimal
      loanTerm: number
      estimatedMonthly: Prisma.Decimal
      validIds: Prisma.JsonValue
      proofOfIncome: Prisma.JsonValue
      proofOfBilling: Prisma.JsonValue
      status: $Enums.ApplicationStatus
      approvedAmount: Prisma.Decimal | null
      approvedTerm: number | null
      applicantNotes: string | null
      adminNotes: string | null
      submittedAt: Date
      reviewedAt: Date | null
      approvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["financingApplication"]>
    composites: {}
  }

  type FinancingApplicationGetPayload<S extends boolean | null | undefined | FinancingApplicationDefaultArgs> = $Result.GetResult<Prisma.$FinancingApplicationPayload, S>

  type FinancingApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FinancingApplicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FinancingApplicationCountAggregateInputType | true
    }

  export interface FinancingApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancingApplication'], meta: { name: 'FinancingApplication' } }
    /**
     * Find zero or one FinancingApplication that matches the filter.
     * @param {FinancingApplicationFindUniqueArgs} args - Arguments to find a FinancingApplication
     * @example
     * // Get one FinancingApplication
     * const financingApplication = await prisma.financingApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinancingApplicationFindUniqueArgs>(args: SelectSubset<T, FinancingApplicationFindUniqueArgs<ExtArgs>>): Prisma__FinancingApplicationClient<$Result.GetResult<Prisma.$FinancingApplicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FinancingApplication that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FinancingApplicationFindUniqueOrThrowArgs} args - Arguments to find a FinancingApplication
     * @example
     * // Get one FinancingApplication
     * const financingApplication = await prisma.financingApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinancingApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, FinancingApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinancingApplicationClient<$Result.GetResult<Prisma.$FinancingApplicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FinancingApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancingApplicationFindFirstArgs} args - Arguments to find a FinancingApplication
     * @example
     * // Get one FinancingApplication
     * const financingApplication = await prisma.financingApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinancingApplicationFindFirstArgs>(args?: SelectSubset<T, FinancingApplicationFindFirstArgs<ExtArgs>>): Prisma__FinancingApplicationClient<$Result.GetResult<Prisma.$FinancingApplicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FinancingApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancingApplicationFindFirstOrThrowArgs} args - Arguments to find a FinancingApplication
     * @example
     * // Get one FinancingApplication
     * const financingApplication = await prisma.financingApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinancingApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, FinancingApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinancingApplicationClient<$Result.GetResult<Prisma.$FinancingApplicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FinancingApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancingApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinancingApplications
     * const financingApplications = await prisma.financingApplication.findMany()
     * 
     * // Get first 10 FinancingApplications
     * const financingApplications = await prisma.financingApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financingApplicationWithIdOnly = await prisma.financingApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinancingApplicationFindManyArgs>(args?: SelectSubset<T, FinancingApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancingApplicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FinancingApplication.
     * @param {FinancingApplicationCreateArgs} args - Arguments to create a FinancingApplication.
     * @example
     * // Create one FinancingApplication
     * const FinancingApplication = await prisma.financingApplication.create({
     *   data: {
     *     // ... data to create a FinancingApplication
     *   }
     * })
     * 
     */
    create<T extends FinancingApplicationCreateArgs>(args: SelectSubset<T, FinancingApplicationCreateArgs<ExtArgs>>): Prisma__FinancingApplicationClient<$Result.GetResult<Prisma.$FinancingApplicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FinancingApplications.
     * @param {FinancingApplicationCreateManyArgs} args - Arguments to create many FinancingApplications.
     * @example
     * // Create many FinancingApplications
     * const financingApplication = await prisma.financingApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinancingApplicationCreateManyArgs>(args?: SelectSubset<T, FinancingApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinancingApplications and returns the data saved in the database.
     * @param {FinancingApplicationCreateManyAndReturnArgs} args - Arguments to create many FinancingApplications.
     * @example
     * // Create many FinancingApplications
     * const financingApplication = await prisma.financingApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinancingApplications and only return the `id`
     * const financingApplicationWithIdOnly = await prisma.financingApplication.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinancingApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, FinancingApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancingApplicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FinancingApplication.
     * @param {FinancingApplicationDeleteArgs} args - Arguments to delete one FinancingApplication.
     * @example
     * // Delete one FinancingApplication
     * const FinancingApplication = await prisma.financingApplication.delete({
     *   where: {
     *     // ... filter to delete one FinancingApplication
     *   }
     * })
     * 
     */
    delete<T extends FinancingApplicationDeleteArgs>(args: SelectSubset<T, FinancingApplicationDeleteArgs<ExtArgs>>): Prisma__FinancingApplicationClient<$Result.GetResult<Prisma.$FinancingApplicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FinancingApplication.
     * @param {FinancingApplicationUpdateArgs} args - Arguments to update one FinancingApplication.
     * @example
     * // Update one FinancingApplication
     * const financingApplication = await prisma.financingApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinancingApplicationUpdateArgs>(args: SelectSubset<T, FinancingApplicationUpdateArgs<ExtArgs>>): Prisma__FinancingApplicationClient<$Result.GetResult<Prisma.$FinancingApplicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FinancingApplications.
     * @param {FinancingApplicationDeleteManyArgs} args - Arguments to filter FinancingApplications to delete.
     * @example
     * // Delete a few FinancingApplications
     * const { count } = await prisma.financingApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinancingApplicationDeleteManyArgs>(args?: SelectSubset<T, FinancingApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancingApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancingApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinancingApplications
     * const financingApplication = await prisma.financingApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinancingApplicationUpdateManyArgs>(args: SelectSubset<T, FinancingApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FinancingApplication.
     * @param {FinancingApplicationUpsertArgs} args - Arguments to update or create a FinancingApplication.
     * @example
     * // Update or create a FinancingApplication
     * const financingApplication = await prisma.financingApplication.upsert({
     *   create: {
     *     // ... data to create a FinancingApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinancingApplication we want to update
     *   }
     * })
     */
    upsert<T extends FinancingApplicationUpsertArgs>(args: SelectSubset<T, FinancingApplicationUpsertArgs<ExtArgs>>): Prisma__FinancingApplicationClient<$Result.GetResult<Prisma.$FinancingApplicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FinancingApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancingApplicationCountArgs} args - Arguments to filter FinancingApplications to count.
     * @example
     * // Count the number of FinancingApplications
     * const count = await prisma.financingApplication.count({
     *   where: {
     *     // ... the filter for the FinancingApplications we want to count
     *   }
     * })
    **/
    count<T extends FinancingApplicationCountArgs>(
      args?: Subset<T, FinancingApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancingApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinancingApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancingApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancingApplicationAggregateArgs>(args: Subset<T, FinancingApplicationAggregateArgs>): Prisma.PrismaPromise<GetFinancingApplicationAggregateType<T>>

    /**
     * Group by FinancingApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancingApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinancingApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinancingApplicationGroupByArgs['orderBy'] }
        : { orderBy?: FinancingApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinancingApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancingApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinancingApplication model
   */
  readonly fields: FinancingApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinancingApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinancingApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinancingApplication model
   */ 
  interface FinancingApplicationFieldRefs {
    readonly id: FieldRef<"FinancingApplication", 'String'>
    readonly firstName: FieldRef<"FinancingApplication", 'String'>
    readonly middleName: FieldRef<"FinancingApplication", 'String'>
    readonly lastName: FieldRef<"FinancingApplication", 'String'>
    readonly email: FieldRef<"FinancingApplication", 'String'>
    readonly phone: FieldRef<"FinancingApplication", 'String'>
    readonly birthDate: FieldRef<"FinancingApplication", 'DateTime'>
    readonly civilStatus: FieldRef<"FinancingApplication", 'String'>
    readonly address: FieldRef<"FinancingApplication", 'String'>
    readonly employmentStatus: FieldRef<"FinancingApplication", 'String'>
    readonly monthlyIncome: FieldRef<"FinancingApplication", 'Decimal'>
    readonly employer: FieldRef<"FinancingApplication", 'String'>
    readonly yearsEmployed: FieldRef<"FinancingApplication", 'Int'>
    readonly vehicleId: FieldRef<"FinancingApplication", 'String'>
    readonly vehicleName: FieldRef<"FinancingApplication", 'String'>
    readonly downPayment: FieldRef<"FinancingApplication", 'Decimal'>
    readonly loanTerm: FieldRef<"FinancingApplication", 'Int'>
    readonly estimatedMonthly: FieldRef<"FinancingApplication", 'Decimal'>
    readonly validIds: FieldRef<"FinancingApplication", 'Json'>
    readonly proofOfIncome: FieldRef<"FinancingApplication", 'Json'>
    readonly proofOfBilling: FieldRef<"FinancingApplication", 'Json'>
    readonly status: FieldRef<"FinancingApplication", 'ApplicationStatus'>
    readonly approvedAmount: FieldRef<"FinancingApplication", 'Decimal'>
    readonly approvedTerm: FieldRef<"FinancingApplication", 'Int'>
    readonly applicantNotes: FieldRef<"FinancingApplication", 'String'>
    readonly adminNotes: FieldRef<"FinancingApplication", 'String'>
    readonly submittedAt: FieldRef<"FinancingApplication", 'DateTime'>
    readonly reviewedAt: FieldRef<"FinancingApplication", 'DateTime'>
    readonly approvedAt: FieldRef<"FinancingApplication", 'DateTime'>
    readonly createdAt: FieldRef<"FinancingApplication", 'DateTime'>
    readonly updatedAt: FieldRef<"FinancingApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FinancingApplication findUnique
   */
  export type FinancingApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingApplication
     */
    select?: FinancingApplicationSelect<ExtArgs> | null
    /**
     * Filter, which FinancingApplication to fetch.
     */
    where: FinancingApplicationWhereUniqueInput
  }

  /**
   * FinancingApplication findUniqueOrThrow
   */
  export type FinancingApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingApplication
     */
    select?: FinancingApplicationSelect<ExtArgs> | null
    /**
     * Filter, which FinancingApplication to fetch.
     */
    where: FinancingApplicationWhereUniqueInput
  }

  /**
   * FinancingApplication findFirst
   */
  export type FinancingApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingApplication
     */
    select?: FinancingApplicationSelect<ExtArgs> | null
    /**
     * Filter, which FinancingApplication to fetch.
     */
    where?: FinancingApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancingApplications to fetch.
     */
    orderBy?: FinancingApplicationOrderByWithRelationInput | FinancingApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancingApplications.
     */
    cursor?: FinancingApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancingApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancingApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancingApplications.
     */
    distinct?: FinancingApplicationScalarFieldEnum | FinancingApplicationScalarFieldEnum[]
  }

  /**
   * FinancingApplication findFirstOrThrow
   */
  export type FinancingApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingApplication
     */
    select?: FinancingApplicationSelect<ExtArgs> | null
    /**
     * Filter, which FinancingApplication to fetch.
     */
    where?: FinancingApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancingApplications to fetch.
     */
    orderBy?: FinancingApplicationOrderByWithRelationInput | FinancingApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancingApplications.
     */
    cursor?: FinancingApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancingApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancingApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancingApplications.
     */
    distinct?: FinancingApplicationScalarFieldEnum | FinancingApplicationScalarFieldEnum[]
  }

  /**
   * FinancingApplication findMany
   */
  export type FinancingApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingApplication
     */
    select?: FinancingApplicationSelect<ExtArgs> | null
    /**
     * Filter, which FinancingApplications to fetch.
     */
    where?: FinancingApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancingApplications to fetch.
     */
    orderBy?: FinancingApplicationOrderByWithRelationInput | FinancingApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinancingApplications.
     */
    cursor?: FinancingApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancingApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancingApplications.
     */
    skip?: number
    distinct?: FinancingApplicationScalarFieldEnum | FinancingApplicationScalarFieldEnum[]
  }

  /**
   * FinancingApplication create
   */
  export type FinancingApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingApplication
     */
    select?: FinancingApplicationSelect<ExtArgs> | null
    /**
     * The data needed to create a FinancingApplication.
     */
    data: XOR<FinancingApplicationCreateInput, FinancingApplicationUncheckedCreateInput>
  }

  /**
   * FinancingApplication createMany
   */
  export type FinancingApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinancingApplications.
     */
    data: FinancingApplicationCreateManyInput | FinancingApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinancingApplication createManyAndReturn
   */
  export type FinancingApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingApplication
     */
    select?: FinancingApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FinancingApplications.
     */
    data: FinancingApplicationCreateManyInput | FinancingApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinancingApplication update
   */
  export type FinancingApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingApplication
     */
    select?: FinancingApplicationSelect<ExtArgs> | null
    /**
     * The data needed to update a FinancingApplication.
     */
    data: XOR<FinancingApplicationUpdateInput, FinancingApplicationUncheckedUpdateInput>
    /**
     * Choose, which FinancingApplication to update.
     */
    where: FinancingApplicationWhereUniqueInput
  }

  /**
   * FinancingApplication updateMany
   */
  export type FinancingApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinancingApplications.
     */
    data: XOR<FinancingApplicationUpdateManyMutationInput, FinancingApplicationUncheckedUpdateManyInput>
    /**
     * Filter which FinancingApplications to update
     */
    where?: FinancingApplicationWhereInput
  }

  /**
   * FinancingApplication upsert
   */
  export type FinancingApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingApplication
     */
    select?: FinancingApplicationSelect<ExtArgs> | null
    /**
     * The filter to search for the FinancingApplication to update in case it exists.
     */
    where: FinancingApplicationWhereUniqueInput
    /**
     * In case the FinancingApplication found by the `where` argument doesn't exist, create a new FinancingApplication with this data.
     */
    create: XOR<FinancingApplicationCreateInput, FinancingApplicationUncheckedCreateInput>
    /**
     * In case the FinancingApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinancingApplicationUpdateInput, FinancingApplicationUncheckedUpdateInput>
  }

  /**
   * FinancingApplication delete
   */
  export type FinancingApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingApplication
     */
    select?: FinancingApplicationSelect<ExtArgs> | null
    /**
     * Filter which FinancingApplication to delete.
     */
    where: FinancingApplicationWhereUniqueInput
  }

  /**
   * FinancingApplication deleteMany
   */
  export type FinancingApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancingApplications to delete
     */
    where?: FinancingApplicationWhereInput
  }

  /**
   * FinancingApplication without action
   */
  export type FinancingApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancingApplication
     */
    select?: FinancingApplicationSelect<ExtArgs> | null
  }


  /**
   * Model TradeIn
   */

  export type AggregateTradeIn = {
    _count: TradeInCountAggregateOutputType | null
    _avg: TradeInAvgAggregateOutputType | null
    _sum: TradeInSumAggregateOutputType | null
    _min: TradeInMinAggregateOutputType | null
    _max: TradeInMaxAggregateOutputType | null
  }

  export type TradeInAvgAggregateOutputType = {
    year: number | null
    mileage: number | null
    expectedPrice: Decimal | null
    offeredPrice: Decimal | null
  }

  export type TradeInSumAggregateOutputType = {
    year: number | null
    mileage: number | null
    expectedPrice: Decimal | null
    offeredPrice: Decimal | null
  }

  export type TradeInMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    brand: string | null
    model: string | null
    year: number | null
    variant: string | null
    mileage: number | null
    transmission: string | null
    fuelType: string | null
    color: string | null
    condition: string | null
    hasAccidents: boolean | null
    serviceHistory: boolean | null
    description: string | null
    expectedPrice: Decimal | null
    offeredPrice: Decimal | null
    status: $Enums.TradeInStatus | null
    applicantNotes: string | null
    evaluationNotes: string | null
    evaluatedAt: Date | null
    offerMadeAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TradeInMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    brand: string | null
    model: string | null
    year: number | null
    variant: string | null
    mileage: number | null
    transmission: string | null
    fuelType: string | null
    color: string | null
    condition: string | null
    hasAccidents: boolean | null
    serviceHistory: boolean | null
    description: string | null
    expectedPrice: Decimal | null
    offeredPrice: Decimal | null
    status: $Enums.TradeInStatus | null
    applicantNotes: string | null
    evaluationNotes: string | null
    evaluatedAt: Date | null
    offerMadeAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TradeInCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    phone: number
    brand: number
    model: number
    year: number
    variant: number
    mileage: number
    transmission: number
    fuelType: number
    color: number
    condition: number
    hasAccidents: number
    serviceHistory: number
    images: number
    description: number
    expectedPrice: number
    offeredPrice: number
    status: number
    applicantNotes: number
    evaluationNotes: number
    evaluatedAt: number
    offerMadeAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TradeInAvgAggregateInputType = {
    year?: true
    mileage?: true
    expectedPrice?: true
    offeredPrice?: true
  }

  export type TradeInSumAggregateInputType = {
    year?: true
    mileage?: true
    expectedPrice?: true
    offeredPrice?: true
  }

  export type TradeInMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    brand?: true
    model?: true
    year?: true
    variant?: true
    mileage?: true
    transmission?: true
    fuelType?: true
    color?: true
    condition?: true
    hasAccidents?: true
    serviceHistory?: true
    description?: true
    expectedPrice?: true
    offeredPrice?: true
    status?: true
    applicantNotes?: true
    evaluationNotes?: true
    evaluatedAt?: true
    offerMadeAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TradeInMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    brand?: true
    model?: true
    year?: true
    variant?: true
    mileage?: true
    transmission?: true
    fuelType?: true
    color?: true
    condition?: true
    hasAccidents?: true
    serviceHistory?: true
    description?: true
    expectedPrice?: true
    offeredPrice?: true
    status?: true
    applicantNotes?: true
    evaluationNotes?: true
    evaluatedAt?: true
    offerMadeAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TradeInCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    brand?: true
    model?: true
    year?: true
    variant?: true
    mileage?: true
    transmission?: true
    fuelType?: true
    color?: true
    condition?: true
    hasAccidents?: true
    serviceHistory?: true
    images?: true
    description?: true
    expectedPrice?: true
    offeredPrice?: true
    status?: true
    applicantNotes?: true
    evaluationNotes?: true
    evaluatedAt?: true
    offerMadeAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TradeInAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradeIn to aggregate.
     */
    where?: TradeInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeIns to fetch.
     */
    orderBy?: TradeInOrderByWithRelationInput | TradeInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TradeInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TradeIns
    **/
    _count?: true | TradeInCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TradeInAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TradeInSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TradeInMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TradeInMaxAggregateInputType
  }

  export type GetTradeInAggregateType<T extends TradeInAggregateArgs> = {
        [P in keyof T & keyof AggregateTradeIn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTradeIn[P]>
      : GetScalarType<T[P], AggregateTradeIn[P]>
  }




  export type TradeInGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeInWhereInput
    orderBy?: TradeInOrderByWithAggregationInput | TradeInOrderByWithAggregationInput[]
    by: TradeInScalarFieldEnum[] | TradeInScalarFieldEnum
    having?: TradeInScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TradeInCountAggregateInputType | true
    _avg?: TradeInAvgAggregateInputType
    _sum?: TradeInSumAggregateInputType
    _min?: TradeInMinAggregateInputType
    _max?: TradeInMaxAggregateInputType
  }

  export type TradeInGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string
    phone: string
    brand: string
    model: string
    year: number
    variant: string | null
    mileage: number
    transmission: string
    fuelType: string
    color: string | null
    condition: string
    hasAccidents: boolean
    serviceHistory: boolean
    images: string[]
    description: string | null
    expectedPrice: Decimal | null
    offeredPrice: Decimal | null
    status: $Enums.TradeInStatus
    applicantNotes: string | null
    evaluationNotes: string | null
    evaluatedAt: Date | null
    offerMadeAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TradeInCountAggregateOutputType | null
    _avg: TradeInAvgAggregateOutputType | null
    _sum: TradeInSumAggregateOutputType | null
    _min: TradeInMinAggregateOutputType | null
    _max: TradeInMaxAggregateOutputType | null
  }

  type GetTradeInGroupByPayload<T extends TradeInGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TradeInGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TradeInGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TradeInGroupByOutputType[P]>
            : GetScalarType<T[P], TradeInGroupByOutputType[P]>
        }
      >
    >


  export type TradeInSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    brand?: boolean
    model?: boolean
    year?: boolean
    variant?: boolean
    mileage?: boolean
    transmission?: boolean
    fuelType?: boolean
    color?: boolean
    condition?: boolean
    hasAccidents?: boolean
    serviceHistory?: boolean
    images?: boolean
    description?: boolean
    expectedPrice?: boolean
    offeredPrice?: boolean
    status?: boolean
    applicantNotes?: boolean
    evaluationNotes?: boolean
    evaluatedAt?: boolean
    offerMadeAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tradeIn"]>

  export type TradeInSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    brand?: boolean
    model?: boolean
    year?: boolean
    variant?: boolean
    mileage?: boolean
    transmission?: boolean
    fuelType?: boolean
    color?: boolean
    condition?: boolean
    hasAccidents?: boolean
    serviceHistory?: boolean
    images?: boolean
    description?: boolean
    expectedPrice?: boolean
    offeredPrice?: boolean
    status?: boolean
    applicantNotes?: boolean
    evaluationNotes?: boolean
    evaluatedAt?: boolean
    offerMadeAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tradeIn"]>

  export type TradeInSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    brand?: boolean
    model?: boolean
    year?: boolean
    variant?: boolean
    mileage?: boolean
    transmission?: boolean
    fuelType?: boolean
    color?: boolean
    condition?: boolean
    hasAccidents?: boolean
    serviceHistory?: boolean
    images?: boolean
    description?: boolean
    expectedPrice?: boolean
    offeredPrice?: boolean
    status?: boolean
    applicantNotes?: boolean
    evaluationNotes?: boolean
    evaluatedAt?: boolean
    offerMadeAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TradeInPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TradeIn"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      email: string
      phone: string
      brand: string
      model: string
      year: number
      variant: string | null
      mileage: number
      transmission: string
      fuelType: string
      color: string | null
      condition: string
      hasAccidents: boolean
      serviceHistory: boolean
      images: string[]
      description: string | null
      expectedPrice: Prisma.Decimal | null
      offeredPrice: Prisma.Decimal | null
      status: $Enums.TradeInStatus
      applicantNotes: string | null
      evaluationNotes: string | null
      evaluatedAt: Date | null
      offerMadeAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tradeIn"]>
    composites: {}
  }

  type TradeInGetPayload<S extends boolean | null | undefined | TradeInDefaultArgs> = $Result.GetResult<Prisma.$TradeInPayload, S>

  type TradeInCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TradeInFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TradeInCountAggregateInputType | true
    }

  export interface TradeInDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TradeIn'], meta: { name: 'TradeIn' } }
    /**
     * Find zero or one TradeIn that matches the filter.
     * @param {TradeInFindUniqueArgs} args - Arguments to find a TradeIn
     * @example
     * // Get one TradeIn
     * const tradeIn = await prisma.tradeIn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TradeInFindUniqueArgs>(args: SelectSubset<T, TradeInFindUniqueArgs<ExtArgs>>): Prisma__TradeInClient<$Result.GetResult<Prisma.$TradeInPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TradeIn that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TradeInFindUniqueOrThrowArgs} args - Arguments to find a TradeIn
     * @example
     * // Get one TradeIn
     * const tradeIn = await prisma.tradeIn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TradeInFindUniqueOrThrowArgs>(args: SelectSubset<T, TradeInFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TradeInClient<$Result.GetResult<Prisma.$TradeInPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TradeIn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeInFindFirstArgs} args - Arguments to find a TradeIn
     * @example
     * // Get one TradeIn
     * const tradeIn = await prisma.tradeIn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TradeInFindFirstArgs>(args?: SelectSubset<T, TradeInFindFirstArgs<ExtArgs>>): Prisma__TradeInClient<$Result.GetResult<Prisma.$TradeInPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TradeIn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeInFindFirstOrThrowArgs} args - Arguments to find a TradeIn
     * @example
     * // Get one TradeIn
     * const tradeIn = await prisma.tradeIn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TradeInFindFirstOrThrowArgs>(args?: SelectSubset<T, TradeInFindFirstOrThrowArgs<ExtArgs>>): Prisma__TradeInClient<$Result.GetResult<Prisma.$TradeInPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TradeIns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeInFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TradeIns
     * const tradeIns = await prisma.tradeIn.findMany()
     * 
     * // Get first 10 TradeIns
     * const tradeIns = await prisma.tradeIn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tradeInWithIdOnly = await prisma.tradeIn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TradeInFindManyArgs>(args?: SelectSubset<T, TradeInFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeInPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TradeIn.
     * @param {TradeInCreateArgs} args - Arguments to create a TradeIn.
     * @example
     * // Create one TradeIn
     * const TradeIn = await prisma.tradeIn.create({
     *   data: {
     *     // ... data to create a TradeIn
     *   }
     * })
     * 
     */
    create<T extends TradeInCreateArgs>(args: SelectSubset<T, TradeInCreateArgs<ExtArgs>>): Prisma__TradeInClient<$Result.GetResult<Prisma.$TradeInPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TradeIns.
     * @param {TradeInCreateManyArgs} args - Arguments to create many TradeIns.
     * @example
     * // Create many TradeIns
     * const tradeIn = await prisma.tradeIn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TradeInCreateManyArgs>(args?: SelectSubset<T, TradeInCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TradeIns and returns the data saved in the database.
     * @param {TradeInCreateManyAndReturnArgs} args - Arguments to create many TradeIns.
     * @example
     * // Create many TradeIns
     * const tradeIn = await prisma.tradeIn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TradeIns and only return the `id`
     * const tradeInWithIdOnly = await prisma.tradeIn.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TradeInCreateManyAndReturnArgs>(args?: SelectSubset<T, TradeInCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeInPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TradeIn.
     * @param {TradeInDeleteArgs} args - Arguments to delete one TradeIn.
     * @example
     * // Delete one TradeIn
     * const TradeIn = await prisma.tradeIn.delete({
     *   where: {
     *     // ... filter to delete one TradeIn
     *   }
     * })
     * 
     */
    delete<T extends TradeInDeleteArgs>(args: SelectSubset<T, TradeInDeleteArgs<ExtArgs>>): Prisma__TradeInClient<$Result.GetResult<Prisma.$TradeInPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TradeIn.
     * @param {TradeInUpdateArgs} args - Arguments to update one TradeIn.
     * @example
     * // Update one TradeIn
     * const tradeIn = await prisma.tradeIn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TradeInUpdateArgs>(args: SelectSubset<T, TradeInUpdateArgs<ExtArgs>>): Prisma__TradeInClient<$Result.GetResult<Prisma.$TradeInPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TradeIns.
     * @param {TradeInDeleteManyArgs} args - Arguments to filter TradeIns to delete.
     * @example
     * // Delete a few TradeIns
     * const { count } = await prisma.tradeIn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TradeInDeleteManyArgs>(args?: SelectSubset<T, TradeInDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TradeIns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeInUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TradeIns
     * const tradeIn = await prisma.tradeIn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TradeInUpdateManyArgs>(args: SelectSubset<T, TradeInUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TradeIn.
     * @param {TradeInUpsertArgs} args - Arguments to update or create a TradeIn.
     * @example
     * // Update or create a TradeIn
     * const tradeIn = await prisma.tradeIn.upsert({
     *   create: {
     *     // ... data to create a TradeIn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TradeIn we want to update
     *   }
     * })
     */
    upsert<T extends TradeInUpsertArgs>(args: SelectSubset<T, TradeInUpsertArgs<ExtArgs>>): Prisma__TradeInClient<$Result.GetResult<Prisma.$TradeInPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TradeIns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeInCountArgs} args - Arguments to filter TradeIns to count.
     * @example
     * // Count the number of TradeIns
     * const count = await prisma.tradeIn.count({
     *   where: {
     *     // ... the filter for the TradeIns we want to count
     *   }
     * })
    **/
    count<T extends TradeInCountArgs>(
      args?: Subset<T, TradeInCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TradeInCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TradeIn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeInAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TradeInAggregateArgs>(args: Subset<T, TradeInAggregateArgs>): Prisma.PrismaPromise<GetTradeInAggregateType<T>>

    /**
     * Group by TradeIn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeInGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TradeInGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TradeInGroupByArgs['orderBy'] }
        : { orderBy?: TradeInGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TradeInGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTradeInGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TradeIn model
   */
  readonly fields: TradeInFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TradeIn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TradeInClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TradeIn model
   */ 
  interface TradeInFieldRefs {
    readonly id: FieldRef<"TradeIn", 'String'>
    readonly firstName: FieldRef<"TradeIn", 'String'>
    readonly lastName: FieldRef<"TradeIn", 'String'>
    readonly email: FieldRef<"TradeIn", 'String'>
    readonly phone: FieldRef<"TradeIn", 'String'>
    readonly brand: FieldRef<"TradeIn", 'String'>
    readonly model: FieldRef<"TradeIn", 'String'>
    readonly year: FieldRef<"TradeIn", 'Int'>
    readonly variant: FieldRef<"TradeIn", 'String'>
    readonly mileage: FieldRef<"TradeIn", 'Int'>
    readonly transmission: FieldRef<"TradeIn", 'String'>
    readonly fuelType: FieldRef<"TradeIn", 'String'>
    readonly color: FieldRef<"TradeIn", 'String'>
    readonly condition: FieldRef<"TradeIn", 'String'>
    readonly hasAccidents: FieldRef<"TradeIn", 'Boolean'>
    readonly serviceHistory: FieldRef<"TradeIn", 'Boolean'>
    readonly images: FieldRef<"TradeIn", 'String[]'>
    readonly description: FieldRef<"TradeIn", 'String'>
    readonly expectedPrice: FieldRef<"TradeIn", 'Decimal'>
    readonly offeredPrice: FieldRef<"TradeIn", 'Decimal'>
    readonly status: FieldRef<"TradeIn", 'TradeInStatus'>
    readonly applicantNotes: FieldRef<"TradeIn", 'String'>
    readonly evaluationNotes: FieldRef<"TradeIn", 'String'>
    readonly evaluatedAt: FieldRef<"TradeIn", 'DateTime'>
    readonly offerMadeAt: FieldRef<"TradeIn", 'DateTime'>
    readonly createdAt: FieldRef<"TradeIn", 'DateTime'>
    readonly updatedAt: FieldRef<"TradeIn", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TradeIn findUnique
   */
  export type TradeInFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeIn
     */
    select?: TradeInSelect<ExtArgs> | null
    /**
     * Filter, which TradeIn to fetch.
     */
    where: TradeInWhereUniqueInput
  }

  /**
   * TradeIn findUniqueOrThrow
   */
  export type TradeInFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeIn
     */
    select?: TradeInSelect<ExtArgs> | null
    /**
     * Filter, which TradeIn to fetch.
     */
    where: TradeInWhereUniqueInput
  }

  /**
   * TradeIn findFirst
   */
  export type TradeInFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeIn
     */
    select?: TradeInSelect<ExtArgs> | null
    /**
     * Filter, which TradeIn to fetch.
     */
    where?: TradeInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeIns to fetch.
     */
    orderBy?: TradeInOrderByWithRelationInput | TradeInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradeIns.
     */
    cursor?: TradeInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradeIns.
     */
    distinct?: TradeInScalarFieldEnum | TradeInScalarFieldEnum[]
  }

  /**
   * TradeIn findFirstOrThrow
   */
  export type TradeInFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeIn
     */
    select?: TradeInSelect<ExtArgs> | null
    /**
     * Filter, which TradeIn to fetch.
     */
    where?: TradeInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeIns to fetch.
     */
    orderBy?: TradeInOrderByWithRelationInput | TradeInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradeIns.
     */
    cursor?: TradeInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradeIns.
     */
    distinct?: TradeInScalarFieldEnum | TradeInScalarFieldEnum[]
  }

  /**
   * TradeIn findMany
   */
  export type TradeInFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeIn
     */
    select?: TradeInSelect<ExtArgs> | null
    /**
     * Filter, which TradeIns to fetch.
     */
    where?: TradeInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeIns to fetch.
     */
    orderBy?: TradeInOrderByWithRelationInput | TradeInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TradeIns.
     */
    cursor?: TradeInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeIns.
     */
    skip?: number
    distinct?: TradeInScalarFieldEnum | TradeInScalarFieldEnum[]
  }

  /**
   * TradeIn create
   */
  export type TradeInCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeIn
     */
    select?: TradeInSelect<ExtArgs> | null
    /**
     * The data needed to create a TradeIn.
     */
    data: XOR<TradeInCreateInput, TradeInUncheckedCreateInput>
  }

  /**
   * TradeIn createMany
   */
  export type TradeInCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TradeIns.
     */
    data: TradeInCreateManyInput | TradeInCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TradeIn createManyAndReturn
   */
  export type TradeInCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeIn
     */
    select?: TradeInSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TradeIns.
     */
    data: TradeInCreateManyInput | TradeInCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TradeIn update
   */
  export type TradeInUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeIn
     */
    select?: TradeInSelect<ExtArgs> | null
    /**
     * The data needed to update a TradeIn.
     */
    data: XOR<TradeInUpdateInput, TradeInUncheckedUpdateInput>
    /**
     * Choose, which TradeIn to update.
     */
    where: TradeInWhereUniqueInput
  }

  /**
   * TradeIn updateMany
   */
  export type TradeInUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TradeIns.
     */
    data: XOR<TradeInUpdateManyMutationInput, TradeInUncheckedUpdateManyInput>
    /**
     * Filter which TradeIns to update
     */
    where?: TradeInWhereInput
  }

  /**
   * TradeIn upsert
   */
  export type TradeInUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeIn
     */
    select?: TradeInSelect<ExtArgs> | null
    /**
     * The filter to search for the TradeIn to update in case it exists.
     */
    where: TradeInWhereUniqueInput
    /**
     * In case the TradeIn found by the `where` argument doesn't exist, create a new TradeIn with this data.
     */
    create: XOR<TradeInCreateInput, TradeInUncheckedCreateInput>
    /**
     * In case the TradeIn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TradeInUpdateInput, TradeInUncheckedUpdateInput>
  }

  /**
   * TradeIn delete
   */
  export type TradeInDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeIn
     */
    select?: TradeInSelect<ExtArgs> | null
    /**
     * Filter which TradeIn to delete.
     */
    where: TradeInWhereUniqueInput
  }

  /**
   * TradeIn deleteMany
   */
  export type TradeInDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradeIns to delete
     */
    where?: TradeInWhereInput
  }

  /**
   * TradeIn without action
   */
  export type TradeInDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeIn
     */
    select?: TradeInSelect<ExtArgs> | null
  }


  /**
   * Model Promotion
   */

  export type AggregatePromotion = {
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  export type PromotionAvgAggregateOutputType = {
    discountValue: Decimal | null
  }

  export type PromotionSumAggregateOutputType = {
    discountValue: Decimal | null
  }

  export type PromotionMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    bannerImage: string | null
    thumbnailImage: string | null
    discountType: string | null
    discountValue: Decimal | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    terms: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    bannerImage: string | null
    thumbnailImage: string | null
    discountType: string | null
    discountValue: Decimal | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    terms: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    description: number
    bannerImage: number
    thumbnailImage: number
    discountType: number
    discountValue: number
    vehicleIds: number
    startDate: number
    endDate: number
    isActive: number
    terms: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromotionAvgAggregateInputType = {
    discountValue?: true
  }

  export type PromotionSumAggregateInputType = {
    discountValue?: true
  }

  export type PromotionMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    bannerImage?: true
    thumbnailImage?: true
    discountType?: true
    discountValue?: true
    startDate?: true
    endDate?: true
    isActive?: true
    terms?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    bannerImage?: true
    thumbnailImage?: true
    discountType?: true
    discountValue?: true
    startDate?: true
    endDate?: true
    isActive?: true
    terms?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    bannerImage?: true
    thumbnailImage?: true
    discountType?: true
    discountValue?: true
    vehicleIds?: true
    startDate?: true
    endDate?: true
    isActive?: true
    terms?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotion to aggregate.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Promotions
    **/
    _count?: true | PromotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionMaxAggregateInputType
  }

  export type GetPromotionAggregateType<T extends PromotionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotion[P]>
      : GetScalarType<T[P], AggregatePromotion[P]>
  }




  export type PromotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithAggregationInput | PromotionOrderByWithAggregationInput[]
    by: PromotionScalarFieldEnum[] | PromotionScalarFieldEnum
    having?: PromotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionCountAggregateInputType | true
    _avg?: PromotionAvgAggregateInputType
    _sum?: PromotionSumAggregateInputType
    _min?: PromotionMinAggregateInputType
    _max?: PromotionMaxAggregateInputType
  }

  export type PromotionGroupByOutputType = {
    id: string
    title: string
    slug: string
    description: string
    bannerImage: string
    thumbnailImage: string | null
    discountType: string
    discountValue: Decimal
    vehicleIds: string[]
    startDate: Date
    endDate: Date
    isActive: boolean
    terms: string | null
    createdAt: Date
    updatedAt: Date
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  type GetPromotionGroupByPayload<T extends PromotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionGroupByOutputType[P]>
        }
      >
    >


  export type PromotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    bannerImage?: boolean
    thumbnailImage?: boolean
    discountType?: boolean
    discountValue?: boolean
    vehicleIds?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    terms?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    bannerImage?: boolean
    thumbnailImage?: boolean
    discountType?: boolean
    discountValue?: boolean
    vehicleIds?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    terms?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    bannerImage?: boolean
    thumbnailImage?: boolean
    discountType?: boolean
    discountValue?: boolean
    vehicleIds?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    terms?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $PromotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Promotion"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      description: string
      bannerImage: string
      thumbnailImage: string | null
      discountType: string
      discountValue: Prisma.Decimal
      vehicleIds: string[]
      startDate: Date
      endDate: Date
      isActive: boolean
      terms: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["promotion"]>
    composites: {}
  }

  type PromotionGetPayload<S extends boolean | null | undefined | PromotionDefaultArgs> = $Result.GetResult<Prisma.$PromotionPayload, S>

  type PromotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PromotionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PromotionCountAggregateInputType | true
    }

  export interface PromotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Promotion'], meta: { name: 'Promotion' } }
    /**
     * Find zero or one Promotion that matches the filter.
     * @param {PromotionFindUniqueArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionFindUniqueArgs>(args: SelectSubset<T, PromotionFindUniqueArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Promotion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PromotionFindUniqueOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Promotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionFindFirstArgs>(args?: SelectSubset<T, PromotionFindFirstArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Promotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Promotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promotions
     * const promotions = await prisma.promotion.findMany()
     * 
     * // Get first 10 Promotions
     * const promotions = await prisma.promotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionWithIdOnly = await prisma.promotion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionFindManyArgs>(args?: SelectSubset<T, PromotionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Promotion.
     * @param {PromotionCreateArgs} args - Arguments to create a Promotion.
     * @example
     * // Create one Promotion
     * const Promotion = await prisma.promotion.create({
     *   data: {
     *     // ... data to create a Promotion
     *   }
     * })
     * 
     */
    create<T extends PromotionCreateArgs>(args: SelectSubset<T, PromotionCreateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Promotions.
     * @param {PromotionCreateManyArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionCreateManyArgs>(args?: SelectSubset<T, PromotionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Promotions and returns the data saved in the database.
     * @param {PromotionCreateManyAndReturnArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Promotions and only return the `id`
     * const promotionWithIdOnly = await prisma.promotion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromotionCreateManyAndReturnArgs>(args?: SelectSubset<T, PromotionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Promotion.
     * @param {PromotionDeleteArgs} args - Arguments to delete one Promotion.
     * @example
     * // Delete one Promotion
     * const Promotion = await prisma.promotion.delete({
     *   where: {
     *     // ... filter to delete one Promotion
     *   }
     * })
     * 
     */
    delete<T extends PromotionDeleteArgs>(args: SelectSubset<T, PromotionDeleteArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Promotion.
     * @param {PromotionUpdateArgs} args - Arguments to update one Promotion.
     * @example
     * // Update one Promotion
     * const promotion = await prisma.promotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionUpdateArgs>(args: SelectSubset<T, PromotionUpdateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Promotions.
     * @param {PromotionDeleteManyArgs} args - Arguments to filter Promotions to delete.
     * @example
     * // Delete a few Promotions
     * const { count } = await prisma.promotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionDeleteManyArgs>(args?: SelectSubset<T, PromotionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionUpdateManyArgs>(args: SelectSubset<T, PromotionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Promotion.
     * @param {PromotionUpsertArgs} args - Arguments to update or create a Promotion.
     * @example
     * // Update or create a Promotion
     * const promotion = await prisma.promotion.upsert({
     *   create: {
     *     // ... data to create a Promotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promotion we want to update
     *   }
     * })
     */
    upsert<T extends PromotionUpsertArgs>(args: SelectSubset<T, PromotionUpsertArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCountArgs} args - Arguments to filter Promotions to count.
     * @example
     * // Count the number of Promotions
     * const count = await prisma.promotion.count({
     *   where: {
     *     // ... the filter for the Promotions we want to count
     *   }
     * })
    **/
    count<T extends PromotionCountArgs>(
      args?: Subset<T, PromotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionAggregateArgs>(args: Subset<T, PromotionAggregateArgs>): Prisma.PrismaPromise<GetPromotionAggregateType<T>>

    /**
     * Group by Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionGroupByArgs['orderBy'] }
        : { orderBy?: PromotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Promotion model
   */
  readonly fields: PromotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Promotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Promotion model
   */ 
  interface PromotionFieldRefs {
    readonly id: FieldRef<"Promotion", 'String'>
    readonly title: FieldRef<"Promotion", 'String'>
    readonly slug: FieldRef<"Promotion", 'String'>
    readonly description: FieldRef<"Promotion", 'String'>
    readonly bannerImage: FieldRef<"Promotion", 'String'>
    readonly thumbnailImage: FieldRef<"Promotion", 'String'>
    readonly discountType: FieldRef<"Promotion", 'String'>
    readonly discountValue: FieldRef<"Promotion", 'Decimal'>
    readonly vehicleIds: FieldRef<"Promotion", 'String[]'>
    readonly startDate: FieldRef<"Promotion", 'DateTime'>
    readonly endDate: FieldRef<"Promotion", 'DateTime'>
    readonly isActive: FieldRef<"Promotion", 'Boolean'>
    readonly terms: FieldRef<"Promotion", 'String'>
    readonly createdAt: FieldRef<"Promotion", 'DateTime'>
    readonly updatedAt: FieldRef<"Promotion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Promotion findUnique
   */
  export type PromotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findUniqueOrThrow
   */
  export type PromotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findFirst
   */
  export type PromotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findFirstOrThrow
   */
  export type PromotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findMany
   */
  export type PromotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Filter, which Promotions to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion create
   */
  export type PromotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * The data needed to create a Promotion.
     */
    data: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
  }

  /**
   * Promotion createMany
   */
  export type PromotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promotion createManyAndReturn
   */
  export type PromotionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promotion update
   */
  export type PromotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * The data needed to update a Promotion.
     */
    data: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
    /**
     * Choose, which Promotion to update.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion updateMany
   */
  export type PromotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
  }

  /**
   * Promotion upsert
   */
  export type PromotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * The filter to search for the Promotion to update in case it exists.
     */
    where: PromotionWhereUniqueInput
    /**
     * In case the Promotion found by the `where` argument doesn't exist, create a new Promotion with this data.
     */
    create: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
    /**
     * In case the Promotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
  }

  /**
   * Promotion delete
   */
  export type PromotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Filter which Promotion to delete.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion deleteMany
   */
  export type PromotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotions to delete
     */
    where?: PromotionWhereInput
  }

  /**
   * Promotion without action
   */
  export type PromotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    link: string | null
    icon: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    link: string | null
    icon: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    link: number
    icon: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    link?: true
    icon?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    link?: true
    icon?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    link?: true
    icon?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    title: string
    message: string
    link: string | null
    icon: string | null
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    link?: boolean
    icon?: boolean
    read?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    link?: boolean
    icon?: boolean
    read?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    link?: boolean
    icon?: boolean
    read?: boolean
    createdAt?: boolean
  }


  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      title: string
      message: string
      link: string | null
      icon: string | null
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly link: FieldRef<"Notification", 'String'>
    readonly icon: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const DealershipScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    website: 'website',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DealershipScalarFieldEnum = (typeof DealershipScalarFieldEnum)[keyof typeof DealershipScalarFieldEnum]


  export const BranchScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone',
    email: 'email',
    dealershipId: 'dealershipId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const BranchInventoryScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    vehicleId: 'vehicleId',
    stock: 'stock',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BranchInventoryScalarFieldEnum = (typeof BranchInventoryScalarFieldEnum)[keyof typeof BranchInventoryScalarFieldEnum]


  export const LoanRateScalarFieldEnum: {
    id: 'id',
    bankName: 'bankName',
    annualRate: 'annualRate',
    minTermMonths: 'minTermMonths',
    maxTermMonths: 'maxTermMonths',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoanRateScalarFieldEnum = (typeof LoanRateScalarFieldEnum)[keyof typeof LoanRateScalarFieldEnum]


  export const VehicleScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    brand: 'brand',
    model: 'model',
    year: 'year',
    variant: 'variant',
    cashPrice: 'cashPrice',
    downPayment: 'downPayment',
    monthlyPayment: 'monthlyPayment',
    leaseTerm: 'leaseTerm',
    transmission: 'transmission',
    fuelType: 'fuelType',
    engineSize: 'engineSize',
    horsepower: 'horsepower',
    seatingCapacity: 'seatingCapacity',
    cargoSpace: 'cargoSpace',
    features: 'features',
    specifications: 'specifications',
    description: 'description',
    videos: 'videos',
    model3dUrl: 'model3dUrl',
    thumbnailUrl: 'thumbnailUrl',
    status: 'status',
    availability: 'availability',
    featured: 'featured',
    stockCount: 'stockCount',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    categoryId: 'categoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VehicleScalarFieldEnum = (typeof VehicleScalarFieldEnum)[keyof typeof VehicleScalarFieldEnum]


  export const VehicleImageScalarFieldEnum: {
    id: 'id',
    url: 'url',
    alt: 'alt',
    type: 'type',
    order: 'order',
    vehicleId: 'vehicleId'
  };

  export type VehicleImageScalarFieldEnum = (typeof VehicleImageScalarFieldEnum)[keyof typeof VehicleImageScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    icon: 'icon',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    clerkId: 'clerkId',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    avatar: 'avatar',
    preferences: 'preferences',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SavedVehicleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    vehicleId: 'vehicleId',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type SavedVehicleScalarFieldEnum = (typeof SavedVehicleScalarFieldEnum)[keyof typeof SavedVehicleScalarFieldEnum]


  export const ConfigurationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    vehicleId: 'vehicleId',
    color: 'color',
    colorHex: 'colorHex',
    wheels: 'wheels',
    interior: 'interior',
    packages: 'packages',
    accessories: 'accessories',
    totalPrice: 'totalPrice',
    shared: 'shared',
    shareToken: 'shareToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConfigurationScalarFieldEnum = (typeof ConfigurationScalarFieldEnum)[keyof typeof ConfigurationScalarFieldEnum]


  export const TestDriveScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    vehicleId: 'vehicleId',
    preferredDate: 'preferredDate',
    preferredTime: 'preferredTime',
    location: 'location',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    status: 'status',
    notes: 'notes',
    adminNotes: 'adminNotes',
    confirmedAt: 'confirmedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TestDriveScalarFieldEnum = (typeof TestDriveScalarFieldEnum)[keyof typeof TestDriveScalarFieldEnum]


  export const InquiryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    vehicleId: 'vehicleId',
    type: 'type',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    subject: 'subject',
    message: 'message',
    status: 'status',
    assignedTo: 'assignedTo',
    response: 'response',
    respondedAt: 'respondedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InquiryScalarFieldEnum = (typeof InquiryScalarFieldEnum)[keyof typeof InquiryScalarFieldEnum]


  export const FinancingApplicationScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    birthDate: 'birthDate',
    civilStatus: 'civilStatus',
    address: 'address',
    employmentStatus: 'employmentStatus',
    monthlyIncome: 'monthlyIncome',
    employer: 'employer',
    yearsEmployed: 'yearsEmployed',
    vehicleId: 'vehicleId',
    vehicleName: 'vehicleName',
    downPayment: 'downPayment',
    loanTerm: 'loanTerm',
    estimatedMonthly: 'estimatedMonthly',
    validIds: 'validIds',
    proofOfIncome: 'proofOfIncome',
    proofOfBilling: 'proofOfBilling',
    status: 'status',
    approvedAmount: 'approvedAmount',
    approvedTerm: 'approvedTerm',
    applicantNotes: 'applicantNotes',
    adminNotes: 'adminNotes',
    submittedAt: 'submittedAt',
    reviewedAt: 'reviewedAt',
    approvedAt: 'approvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FinancingApplicationScalarFieldEnum = (typeof FinancingApplicationScalarFieldEnum)[keyof typeof FinancingApplicationScalarFieldEnum]


  export const TradeInScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    brand: 'brand',
    model: 'model',
    year: 'year',
    variant: 'variant',
    mileage: 'mileage',
    transmission: 'transmission',
    fuelType: 'fuelType',
    color: 'color',
    condition: 'condition',
    hasAccidents: 'hasAccidents',
    serviceHistory: 'serviceHistory',
    images: 'images',
    description: 'description',
    expectedPrice: 'expectedPrice',
    offeredPrice: 'offeredPrice',
    status: 'status',
    applicantNotes: 'applicantNotes',
    evaluationNotes: 'evaluationNotes',
    evaluatedAt: 'evaluatedAt',
    offerMadeAt: 'offerMadeAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TradeInScalarFieldEnum = (typeof TradeInScalarFieldEnum)[keyof typeof TradeInScalarFieldEnum]


  export const PromotionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    description: 'description',
    bannerImage: 'bannerImage',
    thumbnailImage: 'thumbnailImage',
    discountType: 'discountType',
    discountValue: 'discountValue',
    vehicleIds: 'vehicleIds',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    terms: 'terms',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromotionScalarFieldEnum = (typeof PromotionScalarFieldEnum)[keyof typeof PromotionScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    link: 'link',
    icon: 'icon',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'VehicleStatus'
   */
  export type EnumVehicleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VehicleStatus'>
    


  /**
   * Reference to a field of type 'VehicleStatus[]'
   */
  export type ListEnumVehicleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VehicleStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'InquiryType'
   */
  export type EnumInquiryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InquiryType'>
    


  /**
   * Reference to a field of type 'InquiryType[]'
   */
  export type ListEnumInquiryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InquiryType[]'>
    


  /**
   * Reference to a field of type 'InquiryStatus'
   */
  export type EnumInquiryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InquiryStatus'>
    


  /**
   * Reference to a field of type 'InquiryStatus[]'
   */
  export type ListEnumInquiryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InquiryStatus[]'>
    


  /**
   * Reference to a field of type 'ApplicationStatus'
   */
  export type EnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus'>
    


  /**
   * Reference to a field of type 'ApplicationStatus[]'
   */
  export type ListEnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus[]'>
    


  /**
   * Reference to a field of type 'TradeInStatus'
   */
  export type EnumTradeInStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TradeInStatus'>
    


  /**
   * Reference to a field of type 'TradeInStatus[]'
   */
  export type ListEnumTradeInStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TradeInStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type DealershipWhereInput = {
    AND?: DealershipWhereInput | DealershipWhereInput[]
    OR?: DealershipWhereInput[]
    NOT?: DealershipWhereInput | DealershipWhereInput[]
    id?: StringFilter<"Dealership"> | string
    name?: StringFilter<"Dealership"> | string
    slug?: StringFilter<"Dealership"> | string
    description?: StringNullableFilter<"Dealership"> | string | null
    website?: StringNullableFilter<"Dealership"> | string | null
    createdAt?: DateTimeFilter<"Dealership"> | Date | string
    updatedAt?: DateTimeFilter<"Dealership"> | Date | string
    branches?: BranchListRelationFilter
  }

  export type DealershipOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branches?: BranchOrderByRelationAggregateInput
  }

  export type DealershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: DealershipWhereInput | DealershipWhereInput[]
    OR?: DealershipWhereInput[]
    NOT?: DealershipWhereInput | DealershipWhereInput[]
    name?: StringFilter<"Dealership"> | string
    description?: StringNullableFilter<"Dealership"> | string | null
    website?: StringNullableFilter<"Dealership"> | string | null
    createdAt?: DateTimeFilter<"Dealership"> | Date | string
    updatedAt?: DateTimeFilter<"Dealership"> | Date | string
    branches?: BranchListRelationFilter
  }, "id" | "slug">

  export type DealershipOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DealershipCountOrderByAggregateInput
    _max?: DealershipMaxOrderByAggregateInput
    _min?: DealershipMinOrderByAggregateInput
  }

  export type DealershipScalarWhereWithAggregatesInput = {
    AND?: DealershipScalarWhereWithAggregatesInput | DealershipScalarWhereWithAggregatesInput[]
    OR?: DealershipScalarWhereWithAggregatesInput[]
    NOT?: DealershipScalarWhereWithAggregatesInput | DealershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Dealership"> | string
    name?: StringWithAggregatesFilter<"Dealership"> | string
    slug?: StringWithAggregatesFilter<"Dealership"> | string
    description?: StringNullableWithAggregatesFilter<"Dealership"> | string | null
    website?: StringNullableWithAggregatesFilter<"Dealership"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Dealership"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Dealership"> | Date | string
  }

  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    id?: StringFilter<"Branch"> | string
    name?: StringFilter<"Branch"> | string
    address?: StringFilter<"Branch"> | string
    phone?: StringNullableFilter<"Branch"> | string | null
    email?: StringNullableFilter<"Branch"> | string | null
    dealershipId?: StringFilter<"Branch"> | string
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    dealership?: XOR<DealershipRelationFilter, DealershipWhereInput>
    inventory?: BranchInventoryListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    dealershipId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dealership?: DealershipOrderByWithRelationInput
    inventory?: BranchInventoryOrderByRelationAggregateInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    name?: StringFilter<"Branch"> | string
    address?: StringFilter<"Branch"> | string
    phone?: StringNullableFilter<"Branch"> | string | null
    email?: StringNullableFilter<"Branch"> | string | null
    dealershipId?: StringFilter<"Branch"> | string
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    dealership?: XOR<DealershipRelationFilter, DealershipWhereInput>
    inventory?: BranchInventoryListRelationFilter
  }, "id">

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    dealershipId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BranchCountOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Branch"> | string
    name?: StringWithAggregatesFilter<"Branch"> | string
    address?: StringWithAggregatesFilter<"Branch"> | string
    phone?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    email?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    dealershipId?: StringWithAggregatesFilter<"Branch"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
  }

  export type BranchInventoryWhereInput = {
    AND?: BranchInventoryWhereInput | BranchInventoryWhereInput[]
    OR?: BranchInventoryWhereInput[]
    NOT?: BranchInventoryWhereInput | BranchInventoryWhereInput[]
    id?: StringFilter<"BranchInventory"> | string
    branchId?: StringFilter<"BranchInventory"> | string
    vehicleId?: StringFilter<"BranchInventory"> | string
    stock?: IntFilter<"BranchInventory"> | number
    price?: DecimalFilter<"BranchInventory"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"BranchInventory"> | Date | string
    updatedAt?: DateTimeFilter<"BranchInventory"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
  }

  export type BranchInventoryOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    vehicleId?: SortOrder
    stock?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
  }

  export type BranchInventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BranchInventoryWhereInput | BranchInventoryWhereInput[]
    OR?: BranchInventoryWhereInput[]
    NOT?: BranchInventoryWhereInput | BranchInventoryWhereInput[]
    branchId?: StringFilter<"BranchInventory"> | string
    vehicleId?: StringFilter<"BranchInventory"> | string
    stock?: IntFilter<"BranchInventory"> | number
    price?: DecimalFilter<"BranchInventory"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"BranchInventory"> | Date | string
    updatedAt?: DateTimeFilter<"BranchInventory"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
  }, "id">

  export type BranchInventoryOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    vehicleId?: SortOrder
    stock?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BranchInventoryCountOrderByAggregateInput
    _avg?: BranchInventoryAvgOrderByAggregateInput
    _max?: BranchInventoryMaxOrderByAggregateInput
    _min?: BranchInventoryMinOrderByAggregateInput
    _sum?: BranchInventorySumOrderByAggregateInput
  }

  export type BranchInventoryScalarWhereWithAggregatesInput = {
    AND?: BranchInventoryScalarWhereWithAggregatesInput | BranchInventoryScalarWhereWithAggregatesInput[]
    OR?: BranchInventoryScalarWhereWithAggregatesInput[]
    NOT?: BranchInventoryScalarWhereWithAggregatesInput | BranchInventoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BranchInventory"> | string
    branchId?: StringWithAggregatesFilter<"BranchInventory"> | string
    vehicleId?: StringWithAggregatesFilter<"BranchInventory"> | string
    stock?: IntWithAggregatesFilter<"BranchInventory"> | number
    price?: DecimalWithAggregatesFilter<"BranchInventory"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"BranchInventory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BranchInventory"> | Date | string
  }

  export type LoanRateWhereInput = {
    AND?: LoanRateWhereInput | LoanRateWhereInput[]
    OR?: LoanRateWhereInput[]
    NOT?: LoanRateWhereInput | LoanRateWhereInput[]
    id?: StringFilter<"LoanRate"> | string
    bankName?: StringFilter<"LoanRate"> | string
    annualRate?: DecimalFilter<"LoanRate"> | Decimal | DecimalJsLike | number | string
    minTermMonths?: IntFilter<"LoanRate"> | number
    maxTermMonths?: IntFilter<"LoanRate"> | number
    createdAt?: DateTimeFilter<"LoanRate"> | Date | string
    updatedAt?: DateTimeFilter<"LoanRate"> | Date | string
  }

  export type LoanRateOrderByWithRelationInput = {
    id?: SortOrder
    bankName?: SortOrder
    annualRate?: SortOrder
    minTermMonths?: SortOrder
    maxTermMonths?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanRateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LoanRateWhereInput | LoanRateWhereInput[]
    OR?: LoanRateWhereInput[]
    NOT?: LoanRateWhereInput | LoanRateWhereInput[]
    bankName?: StringFilter<"LoanRate"> | string
    annualRate?: DecimalFilter<"LoanRate"> | Decimal | DecimalJsLike | number | string
    minTermMonths?: IntFilter<"LoanRate"> | number
    maxTermMonths?: IntFilter<"LoanRate"> | number
    createdAt?: DateTimeFilter<"LoanRate"> | Date | string
    updatedAt?: DateTimeFilter<"LoanRate"> | Date | string
  }, "id">

  export type LoanRateOrderByWithAggregationInput = {
    id?: SortOrder
    bankName?: SortOrder
    annualRate?: SortOrder
    minTermMonths?: SortOrder
    maxTermMonths?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoanRateCountOrderByAggregateInput
    _avg?: LoanRateAvgOrderByAggregateInput
    _max?: LoanRateMaxOrderByAggregateInput
    _min?: LoanRateMinOrderByAggregateInput
    _sum?: LoanRateSumOrderByAggregateInput
  }

  export type LoanRateScalarWhereWithAggregatesInput = {
    AND?: LoanRateScalarWhereWithAggregatesInput | LoanRateScalarWhereWithAggregatesInput[]
    OR?: LoanRateScalarWhereWithAggregatesInput[]
    NOT?: LoanRateScalarWhereWithAggregatesInput | LoanRateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoanRate"> | string
    bankName?: StringWithAggregatesFilter<"LoanRate"> | string
    annualRate?: DecimalWithAggregatesFilter<"LoanRate"> | Decimal | DecimalJsLike | number | string
    minTermMonths?: IntWithAggregatesFilter<"LoanRate"> | number
    maxTermMonths?: IntWithAggregatesFilter<"LoanRate"> | number
    createdAt?: DateTimeWithAggregatesFilter<"LoanRate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LoanRate"> | Date | string
  }

  export type VehicleWhereInput = {
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    id?: StringFilter<"Vehicle"> | string
    slug?: StringFilter<"Vehicle"> | string
    brand?: StringFilter<"Vehicle"> | string
    model?: StringFilter<"Vehicle"> | string
    year?: IntFilter<"Vehicle"> | number
    variant?: StringNullableFilter<"Vehicle"> | string | null
    cashPrice?: DecimalFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFilter<"Vehicle"> | number
    transmission?: StringFilter<"Vehicle"> | string
    fuelType?: StringFilter<"Vehicle"> | string
    engineSize?: StringNullableFilter<"Vehicle"> | string | null
    horsepower?: IntNullableFilter<"Vehicle"> | number | null
    seatingCapacity?: IntFilter<"Vehicle"> | number
    cargoSpace?: StringNullableFilter<"Vehicle"> | string | null
    features?: JsonFilter<"Vehicle">
    specifications?: JsonFilter<"Vehicle">
    description?: StringNullableFilter<"Vehicle"> | string | null
    videos?: StringNullableListFilter<"Vehicle">
    model3dUrl?: StringNullableFilter<"Vehicle"> | string | null
    thumbnailUrl?: StringFilter<"Vehicle"> | string
    status?: EnumVehicleStatusFilter<"Vehicle"> | $Enums.VehicleStatus
    availability?: StringFilter<"Vehicle"> | string
    featured?: BoolFilter<"Vehicle"> | boolean
    stockCount?: IntFilter<"Vehicle"> | number
    metaTitle?: StringNullableFilter<"Vehicle"> | string | null
    metaDescription?: StringNullableFilter<"Vehicle"> | string | null
    categoryId?: StringFilter<"Vehicle"> | string
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string
    images?: VehicleImageListRelationFilter
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    inquiries?: InquiryListRelationFilter
    testDrives?: TestDriveListRelationFilter
    savedBy?: SavedVehicleListRelationFilter
    configurations?: ConfigurationListRelationFilter
    branchInventory?: BranchInventoryListRelationFilter
  }

  export type VehicleOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    variant?: SortOrderInput | SortOrder
    cashPrice?: SortOrder
    downPayment?: SortOrder
    monthlyPayment?: SortOrder
    leaseTerm?: SortOrder
    transmission?: SortOrder
    fuelType?: SortOrder
    engineSize?: SortOrderInput | SortOrder
    horsepower?: SortOrderInput | SortOrder
    seatingCapacity?: SortOrder
    cargoSpace?: SortOrderInput | SortOrder
    features?: SortOrder
    specifications?: SortOrder
    description?: SortOrderInput | SortOrder
    videos?: SortOrder
    model3dUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrder
    status?: SortOrder
    availability?: SortOrder
    featured?: SortOrder
    stockCount?: SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    images?: VehicleImageOrderByRelationAggregateInput
    category?: CategoryOrderByWithRelationInput
    inquiries?: InquiryOrderByRelationAggregateInput
    testDrives?: TestDriveOrderByRelationAggregateInput
    savedBy?: SavedVehicleOrderByRelationAggregateInput
    configurations?: ConfigurationOrderByRelationAggregateInput
    branchInventory?: BranchInventoryOrderByRelationAggregateInput
  }

  export type VehicleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    brand?: StringFilter<"Vehicle"> | string
    model?: StringFilter<"Vehicle"> | string
    year?: IntFilter<"Vehicle"> | number
    variant?: StringNullableFilter<"Vehicle"> | string | null
    cashPrice?: DecimalFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFilter<"Vehicle"> | number
    transmission?: StringFilter<"Vehicle"> | string
    fuelType?: StringFilter<"Vehicle"> | string
    engineSize?: StringNullableFilter<"Vehicle"> | string | null
    horsepower?: IntNullableFilter<"Vehicle"> | number | null
    seatingCapacity?: IntFilter<"Vehicle"> | number
    cargoSpace?: StringNullableFilter<"Vehicle"> | string | null
    features?: JsonFilter<"Vehicle">
    specifications?: JsonFilter<"Vehicle">
    description?: StringNullableFilter<"Vehicle"> | string | null
    videos?: StringNullableListFilter<"Vehicle">
    model3dUrl?: StringNullableFilter<"Vehicle"> | string | null
    thumbnailUrl?: StringFilter<"Vehicle"> | string
    status?: EnumVehicleStatusFilter<"Vehicle"> | $Enums.VehicleStatus
    availability?: StringFilter<"Vehicle"> | string
    featured?: BoolFilter<"Vehicle"> | boolean
    stockCount?: IntFilter<"Vehicle"> | number
    metaTitle?: StringNullableFilter<"Vehicle"> | string | null
    metaDescription?: StringNullableFilter<"Vehicle"> | string | null
    categoryId?: StringFilter<"Vehicle"> | string
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string
    images?: VehicleImageListRelationFilter
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    inquiries?: InquiryListRelationFilter
    testDrives?: TestDriveListRelationFilter
    savedBy?: SavedVehicleListRelationFilter
    configurations?: ConfigurationListRelationFilter
    branchInventory?: BranchInventoryListRelationFilter
  }, "id" | "slug">

  export type VehicleOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    variant?: SortOrderInput | SortOrder
    cashPrice?: SortOrder
    downPayment?: SortOrder
    monthlyPayment?: SortOrder
    leaseTerm?: SortOrder
    transmission?: SortOrder
    fuelType?: SortOrder
    engineSize?: SortOrderInput | SortOrder
    horsepower?: SortOrderInput | SortOrder
    seatingCapacity?: SortOrder
    cargoSpace?: SortOrderInput | SortOrder
    features?: SortOrder
    specifications?: SortOrder
    description?: SortOrderInput | SortOrder
    videos?: SortOrder
    model3dUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrder
    status?: SortOrder
    availability?: SortOrder
    featured?: SortOrder
    stockCount?: SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VehicleCountOrderByAggregateInput
    _avg?: VehicleAvgOrderByAggregateInput
    _max?: VehicleMaxOrderByAggregateInput
    _min?: VehicleMinOrderByAggregateInput
    _sum?: VehicleSumOrderByAggregateInput
  }

  export type VehicleScalarWhereWithAggregatesInput = {
    AND?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    OR?: VehicleScalarWhereWithAggregatesInput[]
    NOT?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vehicle"> | string
    slug?: StringWithAggregatesFilter<"Vehicle"> | string
    brand?: StringWithAggregatesFilter<"Vehicle"> | string
    model?: StringWithAggregatesFilter<"Vehicle"> | string
    year?: IntWithAggregatesFilter<"Vehicle"> | number
    variant?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    cashPrice?: DecimalWithAggregatesFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalWithAggregatesFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalWithAggregatesFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntWithAggregatesFilter<"Vehicle"> | number
    transmission?: StringWithAggregatesFilter<"Vehicle"> | string
    fuelType?: StringWithAggregatesFilter<"Vehicle"> | string
    engineSize?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    horsepower?: IntNullableWithAggregatesFilter<"Vehicle"> | number | null
    seatingCapacity?: IntWithAggregatesFilter<"Vehicle"> | number
    cargoSpace?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    features?: JsonWithAggregatesFilter<"Vehicle">
    specifications?: JsonWithAggregatesFilter<"Vehicle">
    description?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    videos?: StringNullableListFilter<"Vehicle">
    model3dUrl?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    thumbnailUrl?: StringWithAggregatesFilter<"Vehicle"> | string
    status?: EnumVehicleStatusWithAggregatesFilter<"Vehicle"> | $Enums.VehicleStatus
    availability?: StringWithAggregatesFilter<"Vehicle"> | string
    featured?: BoolWithAggregatesFilter<"Vehicle"> | boolean
    stockCount?: IntWithAggregatesFilter<"Vehicle"> | number
    metaTitle?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    categoryId?: StringWithAggregatesFilter<"Vehicle"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
  }

  export type VehicleImageWhereInput = {
    AND?: VehicleImageWhereInput | VehicleImageWhereInput[]
    OR?: VehicleImageWhereInput[]
    NOT?: VehicleImageWhereInput | VehicleImageWhereInput[]
    id?: StringFilter<"VehicleImage"> | string
    url?: StringFilter<"VehicleImage"> | string
    alt?: StringFilter<"VehicleImage"> | string
    type?: StringFilter<"VehicleImage"> | string
    order?: IntFilter<"VehicleImage"> | number
    vehicleId?: StringFilter<"VehicleImage"> | string
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
  }

  export type VehicleImageOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    type?: SortOrder
    order?: SortOrder
    vehicleId?: SortOrder
    vehicle?: VehicleOrderByWithRelationInput
  }

  export type VehicleImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VehicleImageWhereInput | VehicleImageWhereInput[]
    OR?: VehicleImageWhereInput[]
    NOT?: VehicleImageWhereInput | VehicleImageWhereInput[]
    url?: StringFilter<"VehicleImage"> | string
    alt?: StringFilter<"VehicleImage"> | string
    type?: StringFilter<"VehicleImage"> | string
    order?: IntFilter<"VehicleImage"> | number
    vehicleId?: StringFilter<"VehicleImage"> | string
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
  }, "id">

  export type VehicleImageOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    type?: SortOrder
    order?: SortOrder
    vehicleId?: SortOrder
    _count?: VehicleImageCountOrderByAggregateInput
    _avg?: VehicleImageAvgOrderByAggregateInput
    _max?: VehicleImageMaxOrderByAggregateInput
    _min?: VehicleImageMinOrderByAggregateInput
    _sum?: VehicleImageSumOrderByAggregateInput
  }

  export type VehicleImageScalarWhereWithAggregatesInput = {
    AND?: VehicleImageScalarWhereWithAggregatesInput | VehicleImageScalarWhereWithAggregatesInput[]
    OR?: VehicleImageScalarWhereWithAggregatesInput[]
    NOT?: VehicleImageScalarWhereWithAggregatesInput | VehicleImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VehicleImage"> | string
    url?: StringWithAggregatesFilter<"VehicleImage"> | string
    alt?: StringWithAggregatesFilter<"VehicleImage"> | string
    type?: StringWithAggregatesFilter<"VehicleImage"> | string
    order?: IntWithAggregatesFilter<"VehicleImage"> | number
    vehicleId?: StringWithAggregatesFilter<"VehicleImage"> | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    icon?: StringNullableFilter<"Category"> | string | null
    order?: IntFilter<"Category"> | number
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    vehicles?: VehicleListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicles?: VehicleOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    description?: StringNullableFilter<"Category"> | string | null
    icon?: StringNullableFilter<"Category"> | string | null
    order?: IntFilter<"Category"> | number
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    vehicles?: VehicleListRelationFilter
  }, "id" | "name" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Category"> | string | null
    order?: IntWithAggregatesFilter<"Category"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    clerkId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    preferences?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    savedVehicles?: SavedVehicleListRelationFilter
    configurations?: ConfigurationListRelationFilter
    inquiries?: InquiryListRelationFilter
    testDrives?: TestDriveListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    clerkId?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    savedVehicles?: SavedVehicleOrderByRelationAggregateInput
    configurations?: ConfigurationOrderByRelationAggregateInput
    inquiries?: InquiryOrderByRelationAggregateInput
    testDrives?: TestDriveOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clerkId?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    preferences?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    savedVehicles?: SavedVehicleListRelationFilter
    configurations?: ConfigurationListRelationFilter
    inquiries?: InquiryListRelationFilter
    testDrives?: TestDriveListRelationFilter
  }, "id" | "clerkId" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    clerkId?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    clerkId?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    preferences?: JsonNullableWithAggregatesFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SavedVehicleWhereInput = {
    AND?: SavedVehicleWhereInput | SavedVehicleWhereInput[]
    OR?: SavedVehicleWhereInput[]
    NOT?: SavedVehicleWhereInput | SavedVehicleWhereInput[]
    id?: StringFilter<"SavedVehicle"> | string
    userId?: StringFilter<"SavedVehicle"> | string
    vehicleId?: StringFilter<"SavedVehicle"> | string
    notes?: StringNullableFilter<"SavedVehicle"> | string | null
    createdAt?: DateTimeFilter<"SavedVehicle"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
  }

  export type SavedVehicleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
  }

  export type SavedVehicleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_vehicleId?: SavedVehicleUserIdVehicleIdCompoundUniqueInput
    AND?: SavedVehicleWhereInput | SavedVehicleWhereInput[]
    OR?: SavedVehicleWhereInput[]
    NOT?: SavedVehicleWhereInput | SavedVehicleWhereInput[]
    userId?: StringFilter<"SavedVehicle"> | string
    vehicleId?: StringFilter<"SavedVehicle"> | string
    notes?: StringNullableFilter<"SavedVehicle"> | string | null
    createdAt?: DateTimeFilter<"SavedVehicle"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
  }, "id" | "userId_vehicleId">

  export type SavedVehicleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SavedVehicleCountOrderByAggregateInput
    _max?: SavedVehicleMaxOrderByAggregateInput
    _min?: SavedVehicleMinOrderByAggregateInput
  }

  export type SavedVehicleScalarWhereWithAggregatesInput = {
    AND?: SavedVehicleScalarWhereWithAggregatesInput | SavedVehicleScalarWhereWithAggregatesInput[]
    OR?: SavedVehicleScalarWhereWithAggregatesInput[]
    NOT?: SavedVehicleScalarWhereWithAggregatesInput | SavedVehicleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SavedVehicle"> | string
    userId?: StringWithAggregatesFilter<"SavedVehicle"> | string
    vehicleId?: StringWithAggregatesFilter<"SavedVehicle"> | string
    notes?: StringNullableWithAggregatesFilter<"SavedVehicle"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SavedVehicle"> | Date | string
  }

  export type ConfigurationWhereInput = {
    AND?: ConfigurationWhereInput | ConfigurationWhereInput[]
    OR?: ConfigurationWhereInput[]
    NOT?: ConfigurationWhereInput | ConfigurationWhereInput[]
    id?: StringFilter<"Configuration"> | string
    userId?: StringFilter<"Configuration"> | string
    vehicleId?: StringFilter<"Configuration"> | string
    color?: StringFilter<"Configuration"> | string
    colorHex?: StringFilter<"Configuration"> | string
    wheels?: StringNullableFilter<"Configuration"> | string | null
    interior?: StringNullableFilter<"Configuration"> | string | null
    packages?: JsonFilter<"Configuration">
    accessories?: JsonFilter<"Configuration">
    totalPrice?: DecimalFilter<"Configuration"> | Decimal | DecimalJsLike | number | string
    shared?: BoolFilter<"Configuration"> | boolean
    shareToken?: StringNullableFilter<"Configuration"> | string | null
    createdAt?: DateTimeFilter<"Configuration"> | Date | string
    updatedAt?: DateTimeFilter<"Configuration"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
  }

  export type ConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    color?: SortOrder
    colorHex?: SortOrder
    wheels?: SortOrderInput | SortOrder
    interior?: SortOrderInput | SortOrder
    packages?: SortOrder
    accessories?: SortOrder
    totalPrice?: SortOrder
    shared?: SortOrder
    shareToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
  }

  export type ConfigurationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shareToken?: string
    AND?: ConfigurationWhereInput | ConfigurationWhereInput[]
    OR?: ConfigurationWhereInput[]
    NOT?: ConfigurationWhereInput | ConfigurationWhereInput[]
    userId?: StringFilter<"Configuration"> | string
    vehicleId?: StringFilter<"Configuration"> | string
    color?: StringFilter<"Configuration"> | string
    colorHex?: StringFilter<"Configuration"> | string
    wheels?: StringNullableFilter<"Configuration"> | string | null
    interior?: StringNullableFilter<"Configuration"> | string | null
    packages?: JsonFilter<"Configuration">
    accessories?: JsonFilter<"Configuration">
    totalPrice?: DecimalFilter<"Configuration"> | Decimal | DecimalJsLike | number | string
    shared?: BoolFilter<"Configuration"> | boolean
    createdAt?: DateTimeFilter<"Configuration"> | Date | string
    updatedAt?: DateTimeFilter<"Configuration"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
  }, "id" | "shareToken">

  export type ConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    color?: SortOrder
    colorHex?: SortOrder
    wheels?: SortOrderInput | SortOrder
    interior?: SortOrderInput | SortOrder
    packages?: SortOrder
    accessories?: SortOrder
    totalPrice?: SortOrder
    shared?: SortOrder
    shareToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConfigurationCountOrderByAggregateInput
    _avg?: ConfigurationAvgOrderByAggregateInput
    _max?: ConfigurationMaxOrderByAggregateInput
    _min?: ConfigurationMinOrderByAggregateInput
    _sum?: ConfigurationSumOrderByAggregateInput
  }

  export type ConfigurationScalarWhereWithAggregatesInput = {
    AND?: ConfigurationScalarWhereWithAggregatesInput | ConfigurationScalarWhereWithAggregatesInput[]
    OR?: ConfigurationScalarWhereWithAggregatesInput[]
    NOT?: ConfigurationScalarWhereWithAggregatesInput | ConfigurationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Configuration"> | string
    userId?: StringWithAggregatesFilter<"Configuration"> | string
    vehicleId?: StringWithAggregatesFilter<"Configuration"> | string
    color?: StringWithAggregatesFilter<"Configuration"> | string
    colorHex?: StringWithAggregatesFilter<"Configuration"> | string
    wheels?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
    interior?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
    packages?: JsonWithAggregatesFilter<"Configuration">
    accessories?: JsonWithAggregatesFilter<"Configuration">
    totalPrice?: DecimalWithAggregatesFilter<"Configuration"> | Decimal | DecimalJsLike | number | string
    shared?: BoolWithAggregatesFilter<"Configuration"> | boolean
    shareToken?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Configuration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Configuration"> | Date | string
  }

  export type TestDriveWhereInput = {
    AND?: TestDriveWhereInput | TestDriveWhereInput[]
    OR?: TestDriveWhereInput[]
    NOT?: TestDriveWhereInput | TestDriveWhereInput[]
    id?: StringFilter<"TestDrive"> | string
    userId?: StringFilter<"TestDrive"> | string
    vehicleId?: StringFilter<"TestDrive"> | string
    preferredDate?: DateTimeFilter<"TestDrive"> | Date | string
    preferredTime?: StringFilter<"TestDrive"> | string
    location?: StringFilter<"TestDrive"> | string
    firstName?: StringFilter<"TestDrive"> | string
    lastName?: StringFilter<"TestDrive"> | string
    email?: StringFilter<"TestDrive"> | string
    phone?: StringFilter<"TestDrive"> | string
    status?: EnumBookingStatusFilter<"TestDrive"> | $Enums.BookingStatus
    notes?: StringNullableFilter<"TestDrive"> | string | null
    adminNotes?: StringNullableFilter<"TestDrive"> | string | null
    confirmedAt?: DateTimeNullableFilter<"TestDrive"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"TestDrive"> | Date | string | null
    createdAt?: DateTimeFilter<"TestDrive"> | Date | string
    updatedAt?: DateTimeFilter<"TestDrive"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
  }

  export type TestDriveOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    preferredDate?: SortOrder
    preferredTime?: SortOrder
    location?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
  }

  export type TestDriveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestDriveWhereInput | TestDriveWhereInput[]
    OR?: TestDriveWhereInput[]
    NOT?: TestDriveWhereInput | TestDriveWhereInput[]
    userId?: StringFilter<"TestDrive"> | string
    vehicleId?: StringFilter<"TestDrive"> | string
    preferredDate?: DateTimeFilter<"TestDrive"> | Date | string
    preferredTime?: StringFilter<"TestDrive"> | string
    location?: StringFilter<"TestDrive"> | string
    firstName?: StringFilter<"TestDrive"> | string
    lastName?: StringFilter<"TestDrive"> | string
    email?: StringFilter<"TestDrive"> | string
    phone?: StringFilter<"TestDrive"> | string
    status?: EnumBookingStatusFilter<"TestDrive"> | $Enums.BookingStatus
    notes?: StringNullableFilter<"TestDrive"> | string | null
    adminNotes?: StringNullableFilter<"TestDrive"> | string | null
    confirmedAt?: DateTimeNullableFilter<"TestDrive"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"TestDrive"> | Date | string | null
    createdAt?: DateTimeFilter<"TestDrive"> | Date | string
    updatedAt?: DateTimeFilter<"TestDrive"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
  }, "id">

  export type TestDriveOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    preferredDate?: SortOrder
    preferredTime?: SortOrder
    location?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestDriveCountOrderByAggregateInput
    _max?: TestDriveMaxOrderByAggregateInput
    _min?: TestDriveMinOrderByAggregateInput
  }

  export type TestDriveScalarWhereWithAggregatesInput = {
    AND?: TestDriveScalarWhereWithAggregatesInput | TestDriveScalarWhereWithAggregatesInput[]
    OR?: TestDriveScalarWhereWithAggregatesInput[]
    NOT?: TestDriveScalarWhereWithAggregatesInput | TestDriveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestDrive"> | string
    userId?: StringWithAggregatesFilter<"TestDrive"> | string
    vehicleId?: StringWithAggregatesFilter<"TestDrive"> | string
    preferredDate?: DateTimeWithAggregatesFilter<"TestDrive"> | Date | string
    preferredTime?: StringWithAggregatesFilter<"TestDrive"> | string
    location?: StringWithAggregatesFilter<"TestDrive"> | string
    firstName?: StringWithAggregatesFilter<"TestDrive"> | string
    lastName?: StringWithAggregatesFilter<"TestDrive"> | string
    email?: StringWithAggregatesFilter<"TestDrive"> | string
    phone?: StringWithAggregatesFilter<"TestDrive"> | string
    status?: EnumBookingStatusWithAggregatesFilter<"TestDrive"> | $Enums.BookingStatus
    notes?: StringNullableWithAggregatesFilter<"TestDrive"> | string | null
    adminNotes?: StringNullableWithAggregatesFilter<"TestDrive"> | string | null
    confirmedAt?: DateTimeNullableWithAggregatesFilter<"TestDrive"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"TestDrive"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TestDrive"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestDrive"> | Date | string
  }

  export type InquiryWhereInput = {
    AND?: InquiryWhereInput | InquiryWhereInput[]
    OR?: InquiryWhereInput[]
    NOT?: InquiryWhereInput | InquiryWhereInput[]
    id?: StringFilter<"Inquiry"> | string
    userId?: StringNullableFilter<"Inquiry"> | string | null
    vehicleId?: StringNullableFilter<"Inquiry"> | string | null
    type?: EnumInquiryTypeFilter<"Inquiry"> | $Enums.InquiryType
    firstName?: StringFilter<"Inquiry"> | string
    lastName?: StringFilter<"Inquiry"> | string
    email?: StringFilter<"Inquiry"> | string
    phone?: StringFilter<"Inquiry"> | string
    subject?: StringNullableFilter<"Inquiry"> | string | null
    message?: StringFilter<"Inquiry"> | string
    status?: EnumInquiryStatusFilter<"Inquiry"> | $Enums.InquiryStatus
    assignedTo?: StringNullableFilter<"Inquiry"> | string | null
    response?: StringNullableFilter<"Inquiry"> | string | null
    respondedAt?: DateTimeNullableFilter<"Inquiry"> | Date | string | null
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
    updatedAt?: DateTimeFilter<"Inquiry"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    vehicle?: XOR<VehicleNullableRelationFilter, VehicleWhereInput> | null
  }

  export type InquiryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    vehicleId?: SortOrderInput | SortOrder
    type?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
  }

  export type InquiryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InquiryWhereInput | InquiryWhereInput[]
    OR?: InquiryWhereInput[]
    NOT?: InquiryWhereInput | InquiryWhereInput[]
    userId?: StringNullableFilter<"Inquiry"> | string | null
    vehicleId?: StringNullableFilter<"Inquiry"> | string | null
    type?: EnumInquiryTypeFilter<"Inquiry"> | $Enums.InquiryType
    firstName?: StringFilter<"Inquiry"> | string
    lastName?: StringFilter<"Inquiry"> | string
    email?: StringFilter<"Inquiry"> | string
    phone?: StringFilter<"Inquiry"> | string
    subject?: StringNullableFilter<"Inquiry"> | string | null
    message?: StringFilter<"Inquiry"> | string
    status?: EnumInquiryStatusFilter<"Inquiry"> | $Enums.InquiryStatus
    assignedTo?: StringNullableFilter<"Inquiry"> | string | null
    response?: StringNullableFilter<"Inquiry"> | string | null
    respondedAt?: DateTimeNullableFilter<"Inquiry"> | Date | string | null
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
    updatedAt?: DateTimeFilter<"Inquiry"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    vehicle?: XOR<VehicleNullableRelationFilter, VehicleWhereInput> | null
  }, "id">

  export type InquiryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    vehicleId?: SortOrderInput | SortOrder
    type?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InquiryCountOrderByAggregateInput
    _max?: InquiryMaxOrderByAggregateInput
    _min?: InquiryMinOrderByAggregateInput
  }

  export type InquiryScalarWhereWithAggregatesInput = {
    AND?: InquiryScalarWhereWithAggregatesInput | InquiryScalarWhereWithAggregatesInput[]
    OR?: InquiryScalarWhereWithAggregatesInput[]
    NOT?: InquiryScalarWhereWithAggregatesInput | InquiryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Inquiry"> | string
    userId?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    vehicleId?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    type?: EnumInquiryTypeWithAggregatesFilter<"Inquiry"> | $Enums.InquiryType
    firstName?: StringWithAggregatesFilter<"Inquiry"> | string
    lastName?: StringWithAggregatesFilter<"Inquiry"> | string
    email?: StringWithAggregatesFilter<"Inquiry"> | string
    phone?: StringWithAggregatesFilter<"Inquiry"> | string
    subject?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    message?: StringWithAggregatesFilter<"Inquiry"> | string
    status?: EnumInquiryStatusWithAggregatesFilter<"Inquiry"> | $Enums.InquiryStatus
    assignedTo?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    response?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    respondedAt?: DateTimeNullableWithAggregatesFilter<"Inquiry"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Inquiry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inquiry"> | Date | string
  }

  export type FinancingApplicationWhereInput = {
    AND?: FinancingApplicationWhereInput | FinancingApplicationWhereInput[]
    OR?: FinancingApplicationWhereInput[]
    NOT?: FinancingApplicationWhereInput | FinancingApplicationWhereInput[]
    id?: StringFilter<"FinancingApplication"> | string
    firstName?: StringFilter<"FinancingApplication"> | string
    middleName?: StringNullableFilter<"FinancingApplication"> | string | null
    lastName?: StringFilter<"FinancingApplication"> | string
    email?: StringFilter<"FinancingApplication"> | string
    phone?: StringFilter<"FinancingApplication"> | string
    birthDate?: DateTimeFilter<"FinancingApplication"> | Date | string
    civilStatus?: StringFilter<"FinancingApplication"> | string
    address?: StringFilter<"FinancingApplication"> | string
    employmentStatus?: StringFilter<"FinancingApplication"> | string
    monthlyIncome?: DecimalFilter<"FinancingApplication"> | Decimal | DecimalJsLike | number | string
    employer?: StringNullableFilter<"FinancingApplication"> | string | null
    yearsEmployed?: IntNullableFilter<"FinancingApplication"> | number | null
    vehicleId?: StringFilter<"FinancingApplication"> | string
    vehicleName?: StringFilter<"FinancingApplication"> | string
    downPayment?: DecimalFilter<"FinancingApplication"> | Decimal | DecimalJsLike | number | string
    loanTerm?: IntFilter<"FinancingApplication"> | number
    estimatedMonthly?: DecimalFilter<"FinancingApplication"> | Decimal | DecimalJsLike | number | string
    validIds?: JsonFilter<"FinancingApplication">
    proofOfIncome?: JsonFilter<"FinancingApplication">
    proofOfBilling?: JsonFilter<"FinancingApplication">
    status?: EnumApplicationStatusFilter<"FinancingApplication"> | $Enums.ApplicationStatus
    approvedAmount?: DecimalNullableFilter<"FinancingApplication"> | Decimal | DecimalJsLike | number | string | null
    approvedTerm?: IntNullableFilter<"FinancingApplication"> | number | null
    applicantNotes?: StringNullableFilter<"FinancingApplication"> | string | null
    adminNotes?: StringNullableFilter<"FinancingApplication"> | string | null
    submittedAt?: DateTimeFilter<"FinancingApplication"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"FinancingApplication"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"FinancingApplication"> | Date | string | null
    createdAt?: DateTimeFilter<"FinancingApplication"> | Date | string
    updatedAt?: DateTimeFilter<"FinancingApplication"> | Date | string
  }

  export type FinancingApplicationOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    birthDate?: SortOrder
    civilStatus?: SortOrder
    address?: SortOrder
    employmentStatus?: SortOrder
    monthlyIncome?: SortOrder
    employer?: SortOrderInput | SortOrder
    yearsEmployed?: SortOrderInput | SortOrder
    vehicleId?: SortOrder
    vehicleName?: SortOrder
    downPayment?: SortOrder
    loanTerm?: SortOrder
    estimatedMonthly?: SortOrder
    validIds?: SortOrder
    proofOfIncome?: SortOrder
    proofOfBilling?: SortOrder
    status?: SortOrder
    approvedAmount?: SortOrderInput | SortOrder
    approvedTerm?: SortOrderInput | SortOrder
    applicantNotes?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancingApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FinancingApplicationWhereInput | FinancingApplicationWhereInput[]
    OR?: FinancingApplicationWhereInput[]
    NOT?: FinancingApplicationWhereInput | FinancingApplicationWhereInput[]
    firstName?: StringFilter<"FinancingApplication"> | string
    middleName?: StringNullableFilter<"FinancingApplication"> | string | null
    lastName?: StringFilter<"FinancingApplication"> | string
    email?: StringFilter<"FinancingApplication"> | string
    phone?: StringFilter<"FinancingApplication"> | string
    birthDate?: DateTimeFilter<"FinancingApplication"> | Date | string
    civilStatus?: StringFilter<"FinancingApplication"> | string
    address?: StringFilter<"FinancingApplication"> | string
    employmentStatus?: StringFilter<"FinancingApplication"> | string
    monthlyIncome?: DecimalFilter<"FinancingApplication"> | Decimal | DecimalJsLike | number | string
    employer?: StringNullableFilter<"FinancingApplication"> | string | null
    yearsEmployed?: IntNullableFilter<"FinancingApplication"> | number | null
    vehicleId?: StringFilter<"FinancingApplication"> | string
    vehicleName?: StringFilter<"FinancingApplication"> | string
    downPayment?: DecimalFilter<"FinancingApplication"> | Decimal | DecimalJsLike | number | string
    loanTerm?: IntFilter<"FinancingApplication"> | number
    estimatedMonthly?: DecimalFilter<"FinancingApplication"> | Decimal | DecimalJsLike | number | string
    validIds?: JsonFilter<"FinancingApplication">
    proofOfIncome?: JsonFilter<"FinancingApplication">
    proofOfBilling?: JsonFilter<"FinancingApplication">
    status?: EnumApplicationStatusFilter<"FinancingApplication"> | $Enums.ApplicationStatus
    approvedAmount?: DecimalNullableFilter<"FinancingApplication"> | Decimal | DecimalJsLike | number | string | null
    approvedTerm?: IntNullableFilter<"FinancingApplication"> | number | null
    applicantNotes?: StringNullableFilter<"FinancingApplication"> | string | null
    adminNotes?: StringNullableFilter<"FinancingApplication"> | string | null
    submittedAt?: DateTimeFilter<"FinancingApplication"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"FinancingApplication"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"FinancingApplication"> | Date | string | null
    createdAt?: DateTimeFilter<"FinancingApplication"> | Date | string
    updatedAt?: DateTimeFilter<"FinancingApplication"> | Date | string
  }, "id">

  export type FinancingApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    birthDate?: SortOrder
    civilStatus?: SortOrder
    address?: SortOrder
    employmentStatus?: SortOrder
    monthlyIncome?: SortOrder
    employer?: SortOrderInput | SortOrder
    yearsEmployed?: SortOrderInput | SortOrder
    vehicleId?: SortOrder
    vehicleName?: SortOrder
    downPayment?: SortOrder
    loanTerm?: SortOrder
    estimatedMonthly?: SortOrder
    validIds?: SortOrder
    proofOfIncome?: SortOrder
    proofOfBilling?: SortOrder
    status?: SortOrder
    approvedAmount?: SortOrderInput | SortOrder
    approvedTerm?: SortOrderInput | SortOrder
    applicantNotes?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FinancingApplicationCountOrderByAggregateInput
    _avg?: FinancingApplicationAvgOrderByAggregateInput
    _max?: FinancingApplicationMaxOrderByAggregateInput
    _min?: FinancingApplicationMinOrderByAggregateInput
    _sum?: FinancingApplicationSumOrderByAggregateInput
  }

  export type FinancingApplicationScalarWhereWithAggregatesInput = {
    AND?: FinancingApplicationScalarWhereWithAggregatesInput | FinancingApplicationScalarWhereWithAggregatesInput[]
    OR?: FinancingApplicationScalarWhereWithAggregatesInput[]
    NOT?: FinancingApplicationScalarWhereWithAggregatesInput | FinancingApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FinancingApplication"> | string
    firstName?: StringWithAggregatesFilter<"FinancingApplication"> | string
    middleName?: StringNullableWithAggregatesFilter<"FinancingApplication"> | string | null
    lastName?: StringWithAggregatesFilter<"FinancingApplication"> | string
    email?: StringWithAggregatesFilter<"FinancingApplication"> | string
    phone?: StringWithAggregatesFilter<"FinancingApplication"> | string
    birthDate?: DateTimeWithAggregatesFilter<"FinancingApplication"> | Date | string
    civilStatus?: StringWithAggregatesFilter<"FinancingApplication"> | string
    address?: StringWithAggregatesFilter<"FinancingApplication"> | string
    employmentStatus?: StringWithAggregatesFilter<"FinancingApplication"> | string
    monthlyIncome?: DecimalWithAggregatesFilter<"FinancingApplication"> | Decimal | DecimalJsLike | number | string
    employer?: StringNullableWithAggregatesFilter<"FinancingApplication"> | string | null
    yearsEmployed?: IntNullableWithAggregatesFilter<"FinancingApplication"> | number | null
    vehicleId?: StringWithAggregatesFilter<"FinancingApplication"> | string
    vehicleName?: StringWithAggregatesFilter<"FinancingApplication"> | string
    downPayment?: DecimalWithAggregatesFilter<"FinancingApplication"> | Decimal | DecimalJsLike | number | string
    loanTerm?: IntWithAggregatesFilter<"FinancingApplication"> | number
    estimatedMonthly?: DecimalWithAggregatesFilter<"FinancingApplication"> | Decimal | DecimalJsLike | number | string
    validIds?: JsonWithAggregatesFilter<"FinancingApplication">
    proofOfIncome?: JsonWithAggregatesFilter<"FinancingApplication">
    proofOfBilling?: JsonWithAggregatesFilter<"FinancingApplication">
    status?: EnumApplicationStatusWithAggregatesFilter<"FinancingApplication"> | $Enums.ApplicationStatus
    approvedAmount?: DecimalNullableWithAggregatesFilter<"FinancingApplication"> | Decimal | DecimalJsLike | number | string | null
    approvedTerm?: IntNullableWithAggregatesFilter<"FinancingApplication"> | number | null
    applicantNotes?: StringNullableWithAggregatesFilter<"FinancingApplication"> | string | null
    adminNotes?: StringNullableWithAggregatesFilter<"FinancingApplication"> | string | null
    submittedAt?: DateTimeWithAggregatesFilter<"FinancingApplication"> | Date | string
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"FinancingApplication"> | Date | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"FinancingApplication"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FinancingApplication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FinancingApplication"> | Date | string
  }

  export type TradeInWhereInput = {
    AND?: TradeInWhereInput | TradeInWhereInput[]
    OR?: TradeInWhereInput[]
    NOT?: TradeInWhereInput | TradeInWhereInput[]
    id?: StringFilter<"TradeIn"> | string
    firstName?: StringFilter<"TradeIn"> | string
    lastName?: StringFilter<"TradeIn"> | string
    email?: StringFilter<"TradeIn"> | string
    phone?: StringFilter<"TradeIn"> | string
    brand?: StringFilter<"TradeIn"> | string
    model?: StringFilter<"TradeIn"> | string
    year?: IntFilter<"TradeIn"> | number
    variant?: StringNullableFilter<"TradeIn"> | string | null
    mileage?: IntFilter<"TradeIn"> | number
    transmission?: StringFilter<"TradeIn"> | string
    fuelType?: StringFilter<"TradeIn"> | string
    color?: StringNullableFilter<"TradeIn"> | string | null
    condition?: StringFilter<"TradeIn"> | string
    hasAccidents?: BoolFilter<"TradeIn"> | boolean
    serviceHistory?: BoolFilter<"TradeIn"> | boolean
    images?: StringNullableListFilter<"TradeIn">
    description?: StringNullableFilter<"TradeIn"> | string | null
    expectedPrice?: DecimalNullableFilter<"TradeIn"> | Decimal | DecimalJsLike | number | string | null
    offeredPrice?: DecimalNullableFilter<"TradeIn"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumTradeInStatusFilter<"TradeIn"> | $Enums.TradeInStatus
    applicantNotes?: StringNullableFilter<"TradeIn"> | string | null
    evaluationNotes?: StringNullableFilter<"TradeIn"> | string | null
    evaluatedAt?: DateTimeNullableFilter<"TradeIn"> | Date | string | null
    offerMadeAt?: DateTimeNullableFilter<"TradeIn"> | Date | string | null
    createdAt?: DateTimeFilter<"TradeIn"> | Date | string
    updatedAt?: DateTimeFilter<"TradeIn"> | Date | string
  }

  export type TradeInOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    variant?: SortOrderInput | SortOrder
    mileage?: SortOrder
    transmission?: SortOrder
    fuelType?: SortOrder
    color?: SortOrderInput | SortOrder
    condition?: SortOrder
    hasAccidents?: SortOrder
    serviceHistory?: SortOrder
    images?: SortOrder
    description?: SortOrderInput | SortOrder
    expectedPrice?: SortOrderInput | SortOrder
    offeredPrice?: SortOrderInput | SortOrder
    status?: SortOrder
    applicantNotes?: SortOrderInput | SortOrder
    evaluationNotes?: SortOrderInput | SortOrder
    evaluatedAt?: SortOrderInput | SortOrder
    offerMadeAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradeInWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TradeInWhereInput | TradeInWhereInput[]
    OR?: TradeInWhereInput[]
    NOT?: TradeInWhereInput | TradeInWhereInput[]
    firstName?: StringFilter<"TradeIn"> | string
    lastName?: StringFilter<"TradeIn"> | string
    email?: StringFilter<"TradeIn"> | string
    phone?: StringFilter<"TradeIn"> | string
    brand?: StringFilter<"TradeIn"> | string
    model?: StringFilter<"TradeIn"> | string
    year?: IntFilter<"TradeIn"> | number
    variant?: StringNullableFilter<"TradeIn"> | string | null
    mileage?: IntFilter<"TradeIn"> | number
    transmission?: StringFilter<"TradeIn"> | string
    fuelType?: StringFilter<"TradeIn"> | string
    color?: StringNullableFilter<"TradeIn"> | string | null
    condition?: StringFilter<"TradeIn"> | string
    hasAccidents?: BoolFilter<"TradeIn"> | boolean
    serviceHistory?: BoolFilter<"TradeIn"> | boolean
    images?: StringNullableListFilter<"TradeIn">
    description?: StringNullableFilter<"TradeIn"> | string | null
    expectedPrice?: DecimalNullableFilter<"TradeIn"> | Decimal | DecimalJsLike | number | string | null
    offeredPrice?: DecimalNullableFilter<"TradeIn"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumTradeInStatusFilter<"TradeIn"> | $Enums.TradeInStatus
    applicantNotes?: StringNullableFilter<"TradeIn"> | string | null
    evaluationNotes?: StringNullableFilter<"TradeIn"> | string | null
    evaluatedAt?: DateTimeNullableFilter<"TradeIn"> | Date | string | null
    offerMadeAt?: DateTimeNullableFilter<"TradeIn"> | Date | string | null
    createdAt?: DateTimeFilter<"TradeIn"> | Date | string
    updatedAt?: DateTimeFilter<"TradeIn"> | Date | string
  }, "id">

  export type TradeInOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    variant?: SortOrderInput | SortOrder
    mileage?: SortOrder
    transmission?: SortOrder
    fuelType?: SortOrder
    color?: SortOrderInput | SortOrder
    condition?: SortOrder
    hasAccidents?: SortOrder
    serviceHistory?: SortOrder
    images?: SortOrder
    description?: SortOrderInput | SortOrder
    expectedPrice?: SortOrderInput | SortOrder
    offeredPrice?: SortOrderInput | SortOrder
    status?: SortOrder
    applicantNotes?: SortOrderInput | SortOrder
    evaluationNotes?: SortOrderInput | SortOrder
    evaluatedAt?: SortOrderInput | SortOrder
    offerMadeAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TradeInCountOrderByAggregateInput
    _avg?: TradeInAvgOrderByAggregateInput
    _max?: TradeInMaxOrderByAggregateInput
    _min?: TradeInMinOrderByAggregateInput
    _sum?: TradeInSumOrderByAggregateInput
  }

  export type TradeInScalarWhereWithAggregatesInput = {
    AND?: TradeInScalarWhereWithAggregatesInput | TradeInScalarWhereWithAggregatesInput[]
    OR?: TradeInScalarWhereWithAggregatesInput[]
    NOT?: TradeInScalarWhereWithAggregatesInput | TradeInScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TradeIn"> | string
    firstName?: StringWithAggregatesFilter<"TradeIn"> | string
    lastName?: StringWithAggregatesFilter<"TradeIn"> | string
    email?: StringWithAggregatesFilter<"TradeIn"> | string
    phone?: StringWithAggregatesFilter<"TradeIn"> | string
    brand?: StringWithAggregatesFilter<"TradeIn"> | string
    model?: StringWithAggregatesFilter<"TradeIn"> | string
    year?: IntWithAggregatesFilter<"TradeIn"> | number
    variant?: StringNullableWithAggregatesFilter<"TradeIn"> | string | null
    mileage?: IntWithAggregatesFilter<"TradeIn"> | number
    transmission?: StringWithAggregatesFilter<"TradeIn"> | string
    fuelType?: StringWithAggregatesFilter<"TradeIn"> | string
    color?: StringNullableWithAggregatesFilter<"TradeIn"> | string | null
    condition?: StringWithAggregatesFilter<"TradeIn"> | string
    hasAccidents?: BoolWithAggregatesFilter<"TradeIn"> | boolean
    serviceHistory?: BoolWithAggregatesFilter<"TradeIn"> | boolean
    images?: StringNullableListFilter<"TradeIn">
    description?: StringNullableWithAggregatesFilter<"TradeIn"> | string | null
    expectedPrice?: DecimalNullableWithAggregatesFilter<"TradeIn"> | Decimal | DecimalJsLike | number | string | null
    offeredPrice?: DecimalNullableWithAggregatesFilter<"TradeIn"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumTradeInStatusWithAggregatesFilter<"TradeIn"> | $Enums.TradeInStatus
    applicantNotes?: StringNullableWithAggregatesFilter<"TradeIn"> | string | null
    evaluationNotes?: StringNullableWithAggregatesFilter<"TradeIn"> | string | null
    evaluatedAt?: DateTimeNullableWithAggregatesFilter<"TradeIn"> | Date | string | null
    offerMadeAt?: DateTimeNullableWithAggregatesFilter<"TradeIn"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TradeIn"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TradeIn"> | Date | string
  }

  export type PromotionWhereInput = {
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    id?: StringFilter<"Promotion"> | string
    title?: StringFilter<"Promotion"> | string
    slug?: StringFilter<"Promotion"> | string
    description?: StringFilter<"Promotion"> | string
    bannerImage?: StringFilter<"Promotion"> | string
    thumbnailImage?: StringNullableFilter<"Promotion"> | string | null
    discountType?: StringFilter<"Promotion"> | string
    discountValue?: DecimalFilter<"Promotion"> | Decimal | DecimalJsLike | number | string
    vehicleIds?: StringNullableListFilter<"Promotion">
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    endDate?: DateTimeFilter<"Promotion"> | Date | string
    isActive?: BoolFilter<"Promotion"> | boolean
    terms?: StringNullableFilter<"Promotion"> | string | null
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
  }

  export type PromotionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    bannerImage?: SortOrder
    thumbnailImage?: SortOrderInput | SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    vehicleIds?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    terms?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    title?: StringFilter<"Promotion"> | string
    description?: StringFilter<"Promotion"> | string
    bannerImage?: StringFilter<"Promotion"> | string
    thumbnailImage?: StringNullableFilter<"Promotion"> | string | null
    discountType?: StringFilter<"Promotion"> | string
    discountValue?: DecimalFilter<"Promotion"> | Decimal | DecimalJsLike | number | string
    vehicleIds?: StringNullableListFilter<"Promotion">
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    endDate?: DateTimeFilter<"Promotion"> | Date | string
    isActive?: BoolFilter<"Promotion"> | boolean
    terms?: StringNullableFilter<"Promotion"> | string | null
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
  }, "id" | "slug">

  export type PromotionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    bannerImage?: SortOrder
    thumbnailImage?: SortOrderInput | SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    vehicleIds?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    terms?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PromotionCountOrderByAggregateInput
    _avg?: PromotionAvgOrderByAggregateInput
    _max?: PromotionMaxOrderByAggregateInput
    _min?: PromotionMinOrderByAggregateInput
    _sum?: PromotionSumOrderByAggregateInput
  }

  export type PromotionScalarWhereWithAggregatesInput = {
    AND?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    OR?: PromotionScalarWhereWithAggregatesInput[]
    NOT?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Promotion"> | string
    title?: StringWithAggregatesFilter<"Promotion"> | string
    slug?: StringWithAggregatesFilter<"Promotion"> | string
    description?: StringWithAggregatesFilter<"Promotion"> | string
    bannerImage?: StringWithAggregatesFilter<"Promotion"> | string
    thumbnailImage?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    discountType?: StringWithAggregatesFilter<"Promotion"> | string
    discountValue?: DecimalWithAggregatesFilter<"Promotion"> | Decimal | DecimalJsLike | number | string
    vehicleIds?: StringNullableListFilter<"Promotion">
    startDate?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Promotion"> | boolean
    terms?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    icon?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    icon?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    link?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type DealershipCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branches?: BranchCreateNestedManyWithoutDealershipInput
  }

  export type DealershipUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branches?: BranchUncheckedCreateNestedManyWithoutDealershipInput
  }

  export type DealershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branches?: BranchUpdateManyWithoutDealershipNestedInput
  }

  export type DealershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branches?: BranchUncheckedUpdateManyWithoutDealershipNestedInput
  }

  export type DealershipCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateInput = {
    id?: string
    name: string
    address: string
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dealership: DealershipCreateNestedOneWithoutBranchesInput
    inventory?: BranchInventoryCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    phone?: string | null
    email?: string | null
    dealershipId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: BranchInventoryUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealership?: DealershipUpdateOneRequiredWithoutBranchesNestedInput
    inventory?: BranchInventoryUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dealershipId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: BranchInventoryUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateManyInput = {
    id?: string
    name: string
    address: string
    phone?: string | null
    email?: string | null
    dealershipId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dealershipId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchInventoryCreateInput = {
    id?: string
    stock?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutInventoryInput
    vehicle: VehicleCreateNestedOneWithoutBranchInventoryInput
  }

  export type BranchInventoryUncheckedCreateInput = {
    id?: string
    branchId: string
    vehicleId: string
    stock?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchInventoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutInventoryNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutBranchInventoryNestedInput
  }

  export type BranchInventoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchInventoryCreateManyInput = {
    id?: string
    branchId: string
    vehicleId: string
    stock?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchInventoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchInventoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanRateCreateInput = {
    id?: string
    bankName: string
    annualRate: Decimal | DecimalJsLike | number | string
    minTermMonths: number
    maxTermMonths: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanRateUncheckedCreateInput = {
    id?: string
    bankName: string
    annualRate: Decimal | DecimalJsLike | number | string
    minTermMonths: number
    maxTermMonths: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanRateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    annualRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minTermMonths?: IntFieldUpdateOperationsInput | number
    maxTermMonths?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanRateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    annualRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minTermMonths?: IntFieldUpdateOperationsInput | number
    maxTermMonths?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanRateCreateManyInput = {
    id?: string
    bankName: string
    annualRate: Decimal | DecimalJsLike | number | string
    minTermMonths: number
    maxTermMonths: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanRateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    annualRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minTermMonths?: IntFieldUpdateOperationsInput | number
    maxTermMonths?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanRateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    annualRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minTermMonths?: IntFieldUpdateOperationsInput | number
    maxTermMonths?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleCreateInput = {
    id?: string
    slug: string
    brand: string
    model: string
    year: number
    variant?: string | null
    cashPrice: Decimal | DecimalJsLike | number | string
    downPayment: Decimal | DecimalJsLike | number | string
    monthlyPayment: Decimal | DecimalJsLike | number | string
    leaseTerm: number
    transmission: string
    fuelType: string
    engineSize?: string | null
    horsepower?: number | null
    seatingCapacity: number
    cargoSpace?: string | null
    features: JsonNullValueInput | InputJsonValue
    specifications: JsonNullValueInput | InputJsonValue
    description?: string | null
    videos?: VehicleCreatevideosInput | string[]
    model3dUrl?: string | null
    thumbnailUrl: string
    status?: $Enums.VehicleStatus
    availability: string
    featured?: boolean
    stockCount?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VehicleImageCreateNestedManyWithoutVehicleInput
    category: CategoryCreateNestedOneWithoutVehiclesInput
    inquiries?: InquiryCreateNestedManyWithoutVehicleInput
    testDrives?: TestDriveCreateNestedManyWithoutVehicleInput
    savedBy?: SavedVehicleCreateNestedManyWithoutVehicleInput
    configurations?: ConfigurationCreateNestedManyWithoutVehicleInput
    branchInventory?: BranchInventoryCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateInput = {
    id?: string
    slug: string
    brand: string
    model: string
    year: number
    variant?: string | null
    cashPrice: Decimal | DecimalJsLike | number | string
    downPayment: Decimal | DecimalJsLike | number | string
    monthlyPayment: Decimal | DecimalJsLike | number | string
    leaseTerm: number
    transmission: string
    fuelType: string
    engineSize?: string | null
    horsepower?: number | null
    seatingCapacity: number
    cargoSpace?: string | null
    features: JsonNullValueInput | InputJsonValue
    specifications: JsonNullValueInput | InputJsonValue
    description?: string | null
    videos?: VehicleCreatevideosInput | string[]
    model3dUrl?: string | null
    thumbnailUrl: string
    status?: $Enums.VehicleStatus
    availability: string
    featured?: boolean
    stockCount?: number
    metaTitle?: string | null
    metaDescription?: string | null
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VehicleImageUncheckedCreateNestedManyWithoutVehicleInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutVehicleInput
    testDrives?: TestDriveUncheckedCreateNestedManyWithoutVehicleInput
    savedBy?: SavedVehicleUncheckedCreateNestedManyWithoutVehicleInput
    configurations?: ConfigurationUncheckedCreateNestedManyWithoutVehicleInput
    branchInventory?: BranchInventoryUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    cashPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    engineSize?: NullableStringFieldUpdateOperationsInput | string | null
    horsepower?: NullableIntFieldUpdateOperationsInput | number | null
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    cargoSpace?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    specifications?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VehicleUpdatevideosInput | string[]
    model3dUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    availability?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VehicleImageUpdateManyWithoutVehicleNestedInput
    category?: CategoryUpdateOneRequiredWithoutVehiclesNestedInput
    inquiries?: InquiryUpdateManyWithoutVehicleNestedInput
    testDrives?: TestDriveUpdateManyWithoutVehicleNestedInput
    savedBy?: SavedVehicleUpdateManyWithoutVehicleNestedInput
    configurations?: ConfigurationUpdateManyWithoutVehicleNestedInput
    branchInventory?: BranchInventoryUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    cashPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    engineSize?: NullableStringFieldUpdateOperationsInput | string | null
    horsepower?: NullableIntFieldUpdateOperationsInput | number | null
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    cargoSpace?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    specifications?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VehicleUpdatevideosInput | string[]
    model3dUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    availability?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VehicleImageUncheckedUpdateManyWithoutVehicleNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutVehicleNestedInput
    testDrives?: TestDriveUncheckedUpdateManyWithoutVehicleNestedInput
    savedBy?: SavedVehicleUncheckedUpdateManyWithoutVehicleNestedInput
    configurations?: ConfigurationUncheckedUpdateManyWithoutVehicleNestedInput
    branchInventory?: BranchInventoryUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleCreateManyInput = {
    id?: string
    slug: string
    brand: string
    model: string
    year: number
    variant?: string | null
    cashPrice: Decimal | DecimalJsLike | number | string
    downPayment: Decimal | DecimalJsLike | number | string
    monthlyPayment: Decimal | DecimalJsLike | number | string
    leaseTerm: number
    transmission: string
    fuelType: string
    engineSize?: string | null
    horsepower?: number | null
    seatingCapacity: number
    cargoSpace?: string | null
    features: JsonNullValueInput | InputJsonValue
    specifications: JsonNullValueInput | InputJsonValue
    description?: string | null
    videos?: VehicleCreatevideosInput | string[]
    model3dUrl?: string | null
    thumbnailUrl: string
    status?: $Enums.VehicleStatus
    availability: string
    featured?: boolean
    stockCount?: number
    metaTitle?: string | null
    metaDescription?: string | null
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    cashPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    engineSize?: NullableStringFieldUpdateOperationsInput | string | null
    horsepower?: NullableIntFieldUpdateOperationsInput | number | null
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    cargoSpace?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    specifications?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VehicleUpdatevideosInput | string[]
    model3dUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    availability?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    cashPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    engineSize?: NullableStringFieldUpdateOperationsInput | string | null
    horsepower?: NullableIntFieldUpdateOperationsInput | number | null
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    cargoSpace?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    specifications?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VehicleUpdatevideosInput | string[]
    model3dUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    availability?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleImageCreateInput = {
    id?: string
    url: string
    alt: string
    type: string
    order?: number
    vehicle: VehicleCreateNestedOneWithoutImagesInput
  }

  export type VehicleImageUncheckedCreateInput = {
    id?: string
    url: string
    alt: string
    type: string
    order?: number
    vehicleId: string
  }

  export type VehicleImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    vehicle?: VehicleUpdateOneRequiredWithoutImagesNestedInput
  }

  export type VehicleImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    vehicleId?: StringFieldUpdateOperationsInput | string
  }

  export type VehicleImageCreateManyInput = {
    id?: string
    url: string
    alt: string
    type: string
    order?: number
    vehicleId: string
  }

  export type VehicleImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    vehicleId?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicles?: VehicleCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicles?: VehicleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    clerkId: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    avatar?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    savedVehicles?: SavedVehicleCreateNestedManyWithoutUserInput
    configurations?: ConfigurationCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    testDrives?: TestDriveCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    clerkId: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    avatar?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    savedVehicles?: SavedVehicleUncheckedCreateNestedManyWithoutUserInput
    configurations?: ConfigurationUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    testDrives?: TestDriveUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    savedVehicles?: SavedVehicleUpdateManyWithoutUserNestedInput
    configurations?: ConfigurationUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    testDrives?: TestDriveUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    savedVehicles?: SavedVehicleUncheckedUpdateManyWithoutUserNestedInput
    configurations?: ConfigurationUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    testDrives?: TestDriveUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    clerkId: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    avatar?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedVehicleCreateInput = {
    id?: string
    notes?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSavedVehiclesInput
    vehicle: VehicleCreateNestedOneWithoutSavedByInput
  }

  export type SavedVehicleUncheckedCreateInput = {
    id?: string
    userId: string
    vehicleId: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type SavedVehicleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSavedVehiclesNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutSavedByNestedInput
  }

  export type SavedVehicleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedVehicleCreateManyInput = {
    id?: string
    userId: string
    vehicleId: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type SavedVehicleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedVehicleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationCreateInput = {
    id?: string
    color: string
    colorHex: string
    wheels?: string | null
    interior?: string | null
    packages: JsonNullValueInput | InputJsonValue
    accessories: JsonNullValueInput | InputJsonValue
    totalPrice: Decimal | DecimalJsLike | number | string
    shared?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConfigurationsInput
    vehicle: VehicleCreateNestedOneWithoutConfigurationsInput
  }

  export type ConfigurationUncheckedCreateInput = {
    id?: string
    userId: string
    vehicleId: string
    color: string
    colorHex: string
    wheels?: string | null
    interior?: string | null
    packages: JsonNullValueInput | InputJsonValue
    accessories: JsonNullValueInput | InputJsonValue
    totalPrice: Decimal | DecimalJsLike | number | string
    shared?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigurationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    colorHex?: StringFieldUpdateOperationsInput | string
    wheels?: NullableStringFieldUpdateOperationsInput | string | null
    interior?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: JsonNullValueInput | InputJsonValue
    accessories?: JsonNullValueInput | InputJsonValue
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shared?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConfigurationsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutConfigurationsNestedInput
  }

  export type ConfigurationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    colorHex?: StringFieldUpdateOperationsInput | string
    wheels?: NullableStringFieldUpdateOperationsInput | string | null
    interior?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: JsonNullValueInput | InputJsonValue
    accessories?: JsonNullValueInput | InputJsonValue
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shared?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationCreateManyInput = {
    id?: string
    userId: string
    vehicleId: string
    color: string
    colorHex: string
    wheels?: string | null
    interior?: string | null
    packages: JsonNullValueInput | InputJsonValue
    accessories: JsonNullValueInput | InputJsonValue
    totalPrice: Decimal | DecimalJsLike | number | string
    shared?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigurationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    colorHex?: StringFieldUpdateOperationsInput | string
    wheels?: NullableStringFieldUpdateOperationsInput | string | null
    interior?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: JsonNullValueInput | InputJsonValue
    accessories?: JsonNullValueInput | InputJsonValue
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shared?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    colorHex?: StringFieldUpdateOperationsInput | string
    wheels?: NullableStringFieldUpdateOperationsInput | string | null
    interior?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: JsonNullValueInput | InputJsonValue
    accessories?: JsonNullValueInput | InputJsonValue
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shared?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestDriveCreateInput = {
    id?: string
    preferredDate: Date | string
    preferredTime: string
    location: string
    firstName: string
    lastName: string
    email: string
    phone: string
    status?: $Enums.BookingStatus
    notes?: string | null
    adminNotes?: string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTestDrivesInput
    vehicle: VehicleCreateNestedOneWithoutTestDrivesInput
  }

  export type TestDriveUncheckedCreateInput = {
    id?: string
    userId: string
    vehicleId: string
    preferredDate: Date | string
    preferredTime: string
    location: string
    firstName: string
    lastName: string
    email: string
    phone: string
    status?: $Enums.BookingStatus
    notes?: string | null
    adminNotes?: string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestDriveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTestDrivesNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutTestDrivesNestedInput
  }

  export type TestDriveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestDriveCreateManyInput = {
    id?: string
    userId: string
    vehicleId: string
    preferredDate: Date | string
    preferredTime: string
    location: string
    firstName: string
    lastName: string
    email: string
    phone: string
    status?: $Enums.BookingStatus
    notes?: string | null
    adminNotes?: string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestDriveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestDriveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryCreateInput = {
    id?: string
    type: $Enums.InquiryType
    firstName: string
    lastName: string
    email: string
    phone: string
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    assignedTo?: string | null
    response?: string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutInquiriesInput
    vehicle?: VehicleCreateNestedOneWithoutInquiriesInput
  }

  export type InquiryUncheckedCreateInput = {
    id?: string
    userId?: string | null
    vehicleId?: string | null
    type: $Enums.InquiryType
    firstName: string
    lastName: string
    email: string
    phone: string
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    assignedTo?: string | null
    response?: string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InquiryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutInquiriesNestedInput
    vehicle?: VehicleUpdateOneWithoutInquiriesNestedInput
  }

  export type InquiryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryCreateManyInput = {
    id?: string
    userId?: string | null
    vehicleId?: string | null
    type: $Enums.InquiryType
    firstName: string
    lastName: string
    email: string
    phone: string
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    assignedTo?: string | null
    response?: string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InquiryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancingApplicationCreateInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phone: string
    birthDate: Date | string
    civilStatus: string
    address: string
    employmentStatus: string
    monthlyIncome: Decimal | DecimalJsLike | number | string
    employer?: string | null
    yearsEmployed?: number | null
    vehicleId: string
    vehicleName: string
    downPayment: Decimal | DecimalJsLike | number | string
    loanTerm: number
    estimatedMonthly: Decimal | DecimalJsLike | number | string
    validIds: JsonNullValueInput | InputJsonValue
    proofOfIncome: JsonNullValueInput | InputJsonValue
    proofOfBilling: JsonNullValueInput | InputJsonValue
    status?: $Enums.ApplicationStatus
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    approvedTerm?: number | null
    applicantNotes?: string | null
    adminNotes?: string | null
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancingApplicationUncheckedCreateInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phone: string
    birthDate: Date | string
    civilStatus: string
    address: string
    employmentStatus: string
    monthlyIncome: Decimal | DecimalJsLike | number | string
    employer?: string | null
    yearsEmployed?: number | null
    vehicleId: string
    vehicleName: string
    downPayment: Decimal | DecimalJsLike | number | string
    loanTerm: number
    estimatedMonthly: Decimal | DecimalJsLike | number | string
    validIds: JsonNullValueInput | InputJsonValue
    proofOfIncome: JsonNullValueInput | InputJsonValue
    proofOfBilling: JsonNullValueInput | InputJsonValue
    status?: $Enums.ApplicationStatus
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    approvedTerm?: number | null
    applicantNotes?: string | null
    adminNotes?: string | null
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancingApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    civilStatus?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    employmentStatus?: StringFieldUpdateOperationsInput | string
    monthlyIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    employer?: NullableStringFieldUpdateOperationsInput | string | null
    yearsEmployed?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleId?: StringFieldUpdateOperationsInput | string
    vehicleName?: StringFieldUpdateOperationsInput | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loanTerm?: IntFieldUpdateOperationsInput | number
    estimatedMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validIds?: JsonNullValueInput | InputJsonValue
    proofOfIncome?: JsonNullValueInput | InputJsonValue
    proofOfBilling?: JsonNullValueInput | InputJsonValue
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedTerm?: NullableIntFieldUpdateOperationsInput | number | null
    applicantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancingApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    civilStatus?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    employmentStatus?: StringFieldUpdateOperationsInput | string
    monthlyIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    employer?: NullableStringFieldUpdateOperationsInput | string | null
    yearsEmployed?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleId?: StringFieldUpdateOperationsInput | string
    vehicleName?: StringFieldUpdateOperationsInput | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loanTerm?: IntFieldUpdateOperationsInput | number
    estimatedMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validIds?: JsonNullValueInput | InputJsonValue
    proofOfIncome?: JsonNullValueInput | InputJsonValue
    proofOfBilling?: JsonNullValueInput | InputJsonValue
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedTerm?: NullableIntFieldUpdateOperationsInput | number | null
    applicantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancingApplicationCreateManyInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phone: string
    birthDate: Date | string
    civilStatus: string
    address: string
    employmentStatus: string
    monthlyIncome: Decimal | DecimalJsLike | number | string
    employer?: string | null
    yearsEmployed?: number | null
    vehicleId: string
    vehicleName: string
    downPayment: Decimal | DecimalJsLike | number | string
    loanTerm: number
    estimatedMonthly: Decimal | DecimalJsLike | number | string
    validIds: JsonNullValueInput | InputJsonValue
    proofOfIncome: JsonNullValueInput | InputJsonValue
    proofOfBilling: JsonNullValueInput | InputJsonValue
    status?: $Enums.ApplicationStatus
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    approvedTerm?: number | null
    applicantNotes?: string | null
    adminNotes?: string | null
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancingApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    civilStatus?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    employmentStatus?: StringFieldUpdateOperationsInput | string
    monthlyIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    employer?: NullableStringFieldUpdateOperationsInput | string | null
    yearsEmployed?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleId?: StringFieldUpdateOperationsInput | string
    vehicleName?: StringFieldUpdateOperationsInput | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loanTerm?: IntFieldUpdateOperationsInput | number
    estimatedMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validIds?: JsonNullValueInput | InputJsonValue
    proofOfIncome?: JsonNullValueInput | InputJsonValue
    proofOfBilling?: JsonNullValueInput | InputJsonValue
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedTerm?: NullableIntFieldUpdateOperationsInput | number | null
    applicantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancingApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    civilStatus?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    employmentStatus?: StringFieldUpdateOperationsInput | string
    monthlyIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    employer?: NullableStringFieldUpdateOperationsInput | string | null
    yearsEmployed?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleId?: StringFieldUpdateOperationsInput | string
    vehicleName?: StringFieldUpdateOperationsInput | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loanTerm?: IntFieldUpdateOperationsInput | number
    estimatedMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validIds?: JsonNullValueInput | InputJsonValue
    proofOfIncome?: JsonNullValueInput | InputJsonValue
    proofOfBilling?: JsonNullValueInput | InputJsonValue
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    approvedTerm?: NullableIntFieldUpdateOperationsInput | number | null
    applicantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeInCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    brand: string
    model: string
    year: number
    variant?: string | null
    mileage: number
    transmission: string
    fuelType: string
    color?: string | null
    condition: string
    hasAccidents?: boolean
    serviceHistory?: boolean
    images?: TradeInCreateimagesInput | string[]
    description?: string | null
    expectedPrice?: Decimal | DecimalJsLike | number | string | null
    offeredPrice?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.TradeInStatus
    applicantNotes?: string | null
    evaluationNotes?: string | null
    evaluatedAt?: Date | string | null
    offerMadeAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeInUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    brand: string
    model: string
    year: number
    variant?: string | null
    mileage: number
    transmission: string
    fuelType: string
    color?: string | null
    condition: string
    hasAccidents?: boolean
    serviceHistory?: boolean
    images?: TradeInCreateimagesInput | string[]
    description?: string | null
    expectedPrice?: Decimal | DecimalJsLike | number | string | null
    offeredPrice?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.TradeInStatus
    applicantNotes?: string | null
    evaluationNotes?: string | null
    evaluatedAt?: Date | string | null
    offerMadeAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeInUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    mileage?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
    hasAccidents?: BoolFieldUpdateOperationsInput | boolean
    serviceHistory?: BoolFieldUpdateOperationsInput | boolean
    images?: TradeInUpdateimagesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expectedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    offeredPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumTradeInStatusFieldUpdateOperationsInput | $Enums.TradeInStatus
    applicantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    evaluatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerMadeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeInUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    mileage?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
    hasAccidents?: BoolFieldUpdateOperationsInput | boolean
    serviceHistory?: BoolFieldUpdateOperationsInput | boolean
    images?: TradeInUpdateimagesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expectedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    offeredPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumTradeInStatusFieldUpdateOperationsInput | $Enums.TradeInStatus
    applicantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    evaluatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerMadeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeInCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    brand: string
    model: string
    year: number
    variant?: string | null
    mileage: number
    transmission: string
    fuelType: string
    color?: string | null
    condition: string
    hasAccidents?: boolean
    serviceHistory?: boolean
    images?: TradeInCreateimagesInput | string[]
    description?: string | null
    expectedPrice?: Decimal | DecimalJsLike | number | string | null
    offeredPrice?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.TradeInStatus
    applicantNotes?: string | null
    evaluationNotes?: string | null
    evaluatedAt?: Date | string | null
    offerMadeAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TradeInUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    mileage?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
    hasAccidents?: BoolFieldUpdateOperationsInput | boolean
    serviceHistory?: BoolFieldUpdateOperationsInput | boolean
    images?: TradeInUpdateimagesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expectedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    offeredPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumTradeInStatusFieldUpdateOperationsInput | $Enums.TradeInStatus
    applicantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    evaluatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerMadeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeInUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    mileage?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
    hasAccidents?: BoolFieldUpdateOperationsInput | boolean
    serviceHistory?: BoolFieldUpdateOperationsInput | boolean
    images?: TradeInUpdateimagesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expectedPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    offeredPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumTradeInStatusFieldUpdateOperationsInput | $Enums.TradeInStatus
    applicantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    evaluatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerMadeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionCreateInput = {
    id?: string
    title: string
    slug: string
    description: string
    bannerImage: string
    thumbnailImage?: string | null
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    vehicleIds?: PromotionCreatevehicleIdsInput | string[]
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    terms?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    description: string
    bannerImage: string
    thumbnailImage?: string | null
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    vehicleIds?: PromotionCreatevehicleIdsInput | string[]
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    terms?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bannerImage?: StringFieldUpdateOperationsInput | string
    thumbnailImage?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vehicleIds?: PromotionUpdatevehicleIdsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bannerImage?: StringFieldUpdateOperationsInput | string
    thumbnailImage?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vehicleIds?: PromotionUpdatevehicleIdsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionCreateManyInput = {
    id?: string
    title: string
    slug: string
    description: string
    bannerImage: string
    thumbnailImage?: string | null
    discountType: string
    discountValue: Decimal | DecimalJsLike | number | string
    vehicleIds?: PromotionCreatevehicleIdsInput | string[]
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    terms?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bannerImage?: StringFieldUpdateOperationsInput | string
    thumbnailImage?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vehicleIds?: PromotionUpdatevehicleIdsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bannerImage?: StringFieldUpdateOperationsInput | string
    thumbnailImage?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vehicleIds?: PromotionUpdatevehicleIdsInput | string[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    link?: string | null
    icon?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    link?: string | null
    icon?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    link?: string | null
    icon?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BranchListRelationFilter = {
    every?: BranchWhereInput
    some?: BranchWhereInput
    none?: BranchWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DealershipCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealershipMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealershipMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DealershipRelationFilter = {
    is?: DealershipWhereInput
    isNot?: DealershipWhereInput
  }

  export type BranchInventoryListRelationFilter = {
    every?: BranchInventoryWhereInput
    some?: BranchInventoryWhereInput
    none?: BranchInventoryWhereInput
  }

  export type BranchInventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    dealershipId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    dealershipId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    dealershipId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BranchRelationFilter = {
    is?: BranchWhereInput
    isNot?: BranchWhereInput
  }

  export type VehicleRelationFilter = {
    is?: VehicleWhereInput
    isNot?: VehicleWhereInput
  }

  export type BranchInventoryCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    vehicleId?: SortOrder
    stock?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchInventoryAvgOrderByAggregateInput = {
    stock?: SortOrder
    price?: SortOrder
  }

  export type BranchInventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    vehicleId?: SortOrder
    stock?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchInventoryMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    vehicleId?: SortOrder
    stock?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchInventorySumOrderByAggregateInput = {
    stock?: SortOrder
    price?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type LoanRateCountOrderByAggregateInput = {
    id?: SortOrder
    bankName?: SortOrder
    annualRate?: SortOrder
    minTermMonths?: SortOrder
    maxTermMonths?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanRateAvgOrderByAggregateInput = {
    annualRate?: SortOrder
    minTermMonths?: SortOrder
    maxTermMonths?: SortOrder
  }

  export type LoanRateMaxOrderByAggregateInput = {
    id?: SortOrder
    bankName?: SortOrder
    annualRate?: SortOrder
    minTermMonths?: SortOrder
    maxTermMonths?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanRateMinOrderByAggregateInput = {
    id?: SortOrder
    bankName?: SortOrder
    annualRate?: SortOrder
    minTermMonths?: SortOrder
    maxTermMonths?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanRateSumOrderByAggregateInput = {
    annualRate?: SortOrder
    minTermMonths?: SortOrder
    maxTermMonths?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumVehicleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleStatus | EnumVehicleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleStatus[] | ListEnumVehicleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleStatus[] | ListEnumVehicleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleStatusFilter<$PrismaModel> | $Enums.VehicleStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type VehicleImageListRelationFilter = {
    every?: VehicleImageWhereInput
    some?: VehicleImageWhereInput
    none?: VehicleImageWhereInput
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type InquiryListRelationFilter = {
    every?: InquiryWhereInput
    some?: InquiryWhereInput
    none?: InquiryWhereInput
  }

  export type TestDriveListRelationFilter = {
    every?: TestDriveWhereInput
    some?: TestDriveWhereInput
    none?: TestDriveWhereInput
  }

  export type SavedVehicleListRelationFilter = {
    every?: SavedVehicleWhereInput
    some?: SavedVehicleWhereInput
    none?: SavedVehicleWhereInput
  }

  export type ConfigurationListRelationFilter = {
    every?: ConfigurationWhereInput
    some?: ConfigurationWhereInput
    none?: ConfigurationWhereInput
  }

  export type VehicleImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InquiryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestDriveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SavedVehicleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConfigurationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    variant?: SortOrder
    cashPrice?: SortOrder
    downPayment?: SortOrder
    monthlyPayment?: SortOrder
    leaseTerm?: SortOrder
    transmission?: SortOrder
    fuelType?: SortOrder
    engineSize?: SortOrder
    horsepower?: SortOrder
    seatingCapacity?: SortOrder
    cargoSpace?: SortOrder
    features?: SortOrder
    specifications?: SortOrder
    description?: SortOrder
    videos?: SortOrder
    model3dUrl?: SortOrder
    thumbnailUrl?: SortOrder
    status?: SortOrder
    availability?: SortOrder
    featured?: SortOrder
    stockCount?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleAvgOrderByAggregateInput = {
    year?: SortOrder
    cashPrice?: SortOrder
    downPayment?: SortOrder
    monthlyPayment?: SortOrder
    leaseTerm?: SortOrder
    horsepower?: SortOrder
    seatingCapacity?: SortOrder
    stockCount?: SortOrder
  }

  export type VehicleMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    variant?: SortOrder
    cashPrice?: SortOrder
    downPayment?: SortOrder
    monthlyPayment?: SortOrder
    leaseTerm?: SortOrder
    transmission?: SortOrder
    fuelType?: SortOrder
    engineSize?: SortOrder
    horsepower?: SortOrder
    seatingCapacity?: SortOrder
    cargoSpace?: SortOrder
    description?: SortOrder
    model3dUrl?: SortOrder
    thumbnailUrl?: SortOrder
    status?: SortOrder
    availability?: SortOrder
    featured?: SortOrder
    stockCount?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    variant?: SortOrder
    cashPrice?: SortOrder
    downPayment?: SortOrder
    monthlyPayment?: SortOrder
    leaseTerm?: SortOrder
    transmission?: SortOrder
    fuelType?: SortOrder
    engineSize?: SortOrder
    horsepower?: SortOrder
    seatingCapacity?: SortOrder
    cargoSpace?: SortOrder
    description?: SortOrder
    model3dUrl?: SortOrder
    thumbnailUrl?: SortOrder
    status?: SortOrder
    availability?: SortOrder
    featured?: SortOrder
    stockCount?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleSumOrderByAggregateInput = {
    year?: SortOrder
    cashPrice?: SortOrder
    downPayment?: SortOrder
    monthlyPayment?: SortOrder
    leaseTerm?: SortOrder
    horsepower?: SortOrder
    seatingCapacity?: SortOrder
    stockCount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumVehicleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleStatus | EnumVehicleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleStatus[] | ListEnumVehicleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleStatus[] | ListEnumVehicleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleStatusWithAggregatesFilter<$PrismaModel> | $Enums.VehicleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVehicleStatusFilter<$PrismaModel>
    _max?: NestedEnumVehicleStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type VehicleImageCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    type?: SortOrder
    order?: SortOrder
    vehicleId?: SortOrder
  }

  export type VehicleImageAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type VehicleImageMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    type?: SortOrder
    order?: SortOrder
    vehicleId?: SortOrder
  }

  export type VehicleImageMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    type?: SortOrder
    order?: SortOrder
    vehicleId?: SortOrder
  }

  export type VehicleImageSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type VehicleListRelationFilter = {
    every?: VehicleWhereInput
    some?: VehicleWhereInput
    none?: VehicleWhereInput
  }

  export type VehicleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    order?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    clerkId?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    clerkId?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    clerkId?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SavedVehicleUserIdVehicleIdCompoundUniqueInput = {
    userId: string
    vehicleId: string
  }

  export type SavedVehicleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type SavedVehicleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type SavedVehicleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    color?: SortOrder
    colorHex?: SortOrder
    wheels?: SortOrder
    interior?: SortOrder
    packages?: SortOrder
    accessories?: SortOrder
    totalPrice?: SortOrder
    shared?: SortOrder
    shareToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigurationAvgOrderByAggregateInput = {
    totalPrice?: SortOrder
  }

  export type ConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    color?: SortOrder
    colorHex?: SortOrder
    wheels?: SortOrder
    interior?: SortOrder
    totalPrice?: SortOrder
    shared?: SortOrder
    shareToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    color?: SortOrder
    colorHex?: SortOrder
    wheels?: SortOrder
    interior?: SortOrder
    totalPrice?: SortOrder
    shared?: SortOrder
    shareToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigurationSumOrderByAggregateInput = {
    totalPrice?: SortOrder
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TestDriveCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    preferredDate?: SortOrder
    preferredTime?: SortOrder
    location?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    adminNotes?: SortOrder
    confirmedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestDriveMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    preferredDate?: SortOrder
    preferredTime?: SortOrder
    location?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    adminNotes?: SortOrder
    confirmedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestDriveMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    preferredDate?: SortOrder
    preferredTime?: SortOrder
    location?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    adminNotes?: SortOrder
    confirmedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumInquiryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryType | EnumInquiryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryType[] | ListEnumInquiryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryType[] | ListEnumInquiryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryTypeFilter<$PrismaModel> | $Enums.InquiryType
  }

  export type EnumInquiryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryStatus | EnumInquiryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryStatusFilter<$PrismaModel> | $Enums.InquiryStatus
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type VehicleNullableRelationFilter = {
    is?: VehicleWhereInput | null
    isNot?: VehicleWhereInput | null
  }

  export type InquiryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    type?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    response?: SortOrder
    respondedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InquiryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    type?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    response?: SortOrder
    respondedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InquiryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleId?: SortOrder
    type?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    response?: SortOrder
    respondedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInquiryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryType | EnumInquiryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryType[] | ListEnumInquiryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryType[] | ListEnumInquiryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryTypeWithAggregatesFilter<$PrismaModel> | $Enums.InquiryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInquiryTypeFilter<$PrismaModel>
    _max?: NestedEnumInquiryTypeFilter<$PrismaModel>
  }

  export type EnumInquiryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryStatus | EnumInquiryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryStatusWithAggregatesFilter<$PrismaModel> | $Enums.InquiryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInquiryStatusFilter<$PrismaModel>
    _max?: NestedEnumInquiryStatusFilter<$PrismaModel>
  }

  export type EnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type FinancingApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    birthDate?: SortOrder
    civilStatus?: SortOrder
    address?: SortOrder
    employmentStatus?: SortOrder
    monthlyIncome?: SortOrder
    employer?: SortOrder
    yearsEmployed?: SortOrder
    vehicleId?: SortOrder
    vehicleName?: SortOrder
    downPayment?: SortOrder
    loanTerm?: SortOrder
    estimatedMonthly?: SortOrder
    validIds?: SortOrder
    proofOfIncome?: SortOrder
    proofOfBilling?: SortOrder
    status?: SortOrder
    approvedAmount?: SortOrder
    approvedTerm?: SortOrder
    applicantNotes?: SortOrder
    adminNotes?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancingApplicationAvgOrderByAggregateInput = {
    monthlyIncome?: SortOrder
    yearsEmployed?: SortOrder
    downPayment?: SortOrder
    loanTerm?: SortOrder
    estimatedMonthly?: SortOrder
    approvedAmount?: SortOrder
    approvedTerm?: SortOrder
  }

  export type FinancingApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    birthDate?: SortOrder
    civilStatus?: SortOrder
    address?: SortOrder
    employmentStatus?: SortOrder
    monthlyIncome?: SortOrder
    employer?: SortOrder
    yearsEmployed?: SortOrder
    vehicleId?: SortOrder
    vehicleName?: SortOrder
    downPayment?: SortOrder
    loanTerm?: SortOrder
    estimatedMonthly?: SortOrder
    status?: SortOrder
    approvedAmount?: SortOrder
    approvedTerm?: SortOrder
    applicantNotes?: SortOrder
    adminNotes?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancingApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    birthDate?: SortOrder
    civilStatus?: SortOrder
    address?: SortOrder
    employmentStatus?: SortOrder
    monthlyIncome?: SortOrder
    employer?: SortOrder
    yearsEmployed?: SortOrder
    vehicleId?: SortOrder
    vehicleName?: SortOrder
    downPayment?: SortOrder
    loanTerm?: SortOrder
    estimatedMonthly?: SortOrder
    status?: SortOrder
    approvedAmount?: SortOrder
    approvedTerm?: SortOrder
    applicantNotes?: SortOrder
    adminNotes?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancingApplicationSumOrderByAggregateInput = {
    monthlyIncome?: SortOrder
    yearsEmployed?: SortOrder
    downPayment?: SortOrder
    loanTerm?: SortOrder
    estimatedMonthly?: SortOrder
    approvedAmount?: SortOrder
    approvedTerm?: SortOrder
  }

  export type EnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumTradeInStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeInStatus | EnumTradeInStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TradeInStatus[] | ListEnumTradeInStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeInStatus[] | ListEnumTradeInStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeInStatusFilter<$PrismaModel> | $Enums.TradeInStatus
  }

  export type TradeInCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    variant?: SortOrder
    mileage?: SortOrder
    transmission?: SortOrder
    fuelType?: SortOrder
    color?: SortOrder
    condition?: SortOrder
    hasAccidents?: SortOrder
    serviceHistory?: SortOrder
    images?: SortOrder
    description?: SortOrder
    expectedPrice?: SortOrder
    offeredPrice?: SortOrder
    status?: SortOrder
    applicantNotes?: SortOrder
    evaluationNotes?: SortOrder
    evaluatedAt?: SortOrder
    offerMadeAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradeInAvgOrderByAggregateInput = {
    year?: SortOrder
    mileage?: SortOrder
    expectedPrice?: SortOrder
    offeredPrice?: SortOrder
  }

  export type TradeInMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    variant?: SortOrder
    mileage?: SortOrder
    transmission?: SortOrder
    fuelType?: SortOrder
    color?: SortOrder
    condition?: SortOrder
    hasAccidents?: SortOrder
    serviceHistory?: SortOrder
    description?: SortOrder
    expectedPrice?: SortOrder
    offeredPrice?: SortOrder
    status?: SortOrder
    applicantNotes?: SortOrder
    evaluationNotes?: SortOrder
    evaluatedAt?: SortOrder
    offerMadeAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradeInMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    variant?: SortOrder
    mileage?: SortOrder
    transmission?: SortOrder
    fuelType?: SortOrder
    color?: SortOrder
    condition?: SortOrder
    hasAccidents?: SortOrder
    serviceHistory?: SortOrder
    description?: SortOrder
    expectedPrice?: SortOrder
    offeredPrice?: SortOrder
    status?: SortOrder
    applicantNotes?: SortOrder
    evaluationNotes?: SortOrder
    evaluatedAt?: SortOrder
    offerMadeAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TradeInSumOrderByAggregateInput = {
    year?: SortOrder
    mileage?: SortOrder
    expectedPrice?: SortOrder
    offeredPrice?: SortOrder
  }

  export type EnumTradeInStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeInStatus | EnumTradeInStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TradeInStatus[] | ListEnumTradeInStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeInStatus[] | ListEnumTradeInStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeInStatusWithAggregatesFilter<$PrismaModel> | $Enums.TradeInStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTradeInStatusFilter<$PrismaModel>
    _max?: NestedEnumTradeInStatusFilter<$PrismaModel>
  }

  export type PromotionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    bannerImage?: SortOrder
    thumbnailImage?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    vehicleIds?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    terms?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionAvgOrderByAggregateInput = {
    discountValue?: SortOrder
  }

  export type PromotionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    bannerImage?: SortOrder
    thumbnailImage?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    terms?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    bannerImage?: SortOrder
    thumbnailImage?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    terms?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionSumOrderByAggregateInput = {
    discountValue?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type BranchCreateNestedManyWithoutDealershipInput = {
    create?: XOR<BranchCreateWithoutDealershipInput, BranchUncheckedCreateWithoutDealershipInput> | BranchCreateWithoutDealershipInput[] | BranchUncheckedCreateWithoutDealershipInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutDealershipInput | BranchCreateOrConnectWithoutDealershipInput[]
    createMany?: BranchCreateManyDealershipInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type BranchUncheckedCreateNestedManyWithoutDealershipInput = {
    create?: XOR<BranchCreateWithoutDealershipInput, BranchUncheckedCreateWithoutDealershipInput> | BranchCreateWithoutDealershipInput[] | BranchUncheckedCreateWithoutDealershipInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutDealershipInput | BranchCreateOrConnectWithoutDealershipInput[]
    createMany?: BranchCreateManyDealershipInputEnvelope
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BranchUpdateManyWithoutDealershipNestedInput = {
    create?: XOR<BranchCreateWithoutDealershipInput, BranchUncheckedCreateWithoutDealershipInput> | BranchCreateWithoutDealershipInput[] | BranchUncheckedCreateWithoutDealershipInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutDealershipInput | BranchCreateOrConnectWithoutDealershipInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutDealershipInput | BranchUpsertWithWhereUniqueWithoutDealershipInput[]
    createMany?: BranchCreateManyDealershipInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutDealershipInput | BranchUpdateWithWhereUniqueWithoutDealershipInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutDealershipInput | BranchUpdateManyWithWhereWithoutDealershipInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type BranchUncheckedUpdateManyWithoutDealershipNestedInput = {
    create?: XOR<BranchCreateWithoutDealershipInput, BranchUncheckedCreateWithoutDealershipInput> | BranchCreateWithoutDealershipInput[] | BranchUncheckedCreateWithoutDealershipInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutDealershipInput | BranchCreateOrConnectWithoutDealershipInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutDealershipInput | BranchUpsertWithWhereUniqueWithoutDealershipInput[]
    createMany?: BranchCreateManyDealershipInputEnvelope
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutDealershipInput | BranchUpdateWithWhereUniqueWithoutDealershipInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutDealershipInput | BranchUpdateManyWithWhereWithoutDealershipInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type DealershipCreateNestedOneWithoutBranchesInput = {
    create?: XOR<DealershipCreateWithoutBranchesInput, DealershipUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: DealershipCreateOrConnectWithoutBranchesInput
    connect?: DealershipWhereUniqueInput
  }

  export type BranchInventoryCreateNestedManyWithoutBranchInput = {
    create?: XOR<BranchInventoryCreateWithoutBranchInput, BranchInventoryUncheckedCreateWithoutBranchInput> | BranchInventoryCreateWithoutBranchInput[] | BranchInventoryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BranchInventoryCreateOrConnectWithoutBranchInput | BranchInventoryCreateOrConnectWithoutBranchInput[]
    createMany?: BranchInventoryCreateManyBranchInputEnvelope
    connect?: BranchInventoryWhereUniqueInput | BranchInventoryWhereUniqueInput[]
  }

  export type BranchInventoryUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<BranchInventoryCreateWithoutBranchInput, BranchInventoryUncheckedCreateWithoutBranchInput> | BranchInventoryCreateWithoutBranchInput[] | BranchInventoryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BranchInventoryCreateOrConnectWithoutBranchInput | BranchInventoryCreateOrConnectWithoutBranchInput[]
    createMany?: BranchInventoryCreateManyBranchInputEnvelope
    connect?: BranchInventoryWhereUniqueInput | BranchInventoryWhereUniqueInput[]
  }

  export type DealershipUpdateOneRequiredWithoutBranchesNestedInput = {
    create?: XOR<DealershipCreateWithoutBranchesInput, DealershipUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: DealershipCreateOrConnectWithoutBranchesInput
    upsert?: DealershipUpsertWithoutBranchesInput
    connect?: DealershipWhereUniqueInput
    update?: XOR<XOR<DealershipUpdateToOneWithWhereWithoutBranchesInput, DealershipUpdateWithoutBranchesInput>, DealershipUncheckedUpdateWithoutBranchesInput>
  }

  export type BranchInventoryUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BranchInventoryCreateWithoutBranchInput, BranchInventoryUncheckedCreateWithoutBranchInput> | BranchInventoryCreateWithoutBranchInput[] | BranchInventoryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BranchInventoryCreateOrConnectWithoutBranchInput | BranchInventoryCreateOrConnectWithoutBranchInput[]
    upsert?: BranchInventoryUpsertWithWhereUniqueWithoutBranchInput | BranchInventoryUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BranchInventoryCreateManyBranchInputEnvelope
    set?: BranchInventoryWhereUniqueInput | BranchInventoryWhereUniqueInput[]
    disconnect?: BranchInventoryWhereUniqueInput | BranchInventoryWhereUniqueInput[]
    delete?: BranchInventoryWhereUniqueInput | BranchInventoryWhereUniqueInput[]
    connect?: BranchInventoryWhereUniqueInput | BranchInventoryWhereUniqueInput[]
    update?: BranchInventoryUpdateWithWhereUniqueWithoutBranchInput | BranchInventoryUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BranchInventoryUpdateManyWithWhereWithoutBranchInput | BranchInventoryUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BranchInventoryScalarWhereInput | BranchInventoryScalarWhereInput[]
  }

  export type BranchInventoryUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BranchInventoryCreateWithoutBranchInput, BranchInventoryUncheckedCreateWithoutBranchInput> | BranchInventoryCreateWithoutBranchInput[] | BranchInventoryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BranchInventoryCreateOrConnectWithoutBranchInput | BranchInventoryCreateOrConnectWithoutBranchInput[]
    upsert?: BranchInventoryUpsertWithWhereUniqueWithoutBranchInput | BranchInventoryUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BranchInventoryCreateManyBranchInputEnvelope
    set?: BranchInventoryWhereUniqueInput | BranchInventoryWhereUniqueInput[]
    disconnect?: BranchInventoryWhereUniqueInput | BranchInventoryWhereUniqueInput[]
    delete?: BranchInventoryWhereUniqueInput | BranchInventoryWhereUniqueInput[]
    connect?: BranchInventoryWhereUniqueInput | BranchInventoryWhereUniqueInput[]
    update?: BranchInventoryUpdateWithWhereUniqueWithoutBranchInput | BranchInventoryUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BranchInventoryUpdateManyWithWhereWithoutBranchInput | BranchInventoryUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BranchInventoryScalarWhereInput | BranchInventoryScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutInventoryInput = {
    create?: XOR<BranchCreateWithoutInventoryInput, BranchUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: BranchCreateOrConnectWithoutInventoryInput
    connect?: BranchWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutBranchInventoryInput = {
    create?: XOR<VehicleCreateWithoutBranchInventoryInput, VehicleUncheckedCreateWithoutBranchInventoryInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutBranchInventoryInput
    connect?: VehicleWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BranchUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<BranchCreateWithoutInventoryInput, BranchUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: BranchCreateOrConnectWithoutInventoryInput
    upsert?: BranchUpsertWithoutInventoryInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutInventoryInput, BranchUpdateWithoutInventoryInput>, BranchUncheckedUpdateWithoutInventoryInput>
  }

  export type VehicleUpdateOneRequiredWithoutBranchInventoryNestedInput = {
    create?: XOR<VehicleCreateWithoutBranchInventoryInput, VehicleUncheckedCreateWithoutBranchInventoryInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutBranchInventoryInput
    upsert?: VehicleUpsertWithoutBranchInventoryInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutBranchInventoryInput, VehicleUpdateWithoutBranchInventoryInput>, VehicleUncheckedUpdateWithoutBranchInventoryInput>
  }

  export type VehicleCreatevideosInput = {
    set: string[]
  }

  export type VehicleImageCreateNestedManyWithoutVehicleInput = {
    create?: XOR<VehicleImageCreateWithoutVehicleInput, VehicleImageUncheckedCreateWithoutVehicleInput> | VehicleImageCreateWithoutVehicleInput[] | VehicleImageUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: VehicleImageCreateOrConnectWithoutVehicleInput | VehicleImageCreateOrConnectWithoutVehicleInput[]
    createMany?: VehicleImageCreateManyVehicleInputEnvelope
    connect?: VehicleImageWhereUniqueInput | VehicleImageWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutVehiclesInput = {
    create?: XOR<CategoryCreateWithoutVehiclesInput, CategoryUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutVehiclesInput
    connect?: CategoryWhereUniqueInput
  }

  export type InquiryCreateNestedManyWithoutVehicleInput = {
    create?: XOR<InquiryCreateWithoutVehicleInput, InquiryUncheckedCreateWithoutVehicleInput> | InquiryCreateWithoutVehicleInput[] | InquiryUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutVehicleInput | InquiryCreateOrConnectWithoutVehicleInput[]
    createMany?: InquiryCreateManyVehicleInputEnvelope
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
  }

  export type TestDriveCreateNestedManyWithoutVehicleInput = {
    create?: XOR<TestDriveCreateWithoutVehicleInput, TestDriveUncheckedCreateWithoutVehicleInput> | TestDriveCreateWithoutVehicleInput[] | TestDriveUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: TestDriveCreateOrConnectWithoutVehicleInput | TestDriveCreateOrConnectWithoutVehicleInput[]
    createMany?: TestDriveCreateManyVehicleInputEnvelope
    connect?: TestDriveWhereUniqueInput | TestDriveWhereUniqueInput[]
  }

  export type SavedVehicleCreateNestedManyWithoutVehicleInput = {
    create?: XOR<SavedVehicleCreateWithoutVehicleInput, SavedVehicleUncheckedCreateWithoutVehicleInput> | SavedVehicleCreateWithoutVehicleInput[] | SavedVehicleUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: SavedVehicleCreateOrConnectWithoutVehicleInput | SavedVehicleCreateOrConnectWithoutVehicleInput[]
    createMany?: SavedVehicleCreateManyVehicleInputEnvelope
    connect?: SavedVehicleWhereUniqueInput | SavedVehicleWhereUniqueInput[]
  }

  export type ConfigurationCreateNestedManyWithoutVehicleInput = {
    create?: XOR<ConfigurationCreateWithoutVehicleInput, ConfigurationUncheckedCreateWithoutVehicleInput> | ConfigurationCreateWithoutVehicleInput[] | ConfigurationUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: ConfigurationCreateOrConnectWithoutVehicleInput | ConfigurationCreateOrConnectWithoutVehicleInput[]
    createMany?: ConfigurationCreateManyVehicleInputEnvelope
    connect?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
  }

  export type BranchInventoryCreateNestedManyWithoutVehicleInput = {
    create?: XOR<BranchInventoryCreateWithoutVehicleInput, BranchInventoryUncheckedCreateWithoutVehicleInput> | BranchInventoryCreateWithoutVehicleInput[] | BranchInventoryUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: BranchInventoryCreateOrConnectWithoutVehicleInput | BranchInventoryCreateOrConnectWithoutVehicleInput[]
    createMany?: BranchInventoryCreateManyVehicleInputEnvelope
    connect?: BranchInventoryWhereUniqueInput | BranchInventoryWhereUniqueInput[]
  }

  export type VehicleImageUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<VehicleImageCreateWithoutVehicleInput, VehicleImageUncheckedCreateWithoutVehicleInput> | VehicleImageCreateWithoutVehicleInput[] | VehicleImageUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: VehicleImageCreateOrConnectWithoutVehicleInput | VehicleImageCreateOrConnectWithoutVehicleInput[]
    createMany?: VehicleImageCreateManyVehicleInputEnvelope
    connect?: VehicleImageWhereUniqueInput | VehicleImageWhereUniqueInput[]
  }

  export type InquiryUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<InquiryCreateWithoutVehicleInput, InquiryUncheckedCreateWithoutVehicleInput> | InquiryCreateWithoutVehicleInput[] | InquiryUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutVehicleInput | InquiryCreateOrConnectWithoutVehicleInput[]
    createMany?: InquiryCreateManyVehicleInputEnvelope
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
  }

  export type TestDriveUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<TestDriveCreateWithoutVehicleInput, TestDriveUncheckedCreateWithoutVehicleInput> | TestDriveCreateWithoutVehicleInput[] | TestDriveUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: TestDriveCreateOrConnectWithoutVehicleInput | TestDriveCreateOrConnectWithoutVehicleInput[]
    createMany?: TestDriveCreateManyVehicleInputEnvelope
    connect?: TestDriveWhereUniqueInput | TestDriveWhereUniqueInput[]
  }

  export type SavedVehicleUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<SavedVehicleCreateWithoutVehicleInput, SavedVehicleUncheckedCreateWithoutVehicleInput> | SavedVehicleCreateWithoutVehicleInput[] | SavedVehicleUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: SavedVehicleCreateOrConnectWithoutVehicleInput | SavedVehicleCreateOrConnectWithoutVehicleInput[]
    createMany?: SavedVehicleCreateManyVehicleInputEnvelope
    connect?: SavedVehicleWhereUniqueInput | SavedVehicleWhereUniqueInput[]
  }

  export type ConfigurationUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<ConfigurationCreateWithoutVehicleInput, ConfigurationUncheckedCreateWithoutVehicleInput> | ConfigurationCreateWithoutVehicleInput[] | ConfigurationUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: ConfigurationCreateOrConnectWithoutVehicleInput | ConfigurationCreateOrConnectWithoutVehicleInput[]
    createMany?: ConfigurationCreateManyVehicleInputEnvelope
    connect?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
  }

  export type BranchInventoryUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<BranchInventoryCreateWithoutVehicleInput, BranchInventoryUncheckedCreateWithoutVehicleInput> | BranchInventoryCreateWithoutVehicleInput[] | BranchInventoryUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: BranchInventoryCreateOrConnectWithoutVehicleInput | BranchInventoryCreateOrConnectWithoutVehicleInput[]
    createMany?: BranchInventoryCreateManyVehicleInputEnvelope
    connect?: BranchInventoryWhereUniqueInput | BranchInventoryWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VehicleUpdatevideosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumVehicleStatusFieldUpdateOperationsInput = {
    set?: $Enums.VehicleStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type VehicleImageUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<VehicleImageCreateWithoutVehicleInput, VehicleImageUncheckedCreateWithoutVehicleInput> | VehicleImageCreateWithoutVehicleInput[] | VehicleImageUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: VehicleImageCreateOrConnectWithoutVehicleInput | VehicleImageCreateOrConnectWithoutVehicleInput[]
    upsert?: VehicleImageUpsertWithWhereUniqueWithoutVehicleInput | VehicleImageUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: VehicleImageCreateManyVehicleInputEnvelope
    set?: VehicleImageWhereUniqueInput | VehicleImageWhereUniqueInput[]
    disconnect?: VehicleImageWhereUniqueInput | VehicleImageWhereUniqueInput[]
    delete?: VehicleImageWhereUniqueInput | VehicleImageWhereUniqueInput[]
    connect?: VehicleImageWhereUniqueInput | VehicleImageWhereUniqueInput[]
    update?: VehicleImageUpdateWithWhereUniqueWithoutVehicleInput | VehicleImageUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: VehicleImageUpdateManyWithWhereWithoutVehicleInput | VehicleImageUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: VehicleImageScalarWhereInput | VehicleImageScalarWhereInput[]
  }

  export type CategoryUpdateOneRequiredWithoutVehiclesNestedInput = {
    create?: XOR<CategoryCreateWithoutVehiclesInput, CategoryUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutVehiclesInput
    upsert?: CategoryUpsertWithoutVehiclesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutVehiclesInput, CategoryUpdateWithoutVehiclesInput>, CategoryUncheckedUpdateWithoutVehiclesInput>
  }

  export type InquiryUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<InquiryCreateWithoutVehicleInput, InquiryUncheckedCreateWithoutVehicleInput> | InquiryCreateWithoutVehicleInput[] | InquiryUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutVehicleInput | InquiryCreateOrConnectWithoutVehicleInput[]
    upsert?: InquiryUpsertWithWhereUniqueWithoutVehicleInput | InquiryUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: InquiryCreateManyVehicleInputEnvelope
    set?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    disconnect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    delete?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    update?: InquiryUpdateWithWhereUniqueWithoutVehicleInput | InquiryUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: InquiryUpdateManyWithWhereWithoutVehicleInput | InquiryUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
  }

  export type TestDriveUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<TestDriveCreateWithoutVehicleInput, TestDriveUncheckedCreateWithoutVehicleInput> | TestDriveCreateWithoutVehicleInput[] | TestDriveUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: TestDriveCreateOrConnectWithoutVehicleInput | TestDriveCreateOrConnectWithoutVehicleInput[]
    upsert?: TestDriveUpsertWithWhereUniqueWithoutVehicleInput | TestDriveUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: TestDriveCreateManyVehicleInputEnvelope
    set?: TestDriveWhereUniqueInput | TestDriveWhereUniqueInput[]
    disconnect?: TestDriveWhereUniqueInput | TestDriveWhereUniqueInput[]
    delete?: TestDriveWhereUniqueInput | TestDriveWhereUniqueInput[]
    connect?: TestDriveWhereUniqueInput | TestDriveWhereUniqueInput[]
    update?: TestDriveUpdateWithWhereUniqueWithoutVehicleInput | TestDriveUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: TestDriveUpdateManyWithWhereWithoutVehicleInput | TestDriveUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: TestDriveScalarWhereInput | TestDriveScalarWhereInput[]
  }

  export type SavedVehicleUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<SavedVehicleCreateWithoutVehicleInput, SavedVehicleUncheckedCreateWithoutVehicleInput> | SavedVehicleCreateWithoutVehicleInput[] | SavedVehicleUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: SavedVehicleCreateOrConnectWithoutVehicleInput | SavedVehicleCreateOrConnectWithoutVehicleInput[]
    upsert?: SavedVehicleUpsertWithWhereUniqueWithoutVehicleInput | SavedVehicleUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: SavedVehicleCreateManyVehicleInputEnvelope
    set?: SavedVehicleWhereUniqueInput | SavedVehicleWhereUniqueInput[]
    disconnect?: SavedVehicleWhereUniqueInput | SavedVehicleWhereUniqueInput[]
    delete?: SavedVehicleWhereUniqueInput | SavedVehicleWhereUniqueInput[]
    connect?: SavedVehicleWhereUniqueInput | SavedVehicleWhereUniqueInput[]
    update?: SavedVehicleUpdateWithWhereUniqueWithoutVehicleInput | SavedVehicleUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: SavedVehicleUpdateManyWithWhereWithoutVehicleInput | SavedVehicleUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: SavedVehicleScalarWhereInput | SavedVehicleScalarWhereInput[]
  }

  export type ConfigurationUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<ConfigurationCreateWithoutVehicleInput, ConfigurationUncheckedCreateWithoutVehicleInput> | ConfigurationCreateWithoutVehicleInput[] | ConfigurationUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: ConfigurationCreateOrConnectWithoutVehicleInput | ConfigurationCreateOrConnectWithoutVehicleInput[]
    upsert?: ConfigurationUpsertWithWhereUniqueWithoutVehicleInput | ConfigurationUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: ConfigurationCreateManyVehicleInputEnvelope
    set?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    disconnect?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    delete?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    connect?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    update?: ConfigurationUpdateWithWhereUniqueWithoutVehicleInput | ConfigurationUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: ConfigurationUpdateManyWithWhereWithoutVehicleInput | ConfigurationUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: ConfigurationScalarWhereInput | ConfigurationScalarWhereInput[]
  }

  export type BranchInventoryUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<BranchInventoryCreateWithoutVehicleInput, BranchInventoryUncheckedCreateWithoutVehicleInput> | BranchInventoryCreateWithoutVehicleInput[] | BranchInventoryUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: BranchInventoryCreateOrConnectWithoutVehicleInput | BranchInventoryCreateOrConnectWithoutVehicleInput[]
    upsert?: BranchInventoryUpsertWithWhereUniqueWithoutVehicleInput | BranchInventoryUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: BranchInventoryCreateManyVehicleInputEnvelope
    set?: BranchInventoryWhereUniqueInput | BranchInventoryWhereUniqueInput[]
    disconnect?: BranchInventoryWhereUniqueInput | BranchInventoryWhereUniqueInput[]
    delete?: BranchInventoryWhereUniqueInput | BranchInventoryWhereUniqueInput[]
    connect?: BranchInventoryWhereUniqueInput | BranchInventoryWhereUniqueInput[]
    update?: BranchInventoryUpdateWithWhereUniqueWithoutVehicleInput | BranchInventoryUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: BranchInventoryUpdateManyWithWhereWithoutVehicleInput | BranchInventoryUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: BranchInventoryScalarWhereInput | BranchInventoryScalarWhereInput[]
  }

  export type VehicleImageUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<VehicleImageCreateWithoutVehicleInput, VehicleImageUncheckedCreateWithoutVehicleInput> | VehicleImageCreateWithoutVehicleInput[] | VehicleImageUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: VehicleImageCreateOrConnectWithoutVehicleInput | VehicleImageCreateOrConnectWithoutVehicleInput[]
    upsert?: VehicleImageUpsertWithWhereUniqueWithoutVehicleInput | VehicleImageUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: VehicleImageCreateManyVehicleInputEnvelope
    set?: VehicleImageWhereUniqueInput | VehicleImageWhereUniqueInput[]
    disconnect?: VehicleImageWhereUniqueInput | VehicleImageWhereUniqueInput[]
    delete?: VehicleImageWhereUniqueInput | VehicleImageWhereUniqueInput[]
    connect?: VehicleImageWhereUniqueInput | VehicleImageWhereUniqueInput[]
    update?: VehicleImageUpdateWithWhereUniqueWithoutVehicleInput | VehicleImageUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: VehicleImageUpdateManyWithWhereWithoutVehicleInput | VehicleImageUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: VehicleImageScalarWhereInput | VehicleImageScalarWhereInput[]
  }

  export type InquiryUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<InquiryCreateWithoutVehicleInput, InquiryUncheckedCreateWithoutVehicleInput> | InquiryCreateWithoutVehicleInput[] | InquiryUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutVehicleInput | InquiryCreateOrConnectWithoutVehicleInput[]
    upsert?: InquiryUpsertWithWhereUniqueWithoutVehicleInput | InquiryUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: InquiryCreateManyVehicleInputEnvelope
    set?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    disconnect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    delete?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    update?: InquiryUpdateWithWhereUniqueWithoutVehicleInput | InquiryUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: InquiryUpdateManyWithWhereWithoutVehicleInput | InquiryUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
  }

  export type TestDriveUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<TestDriveCreateWithoutVehicleInput, TestDriveUncheckedCreateWithoutVehicleInput> | TestDriveCreateWithoutVehicleInput[] | TestDriveUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: TestDriveCreateOrConnectWithoutVehicleInput | TestDriveCreateOrConnectWithoutVehicleInput[]
    upsert?: TestDriveUpsertWithWhereUniqueWithoutVehicleInput | TestDriveUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: TestDriveCreateManyVehicleInputEnvelope
    set?: TestDriveWhereUniqueInput | TestDriveWhereUniqueInput[]
    disconnect?: TestDriveWhereUniqueInput | TestDriveWhereUniqueInput[]
    delete?: TestDriveWhereUniqueInput | TestDriveWhereUniqueInput[]
    connect?: TestDriveWhereUniqueInput | TestDriveWhereUniqueInput[]
    update?: TestDriveUpdateWithWhereUniqueWithoutVehicleInput | TestDriveUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: TestDriveUpdateManyWithWhereWithoutVehicleInput | TestDriveUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: TestDriveScalarWhereInput | TestDriveScalarWhereInput[]
  }

  export type SavedVehicleUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<SavedVehicleCreateWithoutVehicleInput, SavedVehicleUncheckedCreateWithoutVehicleInput> | SavedVehicleCreateWithoutVehicleInput[] | SavedVehicleUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: SavedVehicleCreateOrConnectWithoutVehicleInput | SavedVehicleCreateOrConnectWithoutVehicleInput[]
    upsert?: SavedVehicleUpsertWithWhereUniqueWithoutVehicleInput | SavedVehicleUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: SavedVehicleCreateManyVehicleInputEnvelope
    set?: SavedVehicleWhereUniqueInput | SavedVehicleWhereUniqueInput[]
    disconnect?: SavedVehicleWhereUniqueInput | SavedVehicleWhereUniqueInput[]
    delete?: SavedVehicleWhereUniqueInput | SavedVehicleWhereUniqueInput[]
    connect?: SavedVehicleWhereUniqueInput | SavedVehicleWhereUniqueInput[]
    update?: SavedVehicleUpdateWithWhereUniqueWithoutVehicleInput | SavedVehicleUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: SavedVehicleUpdateManyWithWhereWithoutVehicleInput | SavedVehicleUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: SavedVehicleScalarWhereInput | SavedVehicleScalarWhereInput[]
  }

  export type ConfigurationUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<ConfigurationCreateWithoutVehicleInput, ConfigurationUncheckedCreateWithoutVehicleInput> | ConfigurationCreateWithoutVehicleInput[] | ConfigurationUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: ConfigurationCreateOrConnectWithoutVehicleInput | ConfigurationCreateOrConnectWithoutVehicleInput[]
    upsert?: ConfigurationUpsertWithWhereUniqueWithoutVehicleInput | ConfigurationUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: ConfigurationCreateManyVehicleInputEnvelope
    set?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    disconnect?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    delete?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    connect?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    update?: ConfigurationUpdateWithWhereUniqueWithoutVehicleInput | ConfigurationUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: ConfigurationUpdateManyWithWhereWithoutVehicleInput | ConfigurationUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: ConfigurationScalarWhereInput | ConfigurationScalarWhereInput[]
  }

  export type BranchInventoryUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<BranchInventoryCreateWithoutVehicleInput, BranchInventoryUncheckedCreateWithoutVehicleInput> | BranchInventoryCreateWithoutVehicleInput[] | BranchInventoryUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: BranchInventoryCreateOrConnectWithoutVehicleInput | BranchInventoryCreateOrConnectWithoutVehicleInput[]
    upsert?: BranchInventoryUpsertWithWhereUniqueWithoutVehicleInput | BranchInventoryUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: BranchInventoryCreateManyVehicleInputEnvelope
    set?: BranchInventoryWhereUniqueInput | BranchInventoryWhereUniqueInput[]
    disconnect?: BranchInventoryWhereUniqueInput | BranchInventoryWhereUniqueInput[]
    delete?: BranchInventoryWhereUniqueInput | BranchInventoryWhereUniqueInput[]
    connect?: BranchInventoryWhereUniqueInput | BranchInventoryWhereUniqueInput[]
    update?: BranchInventoryUpdateWithWhereUniqueWithoutVehicleInput | BranchInventoryUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: BranchInventoryUpdateManyWithWhereWithoutVehicleInput | BranchInventoryUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: BranchInventoryScalarWhereInput | BranchInventoryScalarWhereInput[]
  }

  export type VehicleCreateNestedOneWithoutImagesInput = {
    create?: XOR<VehicleCreateWithoutImagesInput, VehicleUncheckedCreateWithoutImagesInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutImagesInput
    connect?: VehicleWhereUniqueInput
  }

  export type VehicleUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<VehicleCreateWithoutImagesInput, VehicleUncheckedCreateWithoutImagesInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutImagesInput
    upsert?: VehicleUpsertWithoutImagesInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutImagesInput, VehicleUpdateWithoutImagesInput>, VehicleUncheckedUpdateWithoutImagesInput>
  }

  export type VehicleCreateNestedManyWithoutCategoryInput = {
    create?: XOR<VehicleCreateWithoutCategoryInput, VehicleUncheckedCreateWithoutCategoryInput> | VehicleCreateWithoutCategoryInput[] | VehicleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutCategoryInput | VehicleCreateOrConnectWithoutCategoryInput[]
    createMany?: VehicleCreateManyCategoryInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type VehicleUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<VehicleCreateWithoutCategoryInput, VehicleUncheckedCreateWithoutCategoryInput> | VehicleCreateWithoutCategoryInput[] | VehicleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutCategoryInput | VehicleCreateOrConnectWithoutCategoryInput[]
    createMany?: VehicleCreateManyCategoryInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type VehicleUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<VehicleCreateWithoutCategoryInput, VehicleUncheckedCreateWithoutCategoryInput> | VehicleCreateWithoutCategoryInput[] | VehicleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutCategoryInput | VehicleCreateOrConnectWithoutCategoryInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutCategoryInput | VehicleUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: VehicleCreateManyCategoryInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutCategoryInput | VehicleUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutCategoryInput | VehicleUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type VehicleUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<VehicleCreateWithoutCategoryInput, VehicleUncheckedCreateWithoutCategoryInput> | VehicleCreateWithoutCategoryInput[] | VehicleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutCategoryInput | VehicleCreateOrConnectWithoutCategoryInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutCategoryInput | VehicleUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: VehicleCreateManyCategoryInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutCategoryInput | VehicleUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutCategoryInput | VehicleUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type SavedVehicleCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedVehicleCreateWithoutUserInput, SavedVehicleUncheckedCreateWithoutUserInput> | SavedVehicleCreateWithoutUserInput[] | SavedVehicleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedVehicleCreateOrConnectWithoutUserInput | SavedVehicleCreateOrConnectWithoutUserInput[]
    createMany?: SavedVehicleCreateManyUserInputEnvelope
    connect?: SavedVehicleWhereUniqueInput | SavedVehicleWhereUniqueInput[]
  }

  export type ConfigurationCreateNestedManyWithoutUserInput = {
    create?: XOR<ConfigurationCreateWithoutUserInput, ConfigurationUncheckedCreateWithoutUserInput> | ConfigurationCreateWithoutUserInput[] | ConfigurationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConfigurationCreateOrConnectWithoutUserInput | ConfigurationCreateOrConnectWithoutUserInput[]
    createMany?: ConfigurationCreateManyUserInputEnvelope
    connect?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
  }

  export type InquiryCreateNestedManyWithoutUserInput = {
    create?: XOR<InquiryCreateWithoutUserInput, InquiryUncheckedCreateWithoutUserInput> | InquiryCreateWithoutUserInput[] | InquiryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutUserInput | InquiryCreateOrConnectWithoutUserInput[]
    createMany?: InquiryCreateManyUserInputEnvelope
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
  }

  export type TestDriveCreateNestedManyWithoutUserInput = {
    create?: XOR<TestDriveCreateWithoutUserInput, TestDriveUncheckedCreateWithoutUserInput> | TestDriveCreateWithoutUserInput[] | TestDriveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestDriveCreateOrConnectWithoutUserInput | TestDriveCreateOrConnectWithoutUserInput[]
    createMany?: TestDriveCreateManyUserInputEnvelope
    connect?: TestDriveWhereUniqueInput | TestDriveWhereUniqueInput[]
  }

  export type SavedVehicleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedVehicleCreateWithoutUserInput, SavedVehicleUncheckedCreateWithoutUserInput> | SavedVehicleCreateWithoutUserInput[] | SavedVehicleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedVehicleCreateOrConnectWithoutUserInput | SavedVehicleCreateOrConnectWithoutUserInput[]
    createMany?: SavedVehicleCreateManyUserInputEnvelope
    connect?: SavedVehicleWhereUniqueInput | SavedVehicleWhereUniqueInput[]
  }

  export type ConfigurationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConfigurationCreateWithoutUserInput, ConfigurationUncheckedCreateWithoutUserInput> | ConfigurationCreateWithoutUserInput[] | ConfigurationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConfigurationCreateOrConnectWithoutUserInput | ConfigurationCreateOrConnectWithoutUserInput[]
    createMany?: ConfigurationCreateManyUserInputEnvelope
    connect?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
  }

  export type InquiryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InquiryCreateWithoutUserInput, InquiryUncheckedCreateWithoutUserInput> | InquiryCreateWithoutUserInput[] | InquiryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutUserInput | InquiryCreateOrConnectWithoutUserInput[]
    createMany?: InquiryCreateManyUserInputEnvelope
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
  }

  export type TestDriveUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TestDriveCreateWithoutUserInput, TestDriveUncheckedCreateWithoutUserInput> | TestDriveCreateWithoutUserInput[] | TestDriveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestDriveCreateOrConnectWithoutUserInput | TestDriveCreateOrConnectWithoutUserInput[]
    createMany?: TestDriveCreateManyUserInputEnvelope
    connect?: TestDriveWhereUniqueInput | TestDriveWhereUniqueInput[]
  }

  export type SavedVehicleUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedVehicleCreateWithoutUserInput, SavedVehicleUncheckedCreateWithoutUserInput> | SavedVehicleCreateWithoutUserInput[] | SavedVehicleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedVehicleCreateOrConnectWithoutUserInput | SavedVehicleCreateOrConnectWithoutUserInput[]
    upsert?: SavedVehicleUpsertWithWhereUniqueWithoutUserInput | SavedVehicleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedVehicleCreateManyUserInputEnvelope
    set?: SavedVehicleWhereUniqueInput | SavedVehicleWhereUniqueInput[]
    disconnect?: SavedVehicleWhereUniqueInput | SavedVehicleWhereUniqueInput[]
    delete?: SavedVehicleWhereUniqueInput | SavedVehicleWhereUniqueInput[]
    connect?: SavedVehicleWhereUniqueInput | SavedVehicleWhereUniqueInput[]
    update?: SavedVehicleUpdateWithWhereUniqueWithoutUserInput | SavedVehicleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedVehicleUpdateManyWithWhereWithoutUserInput | SavedVehicleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedVehicleScalarWhereInput | SavedVehicleScalarWhereInput[]
  }

  export type ConfigurationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConfigurationCreateWithoutUserInput, ConfigurationUncheckedCreateWithoutUserInput> | ConfigurationCreateWithoutUserInput[] | ConfigurationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConfigurationCreateOrConnectWithoutUserInput | ConfigurationCreateOrConnectWithoutUserInput[]
    upsert?: ConfigurationUpsertWithWhereUniqueWithoutUserInput | ConfigurationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConfigurationCreateManyUserInputEnvelope
    set?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    disconnect?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    delete?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    connect?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    update?: ConfigurationUpdateWithWhereUniqueWithoutUserInput | ConfigurationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConfigurationUpdateManyWithWhereWithoutUserInput | ConfigurationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConfigurationScalarWhereInput | ConfigurationScalarWhereInput[]
  }

  export type InquiryUpdateManyWithoutUserNestedInput = {
    create?: XOR<InquiryCreateWithoutUserInput, InquiryUncheckedCreateWithoutUserInput> | InquiryCreateWithoutUserInput[] | InquiryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutUserInput | InquiryCreateOrConnectWithoutUserInput[]
    upsert?: InquiryUpsertWithWhereUniqueWithoutUserInput | InquiryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InquiryCreateManyUserInputEnvelope
    set?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    disconnect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    delete?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    update?: InquiryUpdateWithWhereUniqueWithoutUserInput | InquiryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InquiryUpdateManyWithWhereWithoutUserInput | InquiryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
  }

  export type TestDriveUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestDriveCreateWithoutUserInput, TestDriveUncheckedCreateWithoutUserInput> | TestDriveCreateWithoutUserInput[] | TestDriveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestDriveCreateOrConnectWithoutUserInput | TestDriveCreateOrConnectWithoutUserInput[]
    upsert?: TestDriveUpsertWithWhereUniqueWithoutUserInput | TestDriveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestDriveCreateManyUserInputEnvelope
    set?: TestDriveWhereUniqueInput | TestDriveWhereUniqueInput[]
    disconnect?: TestDriveWhereUniqueInput | TestDriveWhereUniqueInput[]
    delete?: TestDriveWhereUniqueInput | TestDriveWhereUniqueInput[]
    connect?: TestDriveWhereUniqueInput | TestDriveWhereUniqueInput[]
    update?: TestDriveUpdateWithWhereUniqueWithoutUserInput | TestDriveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestDriveUpdateManyWithWhereWithoutUserInput | TestDriveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestDriveScalarWhereInput | TestDriveScalarWhereInput[]
  }

  export type SavedVehicleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedVehicleCreateWithoutUserInput, SavedVehicleUncheckedCreateWithoutUserInput> | SavedVehicleCreateWithoutUserInput[] | SavedVehicleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedVehicleCreateOrConnectWithoutUserInput | SavedVehicleCreateOrConnectWithoutUserInput[]
    upsert?: SavedVehicleUpsertWithWhereUniqueWithoutUserInput | SavedVehicleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedVehicleCreateManyUserInputEnvelope
    set?: SavedVehicleWhereUniqueInput | SavedVehicleWhereUniqueInput[]
    disconnect?: SavedVehicleWhereUniqueInput | SavedVehicleWhereUniqueInput[]
    delete?: SavedVehicleWhereUniqueInput | SavedVehicleWhereUniqueInput[]
    connect?: SavedVehicleWhereUniqueInput | SavedVehicleWhereUniqueInput[]
    update?: SavedVehicleUpdateWithWhereUniqueWithoutUserInput | SavedVehicleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedVehicleUpdateManyWithWhereWithoutUserInput | SavedVehicleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedVehicleScalarWhereInput | SavedVehicleScalarWhereInput[]
  }

  export type ConfigurationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConfigurationCreateWithoutUserInput, ConfigurationUncheckedCreateWithoutUserInput> | ConfigurationCreateWithoutUserInput[] | ConfigurationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConfigurationCreateOrConnectWithoutUserInput | ConfigurationCreateOrConnectWithoutUserInput[]
    upsert?: ConfigurationUpsertWithWhereUniqueWithoutUserInput | ConfigurationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConfigurationCreateManyUserInputEnvelope
    set?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    disconnect?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    delete?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    connect?: ConfigurationWhereUniqueInput | ConfigurationWhereUniqueInput[]
    update?: ConfigurationUpdateWithWhereUniqueWithoutUserInput | ConfigurationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConfigurationUpdateManyWithWhereWithoutUserInput | ConfigurationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConfigurationScalarWhereInput | ConfigurationScalarWhereInput[]
  }

  export type InquiryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InquiryCreateWithoutUserInput, InquiryUncheckedCreateWithoutUserInput> | InquiryCreateWithoutUserInput[] | InquiryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutUserInput | InquiryCreateOrConnectWithoutUserInput[]
    upsert?: InquiryUpsertWithWhereUniqueWithoutUserInput | InquiryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InquiryCreateManyUserInputEnvelope
    set?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    disconnect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    delete?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    update?: InquiryUpdateWithWhereUniqueWithoutUserInput | InquiryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InquiryUpdateManyWithWhereWithoutUserInput | InquiryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
  }

  export type TestDriveUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestDriveCreateWithoutUserInput, TestDriveUncheckedCreateWithoutUserInput> | TestDriveCreateWithoutUserInput[] | TestDriveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestDriveCreateOrConnectWithoutUserInput | TestDriveCreateOrConnectWithoutUserInput[]
    upsert?: TestDriveUpsertWithWhereUniqueWithoutUserInput | TestDriveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestDriveCreateManyUserInputEnvelope
    set?: TestDriveWhereUniqueInput | TestDriveWhereUniqueInput[]
    disconnect?: TestDriveWhereUniqueInput | TestDriveWhereUniqueInput[]
    delete?: TestDriveWhereUniqueInput | TestDriveWhereUniqueInput[]
    connect?: TestDriveWhereUniqueInput | TestDriveWhereUniqueInput[]
    update?: TestDriveUpdateWithWhereUniqueWithoutUserInput | TestDriveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestDriveUpdateManyWithWhereWithoutUserInput | TestDriveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestDriveScalarWhereInput | TestDriveScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSavedVehiclesInput = {
    create?: XOR<UserCreateWithoutSavedVehiclesInput, UserUncheckedCreateWithoutSavedVehiclesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedVehiclesInput
    connect?: UserWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutSavedByInput = {
    create?: XOR<VehicleCreateWithoutSavedByInput, VehicleUncheckedCreateWithoutSavedByInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutSavedByInput
    connect?: VehicleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSavedVehiclesNestedInput = {
    create?: XOR<UserCreateWithoutSavedVehiclesInput, UserUncheckedCreateWithoutSavedVehiclesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedVehiclesInput
    upsert?: UserUpsertWithoutSavedVehiclesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSavedVehiclesInput, UserUpdateWithoutSavedVehiclesInput>, UserUncheckedUpdateWithoutSavedVehiclesInput>
  }

  export type VehicleUpdateOneRequiredWithoutSavedByNestedInput = {
    create?: XOR<VehicleCreateWithoutSavedByInput, VehicleUncheckedCreateWithoutSavedByInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutSavedByInput
    upsert?: VehicleUpsertWithoutSavedByInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutSavedByInput, VehicleUpdateWithoutSavedByInput>, VehicleUncheckedUpdateWithoutSavedByInput>
  }

  export type UserCreateNestedOneWithoutConfigurationsInput = {
    create?: XOR<UserCreateWithoutConfigurationsInput, UserUncheckedCreateWithoutConfigurationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConfigurationsInput
    connect?: UserWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutConfigurationsInput = {
    create?: XOR<VehicleCreateWithoutConfigurationsInput, VehicleUncheckedCreateWithoutConfigurationsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutConfigurationsInput
    connect?: VehicleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutConfigurationsNestedInput = {
    create?: XOR<UserCreateWithoutConfigurationsInput, UserUncheckedCreateWithoutConfigurationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConfigurationsInput
    upsert?: UserUpsertWithoutConfigurationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConfigurationsInput, UserUpdateWithoutConfigurationsInput>, UserUncheckedUpdateWithoutConfigurationsInput>
  }

  export type VehicleUpdateOneRequiredWithoutConfigurationsNestedInput = {
    create?: XOR<VehicleCreateWithoutConfigurationsInput, VehicleUncheckedCreateWithoutConfigurationsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutConfigurationsInput
    upsert?: VehicleUpsertWithoutConfigurationsInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutConfigurationsInput, VehicleUpdateWithoutConfigurationsInput>, VehicleUncheckedUpdateWithoutConfigurationsInput>
  }

  export type UserCreateNestedOneWithoutTestDrivesInput = {
    create?: XOR<UserCreateWithoutTestDrivesInput, UserUncheckedCreateWithoutTestDrivesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestDrivesInput
    connect?: UserWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutTestDrivesInput = {
    create?: XOR<VehicleCreateWithoutTestDrivesInput, VehicleUncheckedCreateWithoutTestDrivesInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutTestDrivesInput
    connect?: VehicleWhereUniqueInput
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutTestDrivesNestedInput = {
    create?: XOR<UserCreateWithoutTestDrivesInput, UserUncheckedCreateWithoutTestDrivesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestDrivesInput
    upsert?: UserUpsertWithoutTestDrivesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTestDrivesInput, UserUpdateWithoutTestDrivesInput>, UserUncheckedUpdateWithoutTestDrivesInput>
  }

  export type VehicleUpdateOneRequiredWithoutTestDrivesNestedInput = {
    create?: XOR<VehicleCreateWithoutTestDrivesInput, VehicleUncheckedCreateWithoutTestDrivesInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutTestDrivesInput
    upsert?: VehicleUpsertWithoutTestDrivesInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutTestDrivesInput, VehicleUpdateWithoutTestDrivesInput>, VehicleUncheckedUpdateWithoutTestDrivesInput>
  }

  export type UserCreateNestedOneWithoutInquiriesInput = {
    create?: XOR<UserCreateWithoutInquiriesInput, UserUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInquiriesInput
    connect?: UserWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutInquiriesInput = {
    create?: XOR<VehicleCreateWithoutInquiriesInput, VehicleUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutInquiriesInput
    connect?: VehicleWhereUniqueInput
  }

  export type EnumInquiryTypeFieldUpdateOperationsInput = {
    set?: $Enums.InquiryType
  }

  export type EnumInquiryStatusFieldUpdateOperationsInput = {
    set?: $Enums.InquiryStatus
  }

  export type UserUpdateOneWithoutInquiriesNestedInput = {
    create?: XOR<UserCreateWithoutInquiriesInput, UserUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInquiriesInput
    upsert?: UserUpsertWithoutInquiriesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInquiriesInput, UserUpdateWithoutInquiriesInput>, UserUncheckedUpdateWithoutInquiriesInput>
  }

  export type VehicleUpdateOneWithoutInquiriesNestedInput = {
    create?: XOR<VehicleCreateWithoutInquiriesInput, VehicleUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutInquiriesInput
    upsert?: VehicleUpsertWithoutInquiriesInput
    disconnect?: VehicleWhereInput | boolean
    delete?: VehicleWhereInput | boolean
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutInquiriesInput, VehicleUpdateWithoutInquiriesInput>, VehicleUncheckedUpdateWithoutInquiriesInput>
  }

  export type EnumApplicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApplicationStatus
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type TradeInCreateimagesInput = {
    set: string[]
  }

  export type TradeInUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumTradeInStatusFieldUpdateOperationsInput = {
    set?: $Enums.TradeInStatus
  }

  export type PromotionCreatevehicleIdsInput = {
    set: string[]
  }

  export type PromotionUpdatevehicleIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumVehicleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleStatus | EnumVehicleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleStatus[] | ListEnumVehicleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleStatus[] | ListEnumVehicleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleStatusFilter<$PrismaModel> | $Enums.VehicleStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumVehicleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleStatus | EnumVehicleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleStatus[] | ListEnumVehicleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleStatus[] | ListEnumVehicleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleStatusWithAggregatesFilter<$PrismaModel> | $Enums.VehicleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVehicleStatusFilter<$PrismaModel>
    _max?: NestedEnumVehicleStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumInquiryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryType | EnumInquiryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryType[] | ListEnumInquiryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryType[] | ListEnumInquiryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryTypeFilter<$PrismaModel> | $Enums.InquiryType
  }

  export type NestedEnumInquiryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryStatus | EnumInquiryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryStatusFilter<$PrismaModel> | $Enums.InquiryStatus
  }

  export type NestedEnumInquiryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryType | EnumInquiryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryType[] | ListEnumInquiryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryType[] | ListEnumInquiryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryTypeWithAggregatesFilter<$PrismaModel> | $Enums.InquiryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInquiryTypeFilter<$PrismaModel>
    _max?: NestedEnumInquiryTypeFilter<$PrismaModel>
  }

  export type NestedEnumInquiryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryStatus | EnumInquiryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InquiryStatus[] | ListEnumInquiryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInquiryStatusWithAggregatesFilter<$PrismaModel> | $Enums.InquiryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInquiryStatusFilter<$PrismaModel>
    _max?: NestedEnumInquiryStatusFilter<$PrismaModel>
  }

  export type NestedEnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumTradeInStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeInStatus | EnumTradeInStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TradeInStatus[] | ListEnumTradeInStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeInStatus[] | ListEnumTradeInStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeInStatusFilter<$PrismaModel> | $Enums.TradeInStatus
  }

  export type NestedEnumTradeInStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TradeInStatus | EnumTradeInStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TradeInStatus[] | ListEnumTradeInStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TradeInStatus[] | ListEnumTradeInStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTradeInStatusWithAggregatesFilter<$PrismaModel> | $Enums.TradeInStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTradeInStatusFilter<$PrismaModel>
    _max?: NestedEnumTradeInStatusFilter<$PrismaModel>
  }

  export type BranchCreateWithoutDealershipInput = {
    id?: string
    name: string
    address: string
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: BranchInventoryCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutDealershipInput = {
    id?: string
    name: string
    address: string
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: BranchInventoryUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutDealershipInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutDealershipInput, BranchUncheckedCreateWithoutDealershipInput>
  }

  export type BranchCreateManyDealershipInputEnvelope = {
    data: BranchCreateManyDealershipInput | BranchCreateManyDealershipInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithWhereUniqueWithoutDealershipInput = {
    where: BranchWhereUniqueInput
    update: XOR<BranchUpdateWithoutDealershipInput, BranchUncheckedUpdateWithoutDealershipInput>
    create: XOR<BranchCreateWithoutDealershipInput, BranchUncheckedCreateWithoutDealershipInput>
  }

  export type BranchUpdateWithWhereUniqueWithoutDealershipInput = {
    where: BranchWhereUniqueInput
    data: XOR<BranchUpdateWithoutDealershipInput, BranchUncheckedUpdateWithoutDealershipInput>
  }

  export type BranchUpdateManyWithWhereWithoutDealershipInput = {
    where: BranchScalarWhereInput
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyWithoutDealershipInput>
  }

  export type BranchScalarWhereInput = {
    AND?: BranchScalarWhereInput | BranchScalarWhereInput[]
    OR?: BranchScalarWhereInput[]
    NOT?: BranchScalarWhereInput | BranchScalarWhereInput[]
    id?: StringFilter<"Branch"> | string
    name?: StringFilter<"Branch"> | string
    address?: StringFilter<"Branch"> | string
    phone?: StringNullableFilter<"Branch"> | string | null
    email?: StringNullableFilter<"Branch"> | string | null
    dealershipId?: StringFilter<"Branch"> | string
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
  }

  export type DealershipCreateWithoutBranchesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealershipUncheckedCreateWithoutBranchesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealershipCreateOrConnectWithoutBranchesInput = {
    where: DealershipWhereUniqueInput
    create: XOR<DealershipCreateWithoutBranchesInput, DealershipUncheckedCreateWithoutBranchesInput>
  }

  export type BranchInventoryCreateWithoutBranchInput = {
    id?: string
    stock?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle: VehicleCreateNestedOneWithoutBranchInventoryInput
  }

  export type BranchInventoryUncheckedCreateWithoutBranchInput = {
    id?: string
    vehicleId: string
    stock?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchInventoryCreateOrConnectWithoutBranchInput = {
    where: BranchInventoryWhereUniqueInput
    create: XOR<BranchInventoryCreateWithoutBranchInput, BranchInventoryUncheckedCreateWithoutBranchInput>
  }

  export type BranchInventoryCreateManyBranchInputEnvelope = {
    data: BranchInventoryCreateManyBranchInput | BranchInventoryCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type DealershipUpsertWithoutBranchesInput = {
    update: XOR<DealershipUpdateWithoutBranchesInput, DealershipUncheckedUpdateWithoutBranchesInput>
    create: XOR<DealershipCreateWithoutBranchesInput, DealershipUncheckedCreateWithoutBranchesInput>
    where?: DealershipWhereInput
  }

  export type DealershipUpdateToOneWithWhereWithoutBranchesInput = {
    where?: DealershipWhereInput
    data: XOR<DealershipUpdateWithoutBranchesInput, DealershipUncheckedUpdateWithoutBranchesInput>
  }

  export type DealershipUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealershipUncheckedUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchInventoryUpsertWithWhereUniqueWithoutBranchInput = {
    where: BranchInventoryWhereUniqueInput
    update: XOR<BranchInventoryUpdateWithoutBranchInput, BranchInventoryUncheckedUpdateWithoutBranchInput>
    create: XOR<BranchInventoryCreateWithoutBranchInput, BranchInventoryUncheckedCreateWithoutBranchInput>
  }

  export type BranchInventoryUpdateWithWhereUniqueWithoutBranchInput = {
    where: BranchInventoryWhereUniqueInput
    data: XOR<BranchInventoryUpdateWithoutBranchInput, BranchInventoryUncheckedUpdateWithoutBranchInput>
  }

  export type BranchInventoryUpdateManyWithWhereWithoutBranchInput = {
    where: BranchInventoryScalarWhereInput
    data: XOR<BranchInventoryUpdateManyMutationInput, BranchInventoryUncheckedUpdateManyWithoutBranchInput>
  }

  export type BranchInventoryScalarWhereInput = {
    AND?: BranchInventoryScalarWhereInput | BranchInventoryScalarWhereInput[]
    OR?: BranchInventoryScalarWhereInput[]
    NOT?: BranchInventoryScalarWhereInput | BranchInventoryScalarWhereInput[]
    id?: StringFilter<"BranchInventory"> | string
    branchId?: StringFilter<"BranchInventory"> | string
    vehicleId?: StringFilter<"BranchInventory"> | string
    stock?: IntFilter<"BranchInventory"> | number
    price?: DecimalFilter<"BranchInventory"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"BranchInventory"> | Date | string
    updatedAt?: DateTimeFilter<"BranchInventory"> | Date | string
  }

  export type BranchCreateWithoutInventoryInput = {
    id?: string
    name: string
    address: string
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dealership: DealershipCreateNestedOneWithoutBranchesInput
  }

  export type BranchUncheckedCreateWithoutInventoryInput = {
    id?: string
    name: string
    address: string
    phone?: string | null
    email?: string | null
    dealershipId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchCreateOrConnectWithoutInventoryInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutInventoryInput, BranchUncheckedCreateWithoutInventoryInput>
  }

  export type VehicleCreateWithoutBranchInventoryInput = {
    id?: string
    slug: string
    brand: string
    model: string
    year: number
    variant?: string | null
    cashPrice: Decimal | DecimalJsLike | number | string
    downPayment: Decimal | DecimalJsLike | number | string
    monthlyPayment: Decimal | DecimalJsLike | number | string
    leaseTerm: number
    transmission: string
    fuelType: string
    engineSize?: string | null
    horsepower?: number | null
    seatingCapacity: number
    cargoSpace?: string | null
    features: JsonNullValueInput | InputJsonValue
    specifications: JsonNullValueInput | InputJsonValue
    description?: string | null
    videos?: VehicleCreatevideosInput | string[]
    model3dUrl?: string | null
    thumbnailUrl: string
    status?: $Enums.VehicleStatus
    availability: string
    featured?: boolean
    stockCount?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VehicleImageCreateNestedManyWithoutVehicleInput
    category: CategoryCreateNestedOneWithoutVehiclesInput
    inquiries?: InquiryCreateNestedManyWithoutVehicleInput
    testDrives?: TestDriveCreateNestedManyWithoutVehicleInput
    savedBy?: SavedVehicleCreateNestedManyWithoutVehicleInput
    configurations?: ConfigurationCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutBranchInventoryInput = {
    id?: string
    slug: string
    brand: string
    model: string
    year: number
    variant?: string | null
    cashPrice: Decimal | DecimalJsLike | number | string
    downPayment: Decimal | DecimalJsLike | number | string
    monthlyPayment: Decimal | DecimalJsLike | number | string
    leaseTerm: number
    transmission: string
    fuelType: string
    engineSize?: string | null
    horsepower?: number | null
    seatingCapacity: number
    cargoSpace?: string | null
    features: JsonNullValueInput | InputJsonValue
    specifications: JsonNullValueInput | InputJsonValue
    description?: string | null
    videos?: VehicleCreatevideosInput | string[]
    model3dUrl?: string | null
    thumbnailUrl: string
    status?: $Enums.VehicleStatus
    availability: string
    featured?: boolean
    stockCount?: number
    metaTitle?: string | null
    metaDescription?: string | null
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VehicleImageUncheckedCreateNestedManyWithoutVehicleInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutVehicleInput
    testDrives?: TestDriveUncheckedCreateNestedManyWithoutVehicleInput
    savedBy?: SavedVehicleUncheckedCreateNestedManyWithoutVehicleInput
    configurations?: ConfigurationUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutBranchInventoryInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutBranchInventoryInput, VehicleUncheckedCreateWithoutBranchInventoryInput>
  }

  export type BranchUpsertWithoutInventoryInput = {
    update: XOR<BranchUpdateWithoutInventoryInput, BranchUncheckedUpdateWithoutInventoryInput>
    create: XOR<BranchCreateWithoutInventoryInput, BranchUncheckedCreateWithoutInventoryInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutInventoryInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutInventoryInput, BranchUncheckedUpdateWithoutInventoryInput>
  }

  export type BranchUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealership?: DealershipUpdateOneRequiredWithoutBranchesNestedInput
  }

  export type BranchUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    dealershipId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleUpsertWithoutBranchInventoryInput = {
    update: XOR<VehicleUpdateWithoutBranchInventoryInput, VehicleUncheckedUpdateWithoutBranchInventoryInput>
    create: XOR<VehicleCreateWithoutBranchInventoryInput, VehicleUncheckedCreateWithoutBranchInventoryInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutBranchInventoryInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutBranchInventoryInput, VehicleUncheckedUpdateWithoutBranchInventoryInput>
  }

  export type VehicleUpdateWithoutBranchInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    cashPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    engineSize?: NullableStringFieldUpdateOperationsInput | string | null
    horsepower?: NullableIntFieldUpdateOperationsInput | number | null
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    cargoSpace?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    specifications?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VehicleUpdatevideosInput | string[]
    model3dUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    availability?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VehicleImageUpdateManyWithoutVehicleNestedInput
    category?: CategoryUpdateOneRequiredWithoutVehiclesNestedInput
    inquiries?: InquiryUpdateManyWithoutVehicleNestedInput
    testDrives?: TestDriveUpdateManyWithoutVehicleNestedInput
    savedBy?: SavedVehicleUpdateManyWithoutVehicleNestedInput
    configurations?: ConfigurationUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutBranchInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    cashPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    engineSize?: NullableStringFieldUpdateOperationsInput | string | null
    horsepower?: NullableIntFieldUpdateOperationsInput | number | null
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    cargoSpace?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    specifications?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VehicleUpdatevideosInput | string[]
    model3dUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    availability?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VehicleImageUncheckedUpdateManyWithoutVehicleNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutVehicleNestedInput
    testDrives?: TestDriveUncheckedUpdateManyWithoutVehicleNestedInput
    savedBy?: SavedVehicleUncheckedUpdateManyWithoutVehicleNestedInput
    configurations?: ConfigurationUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleImageCreateWithoutVehicleInput = {
    id?: string
    url: string
    alt: string
    type: string
    order?: number
  }

  export type VehicleImageUncheckedCreateWithoutVehicleInput = {
    id?: string
    url: string
    alt: string
    type: string
    order?: number
  }

  export type VehicleImageCreateOrConnectWithoutVehicleInput = {
    where: VehicleImageWhereUniqueInput
    create: XOR<VehicleImageCreateWithoutVehicleInput, VehicleImageUncheckedCreateWithoutVehicleInput>
  }

  export type VehicleImageCreateManyVehicleInputEnvelope = {
    data: VehicleImageCreateManyVehicleInput | VehicleImageCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutVehiclesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutVehiclesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutVehiclesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutVehiclesInput, CategoryUncheckedCreateWithoutVehiclesInput>
  }

  export type InquiryCreateWithoutVehicleInput = {
    id?: string
    type: $Enums.InquiryType
    firstName: string
    lastName: string
    email: string
    phone: string
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    assignedTo?: string | null
    response?: string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutInquiriesInput
  }

  export type InquiryUncheckedCreateWithoutVehicleInput = {
    id?: string
    userId?: string | null
    type: $Enums.InquiryType
    firstName: string
    lastName: string
    email: string
    phone: string
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    assignedTo?: string | null
    response?: string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InquiryCreateOrConnectWithoutVehicleInput = {
    where: InquiryWhereUniqueInput
    create: XOR<InquiryCreateWithoutVehicleInput, InquiryUncheckedCreateWithoutVehicleInput>
  }

  export type InquiryCreateManyVehicleInputEnvelope = {
    data: InquiryCreateManyVehicleInput | InquiryCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type TestDriveCreateWithoutVehicleInput = {
    id?: string
    preferredDate: Date | string
    preferredTime: string
    location: string
    firstName: string
    lastName: string
    email: string
    phone: string
    status?: $Enums.BookingStatus
    notes?: string | null
    adminNotes?: string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTestDrivesInput
  }

  export type TestDriveUncheckedCreateWithoutVehicleInput = {
    id?: string
    userId: string
    preferredDate: Date | string
    preferredTime: string
    location: string
    firstName: string
    lastName: string
    email: string
    phone: string
    status?: $Enums.BookingStatus
    notes?: string | null
    adminNotes?: string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestDriveCreateOrConnectWithoutVehicleInput = {
    where: TestDriveWhereUniqueInput
    create: XOR<TestDriveCreateWithoutVehicleInput, TestDriveUncheckedCreateWithoutVehicleInput>
  }

  export type TestDriveCreateManyVehicleInputEnvelope = {
    data: TestDriveCreateManyVehicleInput | TestDriveCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type SavedVehicleCreateWithoutVehicleInput = {
    id?: string
    notes?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSavedVehiclesInput
  }

  export type SavedVehicleUncheckedCreateWithoutVehicleInput = {
    id?: string
    userId: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type SavedVehicleCreateOrConnectWithoutVehicleInput = {
    where: SavedVehicleWhereUniqueInput
    create: XOR<SavedVehicleCreateWithoutVehicleInput, SavedVehicleUncheckedCreateWithoutVehicleInput>
  }

  export type SavedVehicleCreateManyVehicleInputEnvelope = {
    data: SavedVehicleCreateManyVehicleInput | SavedVehicleCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type ConfigurationCreateWithoutVehicleInput = {
    id?: string
    color: string
    colorHex: string
    wheels?: string | null
    interior?: string | null
    packages: JsonNullValueInput | InputJsonValue
    accessories: JsonNullValueInput | InputJsonValue
    totalPrice: Decimal | DecimalJsLike | number | string
    shared?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConfigurationsInput
  }

  export type ConfigurationUncheckedCreateWithoutVehicleInput = {
    id?: string
    userId: string
    color: string
    colorHex: string
    wheels?: string | null
    interior?: string | null
    packages: JsonNullValueInput | InputJsonValue
    accessories: JsonNullValueInput | InputJsonValue
    totalPrice: Decimal | DecimalJsLike | number | string
    shared?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigurationCreateOrConnectWithoutVehicleInput = {
    where: ConfigurationWhereUniqueInput
    create: XOR<ConfigurationCreateWithoutVehicleInput, ConfigurationUncheckedCreateWithoutVehicleInput>
  }

  export type ConfigurationCreateManyVehicleInputEnvelope = {
    data: ConfigurationCreateManyVehicleInput | ConfigurationCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type BranchInventoryCreateWithoutVehicleInput = {
    id?: string
    stock?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutInventoryInput
  }

  export type BranchInventoryUncheckedCreateWithoutVehicleInput = {
    id?: string
    branchId: string
    stock?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchInventoryCreateOrConnectWithoutVehicleInput = {
    where: BranchInventoryWhereUniqueInput
    create: XOR<BranchInventoryCreateWithoutVehicleInput, BranchInventoryUncheckedCreateWithoutVehicleInput>
  }

  export type BranchInventoryCreateManyVehicleInputEnvelope = {
    data: BranchInventoryCreateManyVehicleInput | BranchInventoryCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type VehicleImageUpsertWithWhereUniqueWithoutVehicleInput = {
    where: VehicleImageWhereUniqueInput
    update: XOR<VehicleImageUpdateWithoutVehicleInput, VehicleImageUncheckedUpdateWithoutVehicleInput>
    create: XOR<VehicleImageCreateWithoutVehicleInput, VehicleImageUncheckedCreateWithoutVehicleInput>
  }

  export type VehicleImageUpdateWithWhereUniqueWithoutVehicleInput = {
    where: VehicleImageWhereUniqueInput
    data: XOR<VehicleImageUpdateWithoutVehicleInput, VehicleImageUncheckedUpdateWithoutVehicleInput>
  }

  export type VehicleImageUpdateManyWithWhereWithoutVehicleInput = {
    where: VehicleImageScalarWhereInput
    data: XOR<VehicleImageUpdateManyMutationInput, VehicleImageUncheckedUpdateManyWithoutVehicleInput>
  }

  export type VehicleImageScalarWhereInput = {
    AND?: VehicleImageScalarWhereInput | VehicleImageScalarWhereInput[]
    OR?: VehicleImageScalarWhereInput[]
    NOT?: VehicleImageScalarWhereInput | VehicleImageScalarWhereInput[]
    id?: StringFilter<"VehicleImage"> | string
    url?: StringFilter<"VehicleImage"> | string
    alt?: StringFilter<"VehicleImage"> | string
    type?: StringFilter<"VehicleImage"> | string
    order?: IntFilter<"VehicleImage"> | number
    vehicleId?: StringFilter<"VehicleImage"> | string
  }

  export type CategoryUpsertWithoutVehiclesInput = {
    update: XOR<CategoryUpdateWithoutVehiclesInput, CategoryUncheckedUpdateWithoutVehiclesInput>
    create: XOR<CategoryCreateWithoutVehiclesInput, CategoryUncheckedCreateWithoutVehiclesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutVehiclesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutVehiclesInput, CategoryUncheckedUpdateWithoutVehiclesInput>
  }

  export type CategoryUpdateWithoutVehiclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutVehiclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryUpsertWithWhereUniqueWithoutVehicleInput = {
    where: InquiryWhereUniqueInput
    update: XOR<InquiryUpdateWithoutVehicleInput, InquiryUncheckedUpdateWithoutVehicleInput>
    create: XOR<InquiryCreateWithoutVehicleInput, InquiryUncheckedCreateWithoutVehicleInput>
  }

  export type InquiryUpdateWithWhereUniqueWithoutVehicleInput = {
    where: InquiryWhereUniqueInput
    data: XOR<InquiryUpdateWithoutVehicleInput, InquiryUncheckedUpdateWithoutVehicleInput>
  }

  export type InquiryUpdateManyWithWhereWithoutVehicleInput = {
    where: InquiryScalarWhereInput
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyWithoutVehicleInput>
  }

  export type InquiryScalarWhereInput = {
    AND?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
    OR?: InquiryScalarWhereInput[]
    NOT?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
    id?: StringFilter<"Inquiry"> | string
    userId?: StringNullableFilter<"Inquiry"> | string | null
    vehicleId?: StringNullableFilter<"Inquiry"> | string | null
    type?: EnumInquiryTypeFilter<"Inquiry"> | $Enums.InquiryType
    firstName?: StringFilter<"Inquiry"> | string
    lastName?: StringFilter<"Inquiry"> | string
    email?: StringFilter<"Inquiry"> | string
    phone?: StringFilter<"Inquiry"> | string
    subject?: StringNullableFilter<"Inquiry"> | string | null
    message?: StringFilter<"Inquiry"> | string
    status?: EnumInquiryStatusFilter<"Inquiry"> | $Enums.InquiryStatus
    assignedTo?: StringNullableFilter<"Inquiry"> | string | null
    response?: StringNullableFilter<"Inquiry"> | string | null
    respondedAt?: DateTimeNullableFilter<"Inquiry"> | Date | string | null
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
    updatedAt?: DateTimeFilter<"Inquiry"> | Date | string
  }

  export type TestDriveUpsertWithWhereUniqueWithoutVehicleInput = {
    where: TestDriveWhereUniqueInput
    update: XOR<TestDriveUpdateWithoutVehicleInput, TestDriveUncheckedUpdateWithoutVehicleInput>
    create: XOR<TestDriveCreateWithoutVehicleInput, TestDriveUncheckedCreateWithoutVehicleInput>
  }

  export type TestDriveUpdateWithWhereUniqueWithoutVehicleInput = {
    where: TestDriveWhereUniqueInput
    data: XOR<TestDriveUpdateWithoutVehicleInput, TestDriveUncheckedUpdateWithoutVehicleInput>
  }

  export type TestDriveUpdateManyWithWhereWithoutVehicleInput = {
    where: TestDriveScalarWhereInput
    data: XOR<TestDriveUpdateManyMutationInput, TestDriveUncheckedUpdateManyWithoutVehicleInput>
  }

  export type TestDriveScalarWhereInput = {
    AND?: TestDriveScalarWhereInput | TestDriveScalarWhereInput[]
    OR?: TestDriveScalarWhereInput[]
    NOT?: TestDriveScalarWhereInput | TestDriveScalarWhereInput[]
    id?: StringFilter<"TestDrive"> | string
    userId?: StringFilter<"TestDrive"> | string
    vehicleId?: StringFilter<"TestDrive"> | string
    preferredDate?: DateTimeFilter<"TestDrive"> | Date | string
    preferredTime?: StringFilter<"TestDrive"> | string
    location?: StringFilter<"TestDrive"> | string
    firstName?: StringFilter<"TestDrive"> | string
    lastName?: StringFilter<"TestDrive"> | string
    email?: StringFilter<"TestDrive"> | string
    phone?: StringFilter<"TestDrive"> | string
    status?: EnumBookingStatusFilter<"TestDrive"> | $Enums.BookingStatus
    notes?: StringNullableFilter<"TestDrive"> | string | null
    adminNotes?: StringNullableFilter<"TestDrive"> | string | null
    confirmedAt?: DateTimeNullableFilter<"TestDrive"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"TestDrive"> | Date | string | null
    createdAt?: DateTimeFilter<"TestDrive"> | Date | string
    updatedAt?: DateTimeFilter<"TestDrive"> | Date | string
  }

  export type SavedVehicleUpsertWithWhereUniqueWithoutVehicleInput = {
    where: SavedVehicleWhereUniqueInput
    update: XOR<SavedVehicleUpdateWithoutVehicleInput, SavedVehicleUncheckedUpdateWithoutVehicleInput>
    create: XOR<SavedVehicleCreateWithoutVehicleInput, SavedVehicleUncheckedCreateWithoutVehicleInput>
  }

  export type SavedVehicleUpdateWithWhereUniqueWithoutVehicleInput = {
    where: SavedVehicleWhereUniqueInput
    data: XOR<SavedVehicleUpdateWithoutVehicleInput, SavedVehicleUncheckedUpdateWithoutVehicleInput>
  }

  export type SavedVehicleUpdateManyWithWhereWithoutVehicleInput = {
    where: SavedVehicleScalarWhereInput
    data: XOR<SavedVehicleUpdateManyMutationInput, SavedVehicleUncheckedUpdateManyWithoutVehicleInput>
  }

  export type SavedVehicleScalarWhereInput = {
    AND?: SavedVehicleScalarWhereInput | SavedVehicleScalarWhereInput[]
    OR?: SavedVehicleScalarWhereInput[]
    NOT?: SavedVehicleScalarWhereInput | SavedVehicleScalarWhereInput[]
    id?: StringFilter<"SavedVehicle"> | string
    userId?: StringFilter<"SavedVehicle"> | string
    vehicleId?: StringFilter<"SavedVehicle"> | string
    notes?: StringNullableFilter<"SavedVehicle"> | string | null
    createdAt?: DateTimeFilter<"SavedVehicle"> | Date | string
  }

  export type ConfigurationUpsertWithWhereUniqueWithoutVehicleInput = {
    where: ConfigurationWhereUniqueInput
    update: XOR<ConfigurationUpdateWithoutVehicleInput, ConfigurationUncheckedUpdateWithoutVehicleInput>
    create: XOR<ConfigurationCreateWithoutVehicleInput, ConfigurationUncheckedCreateWithoutVehicleInput>
  }

  export type ConfigurationUpdateWithWhereUniqueWithoutVehicleInput = {
    where: ConfigurationWhereUniqueInput
    data: XOR<ConfigurationUpdateWithoutVehicleInput, ConfigurationUncheckedUpdateWithoutVehicleInput>
  }

  export type ConfigurationUpdateManyWithWhereWithoutVehicleInput = {
    where: ConfigurationScalarWhereInput
    data: XOR<ConfigurationUpdateManyMutationInput, ConfigurationUncheckedUpdateManyWithoutVehicleInput>
  }

  export type ConfigurationScalarWhereInput = {
    AND?: ConfigurationScalarWhereInput | ConfigurationScalarWhereInput[]
    OR?: ConfigurationScalarWhereInput[]
    NOT?: ConfigurationScalarWhereInput | ConfigurationScalarWhereInput[]
    id?: StringFilter<"Configuration"> | string
    userId?: StringFilter<"Configuration"> | string
    vehicleId?: StringFilter<"Configuration"> | string
    color?: StringFilter<"Configuration"> | string
    colorHex?: StringFilter<"Configuration"> | string
    wheels?: StringNullableFilter<"Configuration"> | string | null
    interior?: StringNullableFilter<"Configuration"> | string | null
    packages?: JsonFilter<"Configuration">
    accessories?: JsonFilter<"Configuration">
    totalPrice?: DecimalFilter<"Configuration"> | Decimal | DecimalJsLike | number | string
    shared?: BoolFilter<"Configuration"> | boolean
    shareToken?: StringNullableFilter<"Configuration"> | string | null
    createdAt?: DateTimeFilter<"Configuration"> | Date | string
    updatedAt?: DateTimeFilter<"Configuration"> | Date | string
  }

  export type BranchInventoryUpsertWithWhereUniqueWithoutVehicleInput = {
    where: BranchInventoryWhereUniqueInput
    update: XOR<BranchInventoryUpdateWithoutVehicleInput, BranchInventoryUncheckedUpdateWithoutVehicleInput>
    create: XOR<BranchInventoryCreateWithoutVehicleInput, BranchInventoryUncheckedCreateWithoutVehicleInput>
  }

  export type BranchInventoryUpdateWithWhereUniqueWithoutVehicleInput = {
    where: BranchInventoryWhereUniqueInput
    data: XOR<BranchInventoryUpdateWithoutVehicleInput, BranchInventoryUncheckedUpdateWithoutVehicleInput>
  }

  export type BranchInventoryUpdateManyWithWhereWithoutVehicleInput = {
    where: BranchInventoryScalarWhereInput
    data: XOR<BranchInventoryUpdateManyMutationInput, BranchInventoryUncheckedUpdateManyWithoutVehicleInput>
  }

  export type VehicleCreateWithoutImagesInput = {
    id?: string
    slug: string
    brand: string
    model: string
    year: number
    variant?: string | null
    cashPrice: Decimal | DecimalJsLike | number | string
    downPayment: Decimal | DecimalJsLike | number | string
    monthlyPayment: Decimal | DecimalJsLike | number | string
    leaseTerm: number
    transmission: string
    fuelType: string
    engineSize?: string | null
    horsepower?: number | null
    seatingCapacity: number
    cargoSpace?: string | null
    features: JsonNullValueInput | InputJsonValue
    specifications: JsonNullValueInput | InputJsonValue
    description?: string | null
    videos?: VehicleCreatevideosInput | string[]
    model3dUrl?: string | null
    thumbnailUrl: string
    status?: $Enums.VehicleStatus
    availability: string
    featured?: boolean
    stockCount?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutVehiclesInput
    inquiries?: InquiryCreateNestedManyWithoutVehicleInput
    testDrives?: TestDriveCreateNestedManyWithoutVehicleInput
    savedBy?: SavedVehicleCreateNestedManyWithoutVehicleInput
    configurations?: ConfigurationCreateNestedManyWithoutVehicleInput
    branchInventory?: BranchInventoryCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutImagesInput = {
    id?: string
    slug: string
    brand: string
    model: string
    year: number
    variant?: string | null
    cashPrice: Decimal | DecimalJsLike | number | string
    downPayment: Decimal | DecimalJsLike | number | string
    monthlyPayment: Decimal | DecimalJsLike | number | string
    leaseTerm: number
    transmission: string
    fuelType: string
    engineSize?: string | null
    horsepower?: number | null
    seatingCapacity: number
    cargoSpace?: string | null
    features: JsonNullValueInput | InputJsonValue
    specifications: JsonNullValueInput | InputJsonValue
    description?: string | null
    videos?: VehicleCreatevideosInput | string[]
    model3dUrl?: string | null
    thumbnailUrl: string
    status?: $Enums.VehicleStatus
    availability: string
    featured?: boolean
    stockCount?: number
    metaTitle?: string | null
    metaDescription?: string | null
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inquiries?: InquiryUncheckedCreateNestedManyWithoutVehicleInput
    testDrives?: TestDriveUncheckedCreateNestedManyWithoutVehicleInput
    savedBy?: SavedVehicleUncheckedCreateNestedManyWithoutVehicleInput
    configurations?: ConfigurationUncheckedCreateNestedManyWithoutVehicleInput
    branchInventory?: BranchInventoryUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutImagesInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutImagesInput, VehicleUncheckedCreateWithoutImagesInput>
  }

  export type VehicleUpsertWithoutImagesInput = {
    update: XOR<VehicleUpdateWithoutImagesInput, VehicleUncheckedUpdateWithoutImagesInput>
    create: XOR<VehicleCreateWithoutImagesInput, VehicleUncheckedCreateWithoutImagesInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutImagesInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutImagesInput, VehicleUncheckedUpdateWithoutImagesInput>
  }

  export type VehicleUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    cashPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    engineSize?: NullableStringFieldUpdateOperationsInput | string | null
    horsepower?: NullableIntFieldUpdateOperationsInput | number | null
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    cargoSpace?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    specifications?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VehicleUpdatevideosInput | string[]
    model3dUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    availability?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutVehiclesNestedInput
    inquiries?: InquiryUpdateManyWithoutVehicleNestedInput
    testDrives?: TestDriveUpdateManyWithoutVehicleNestedInput
    savedBy?: SavedVehicleUpdateManyWithoutVehicleNestedInput
    configurations?: ConfigurationUpdateManyWithoutVehicleNestedInput
    branchInventory?: BranchInventoryUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    cashPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    engineSize?: NullableStringFieldUpdateOperationsInput | string | null
    horsepower?: NullableIntFieldUpdateOperationsInput | number | null
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    cargoSpace?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    specifications?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VehicleUpdatevideosInput | string[]
    model3dUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    availability?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inquiries?: InquiryUncheckedUpdateManyWithoutVehicleNestedInput
    testDrives?: TestDriveUncheckedUpdateManyWithoutVehicleNestedInput
    savedBy?: SavedVehicleUncheckedUpdateManyWithoutVehicleNestedInput
    configurations?: ConfigurationUncheckedUpdateManyWithoutVehicleNestedInput
    branchInventory?: BranchInventoryUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleCreateWithoutCategoryInput = {
    id?: string
    slug: string
    brand: string
    model: string
    year: number
    variant?: string | null
    cashPrice: Decimal | DecimalJsLike | number | string
    downPayment: Decimal | DecimalJsLike | number | string
    monthlyPayment: Decimal | DecimalJsLike | number | string
    leaseTerm: number
    transmission: string
    fuelType: string
    engineSize?: string | null
    horsepower?: number | null
    seatingCapacity: number
    cargoSpace?: string | null
    features: JsonNullValueInput | InputJsonValue
    specifications: JsonNullValueInput | InputJsonValue
    description?: string | null
    videos?: VehicleCreatevideosInput | string[]
    model3dUrl?: string | null
    thumbnailUrl: string
    status?: $Enums.VehicleStatus
    availability: string
    featured?: boolean
    stockCount?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VehicleImageCreateNestedManyWithoutVehicleInput
    inquiries?: InquiryCreateNestedManyWithoutVehicleInput
    testDrives?: TestDriveCreateNestedManyWithoutVehicleInput
    savedBy?: SavedVehicleCreateNestedManyWithoutVehicleInput
    configurations?: ConfigurationCreateNestedManyWithoutVehicleInput
    branchInventory?: BranchInventoryCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutCategoryInput = {
    id?: string
    slug: string
    brand: string
    model: string
    year: number
    variant?: string | null
    cashPrice: Decimal | DecimalJsLike | number | string
    downPayment: Decimal | DecimalJsLike | number | string
    monthlyPayment: Decimal | DecimalJsLike | number | string
    leaseTerm: number
    transmission: string
    fuelType: string
    engineSize?: string | null
    horsepower?: number | null
    seatingCapacity: number
    cargoSpace?: string | null
    features: JsonNullValueInput | InputJsonValue
    specifications: JsonNullValueInput | InputJsonValue
    description?: string | null
    videos?: VehicleCreatevideosInput | string[]
    model3dUrl?: string | null
    thumbnailUrl: string
    status?: $Enums.VehicleStatus
    availability: string
    featured?: boolean
    stockCount?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VehicleImageUncheckedCreateNestedManyWithoutVehicleInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutVehicleInput
    testDrives?: TestDriveUncheckedCreateNestedManyWithoutVehicleInput
    savedBy?: SavedVehicleUncheckedCreateNestedManyWithoutVehicleInput
    configurations?: ConfigurationUncheckedCreateNestedManyWithoutVehicleInput
    branchInventory?: BranchInventoryUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutCategoryInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutCategoryInput, VehicleUncheckedCreateWithoutCategoryInput>
  }

  export type VehicleCreateManyCategoryInputEnvelope = {
    data: VehicleCreateManyCategoryInput | VehicleCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type VehicleUpsertWithWhereUniqueWithoutCategoryInput = {
    where: VehicleWhereUniqueInput
    update: XOR<VehicleUpdateWithoutCategoryInput, VehicleUncheckedUpdateWithoutCategoryInput>
    create: XOR<VehicleCreateWithoutCategoryInput, VehicleUncheckedCreateWithoutCategoryInput>
  }

  export type VehicleUpdateWithWhereUniqueWithoutCategoryInput = {
    where: VehicleWhereUniqueInput
    data: XOR<VehicleUpdateWithoutCategoryInput, VehicleUncheckedUpdateWithoutCategoryInput>
  }

  export type VehicleUpdateManyWithWhereWithoutCategoryInput = {
    where: VehicleScalarWhereInput
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyWithoutCategoryInput>
  }

  export type VehicleScalarWhereInput = {
    AND?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
    OR?: VehicleScalarWhereInput[]
    NOT?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
    id?: StringFilter<"Vehicle"> | string
    slug?: StringFilter<"Vehicle"> | string
    brand?: StringFilter<"Vehicle"> | string
    model?: StringFilter<"Vehicle"> | string
    year?: IntFilter<"Vehicle"> | number
    variant?: StringNullableFilter<"Vehicle"> | string | null
    cashPrice?: DecimalFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFilter<"Vehicle"> | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFilter<"Vehicle"> | number
    transmission?: StringFilter<"Vehicle"> | string
    fuelType?: StringFilter<"Vehicle"> | string
    engineSize?: StringNullableFilter<"Vehicle"> | string | null
    horsepower?: IntNullableFilter<"Vehicle"> | number | null
    seatingCapacity?: IntFilter<"Vehicle"> | number
    cargoSpace?: StringNullableFilter<"Vehicle"> | string | null
    features?: JsonFilter<"Vehicle">
    specifications?: JsonFilter<"Vehicle">
    description?: StringNullableFilter<"Vehicle"> | string | null
    videos?: StringNullableListFilter<"Vehicle">
    model3dUrl?: StringNullableFilter<"Vehicle"> | string | null
    thumbnailUrl?: StringFilter<"Vehicle"> | string
    status?: EnumVehicleStatusFilter<"Vehicle"> | $Enums.VehicleStatus
    availability?: StringFilter<"Vehicle"> | string
    featured?: BoolFilter<"Vehicle"> | boolean
    stockCount?: IntFilter<"Vehicle"> | number
    metaTitle?: StringNullableFilter<"Vehicle"> | string | null
    metaDescription?: StringNullableFilter<"Vehicle"> | string | null
    categoryId?: StringFilter<"Vehicle"> | string
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string
  }

  export type SavedVehicleCreateWithoutUserInput = {
    id?: string
    notes?: string | null
    createdAt?: Date | string
    vehicle: VehicleCreateNestedOneWithoutSavedByInput
  }

  export type SavedVehicleUncheckedCreateWithoutUserInput = {
    id?: string
    vehicleId: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type SavedVehicleCreateOrConnectWithoutUserInput = {
    where: SavedVehicleWhereUniqueInput
    create: XOR<SavedVehicleCreateWithoutUserInput, SavedVehicleUncheckedCreateWithoutUserInput>
  }

  export type SavedVehicleCreateManyUserInputEnvelope = {
    data: SavedVehicleCreateManyUserInput | SavedVehicleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConfigurationCreateWithoutUserInput = {
    id?: string
    color: string
    colorHex: string
    wheels?: string | null
    interior?: string | null
    packages: JsonNullValueInput | InputJsonValue
    accessories: JsonNullValueInput | InputJsonValue
    totalPrice: Decimal | DecimalJsLike | number | string
    shared?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle: VehicleCreateNestedOneWithoutConfigurationsInput
  }

  export type ConfigurationUncheckedCreateWithoutUserInput = {
    id?: string
    vehicleId: string
    color: string
    colorHex: string
    wheels?: string | null
    interior?: string | null
    packages: JsonNullValueInput | InputJsonValue
    accessories: JsonNullValueInput | InputJsonValue
    totalPrice: Decimal | DecimalJsLike | number | string
    shared?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigurationCreateOrConnectWithoutUserInput = {
    where: ConfigurationWhereUniqueInput
    create: XOR<ConfigurationCreateWithoutUserInput, ConfigurationUncheckedCreateWithoutUserInput>
  }

  export type ConfigurationCreateManyUserInputEnvelope = {
    data: ConfigurationCreateManyUserInput | ConfigurationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InquiryCreateWithoutUserInput = {
    id?: string
    type: $Enums.InquiryType
    firstName: string
    lastName: string
    email: string
    phone: string
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    assignedTo?: string | null
    response?: string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle?: VehicleCreateNestedOneWithoutInquiriesInput
  }

  export type InquiryUncheckedCreateWithoutUserInput = {
    id?: string
    vehicleId?: string | null
    type: $Enums.InquiryType
    firstName: string
    lastName: string
    email: string
    phone: string
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    assignedTo?: string | null
    response?: string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InquiryCreateOrConnectWithoutUserInput = {
    where: InquiryWhereUniqueInput
    create: XOR<InquiryCreateWithoutUserInput, InquiryUncheckedCreateWithoutUserInput>
  }

  export type InquiryCreateManyUserInputEnvelope = {
    data: InquiryCreateManyUserInput | InquiryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TestDriveCreateWithoutUserInput = {
    id?: string
    preferredDate: Date | string
    preferredTime: string
    location: string
    firstName: string
    lastName: string
    email: string
    phone: string
    status?: $Enums.BookingStatus
    notes?: string | null
    adminNotes?: string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle: VehicleCreateNestedOneWithoutTestDrivesInput
  }

  export type TestDriveUncheckedCreateWithoutUserInput = {
    id?: string
    vehicleId: string
    preferredDate: Date | string
    preferredTime: string
    location: string
    firstName: string
    lastName: string
    email: string
    phone: string
    status?: $Enums.BookingStatus
    notes?: string | null
    adminNotes?: string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestDriveCreateOrConnectWithoutUserInput = {
    where: TestDriveWhereUniqueInput
    create: XOR<TestDriveCreateWithoutUserInput, TestDriveUncheckedCreateWithoutUserInput>
  }

  export type TestDriveCreateManyUserInputEnvelope = {
    data: TestDriveCreateManyUserInput | TestDriveCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SavedVehicleUpsertWithWhereUniqueWithoutUserInput = {
    where: SavedVehicleWhereUniqueInput
    update: XOR<SavedVehicleUpdateWithoutUserInput, SavedVehicleUncheckedUpdateWithoutUserInput>
    create: XOR<SavedVehicleCreateWithoutUserInput, SavedVehicleUncheckedCreateWithoutUserInput>
  }

  export type SavedVehicleUpdateWithWhereUniqueWithoutUserInput = {
    where: SavedVehicleWhereUniqueInput
    data: XOR<SavedVehicleUpdateWithoutUserInput, SavedVehicleUncheckedUpdateWithoutUserInput>
  }

  export type SavedVehicleUpdateManyWithWhereWithoutUserInput = {
    where: SavedVehicleScalarWhereInput
    data: XOR<SavedVehicleUpdateManyMutationInput, SavedVehicleUncheckedUpdateManyWithoutUserInput>
  }

  export type ConfigurationUpsertWithWhereUniqueWithoutUserInput = {
    where: ConfigurationWhereUniqueInput
    update: XOR<ConfigurationUpdateWithoutUserInput, ConfigurationUncheckedUpdateWithoutUserInput>
    create: XOR<ConfigurationCreateWithoutUserInput, ConfigurationUncheckedCreateWithoutUserInput>
  }

  export type ConfigurationUpdateWithWhereUniqueWithoutUserInput = {
    where: ConfigurationWhereUniqueInput
    data: XOR<ConfigurationUpdateWithoutUserInput, ConfigurationUncheckedUpdateWithoutUserInput>
  }

  export type ConfigurationUpdateManyWithWhereWithoutUserInput = {
    where: ConfigurationScalarWhereInput
    data: XOR<ConfigurationUpdateManyMutationInput, ConfigurationUncheckedUpdateManyWithoutUserInput>
  }

  export type InquiryUpsertWithWhereUniqueWithoutUserInput = {
    where: InquiryWhereUniqueInput
    update: XOR<InquiryUpdateWithoutUserInput, InquiryUncheckedUpdateWithoutUserInput>
    create: XOR<InquiryCreateWithoutUserInput, InquiryUncheckedCreateWithoutUserInput>
  }

  export type InquiryUpdateWithWhereUniqueWithoutUserInput = {
    where: InquiryWhereUniqueInput
    data: XOR<InquiryUpdateWithoutUserInput, InquiryUncheckedUpdateWithoutUserInput>
  }

  export type InquiryUpdateManyWithWhereWithoutUserInput = {
    where: InquiryScalarWhereInput
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyWithoutUserInput>
  }

  export type TestDriveUpsertWithWhereUniqueWithoutUserInput = {
    where: TestDriveWhereUniqueInput
    update: XOR<TestDriveUpdateWithoutUserInput, TestDriveUncheckedUpdateWithoutUserInput>
    create: XOR<TestDriveCreateWithoutUserInput, TestDriveUncheckedCreateWithoutUserInput>
  }

  export type TestDriveUpdateWithWhereUniqueWithoutUserInput = {
    where: TestDriveWhereUniqueInput
    data: XOR<TestDriveUpdateWithoutUserInput, TestDriveUncheckedUpdateWithoutUserInput>
  }

  export type TestDriveUpdateManyWithWhereWithoutUserInput = {
    where: TestDriveScalarWhereInput
    data: XOR<TestDriveUpdateManyMutationInput, TestDriveUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCreateWithoutSavedVehiclesInput = {
    id?: string
    clerkId: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    avatar?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    configurations?: ConfigurationCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    testDrives?: TestDriveCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSavedVehiclesInput = {
    id?: string
    clerkId: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    avatar?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    configurations?: ConfigurationUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    testDrives?: TestDriveUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSavedVehiclesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSavedVehiclesInput, UserUncheckedCreateWithoutSavedVehiclesInput>
  }

  export type VehicleCreateWithoutSavedByInput = {
    id?: string
    slug: string
    brand: string
    model: string
    year: number
    variant?: string | null
    cashPrice: Decimal | DecimalJsLike | number | string
    downPayment: Decimal | DecimalJsLike | number | string
    monthlyPayment: Decimal | DecimalJsLike | number | string
    leaseTerm: number
    transmission: string
    fuelType: string
    engineSize?: string | null
    horsepower?: number | null
    seatingCapacity: number
    cargoSpace?: string | null
    features: JsonNullValueInput | InputJsonValue
    specifications: JsonNullValueInput | InputJsonValue
    description?: string | null
    videos?: VehicleCreatevideosInput | string[]
    model3dUrl?: string | null
    thumbnailUrl: string
    status?: $Enums.VehicleStatus
    availability: string
    featured?: boolean
    stockCount?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VehicleImageCreateNestedManyWithoutVehicleInput
    category: CategoryCreateNestedOneWithoutVehiclesInput
    inquiries?: InquiryCreateNestedManyWithoutVehicleInput
    testDrives?: TestDriveCreateNestedManyWithoutVehicleInput
    configurations?: ConfigurationCreateNestedManyWithoutVehicleInput
    branchInventory?: BranchInventoryCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutSavedByInput = {
    id?: string
    slug: string
    brand: string
    model: string
    year: number
    variant?: string | null
    cashPrice: Decimal | DecimalJsLike | number | string
    downPayment: Decimal | DecimalJsLike | number | string
    monthlyPayment: Decimal | DecimalJsLike | number | string
    leaseTerm: number
    transmission: string
    fuelType: string
    engineSize?: string | null
    horsepower?: number | null
    seatingCapacity: number
    cargoSpace?: string | null
    features: JsonNullValueInput | InputJsonValue
    specifications: JsonNullValueInput | InputJsonValue
    description?: string | null
    videos?: VehicleCreatevideosInput | string[]
    model3dUrl?: string | null
    thumbnailUrl: string
    status?: $Enums.VehicleStatus
    availability: string
    featured?: boolean
    stockCount?: number
    metaTitle?: string | null
    metaDescription?: string | null
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VehicleImageUncheckedCreateNestedManyWithoutVehicleInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutVehicleInput
    testDrives?: TestDriveUncheckedCreateNestedManyWithoutVehicleInput
    configurations?: ConfigurationUncheckedCreateNestedManyWithoutVehicleInput
    branchInventory?: BranchInventoryUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutSavedByInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutSavedByInput, VehicleUncheckedCreateWithoutSavedByInput>
  }

  export type UserUpsertWithoutSavedVehiclesInput = {
    update: XOR<UserUpdateWithoutSavedVehiclesInput, UserUncheckedUpdateWithoutSavedVehiclesInput>
    create: XOR<UserCreateWithoutSavedVehiclesInput, UserUncheckedCreateWithoutSavedVehiclesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSavedVehiclesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSavedVehiclesInput, UserUncheckedUpdateWithoutSavedVehiclesInput>
  }

  export type UserUpdateWithoutSavedVehiclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    configurations?: ConfigurationUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    testDrives?: TestDriveUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSavedVehiclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    configurations?: ConfigurationUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    testDrives?: TestDriveUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VehicleUpsertWithoutSavedByInput = {
    update: XOR<VehicleUpdateWithoutSavedByInput, VehicleUncheckedUpdateWithoutSavedByInput>
    create: XOR<VehicleCreateWithoutSavedByInput, VehicleUncheckedCreateWithoutSavedByInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutSavedByInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutSavedByInput, VehicleUncheckedUpdateWithoutSavedByInput>
  }

  export type VehicleUpdateWithoutSavedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    cashPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    engineSize?: NullableStringFieldUpdateOperationsInput | string | null
    horsepower?: NullableIntFieldUpdateOperationsInput | number | null
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    cargoSpace?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    specifications?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VehicleUpdatevideosInput | string[]
    model3dUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    availability?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VehicleImageUpdateManyWithoutVehicleNestedInput
    category?: CategoryUpdateOneRequiredWithoutVehiclesNestedInput
    inquiries?: InquiryUpdateManyWithoutVehicleNestedInput
    testDrives?: TestDriveUpdateManyWithoutVehicleNestedInput
    configurations?: ConfigurationUpdateManyWithoutVehicleNestedInput
    branchInventory?: BranchInventoryUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutSavedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    cashPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    engineSize?: NullableStringFieldUpdateOperationsInput | string | null
    horsepower?: NullableIntFieldUpdateOperationsInput | number | null
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    cargoSpace?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    specifications?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VehicleUpdatevideosInput | string[]
    model3dUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    availability?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VehicleImageUncheckedUpdateManyWithoutVehicleNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutVehicleNestedInput
    testDrives?: TestDriveUncheckedUpdateManyWithoutVehicleNestedInput
    configurations?: ConfigurationUncheckedUpdateManyWithoutVehicleNestedInput
    branchInventory?: BranchInventoryUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type UserCreateWithoutConfigurationsInput = {
    id?: string
    clerkId: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    avatar?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    savedVehicles?: SavedVehicleCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    testDrives?: TestDriveCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConfigurationsInput = {
    id?: string
    clerkId: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    avatar?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    savedVehicles?: SavedVehicleUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    testDrives?: TestDriveUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConfigurationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConfigurationsInput, UserUncheckedCreateWithoutConfigurationsInput>
  }

  export type VehicleCreateWithoutConfigurationsInput = {
    id?: string
    slug: string
    brand: string
    model: string
    year: number
    variant?: string | null
    cashPrice: Decimal | DecimalJsLike | number | string
    downPayment: Decimal | DecimalJsLike | number | string
    monthlyPayment: Decimal | DecimalJsLike | number | string
    leaseTerm: number
    transmission: string
    fuelType: string
    engineSize?: string | null
    horsepower?: number | null
    seatingCapacity: number
    cargoSpace?: string | null
    features: JsonNullValueInput | InputJsonValue
    specifications: JsonNullValueInput | InputJsonValue
    description?: string | null
    videos?: VehicleCreatevideosInput | string[]
    model3dUrl?: string | null
    thumbnailUrl: string
    status?: $Enums.VehicleStatus
    availability: string
    featured?: boolean
    stockCount?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VehicleImageCreateNestedManyWithoutVehicleInput
    category: CategoryCreateNestedOneWithoutVehiclesInput
    inquiries?: InquiryCreateNestedManyWithoutVehicleInput
    testDrives?: TestDriveCreateNestedManyWithoutVehicleInput
    savedBy?: SavedVehicleCreateNestedManyWithoutVehicleInput
    branchInventory?: BranchInventoryCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutConfigurationsInput = {
    id?: string
    slug: string
    brand: string
    model: string
    year: number
    variant?: string | null
    cashPrice: Decimal | DecimalJsLike | number | string
    downPayment: Decimal | DecimalJsLike | number | string
    monthlyPayment: Decimal | DecimalJsLike | number | string
    leaseTerm: number
    transmission: string
    fuelType: string
    engineSize?: string | null
    horsepower?: number | null
    seatingCapacity: number
    cargoSpace?: string | null
    features: JsonNullValueInput | InputJsonValue
    specifications: JsonNullValueInput | InputJsonValue
    description?: string | null
    videos?: VehicleCreatevideosInput | string[]
    model3dUrl?: string | null
    thumbnailUrl: string
    status?: $Enums.VehicleStatus
    availability: string
    featured?: boolean
    stockCount?: number
    metaTitle?: string | null
    metaDescription?: string | null
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VehicleImageUncheckedCreateNestedManyWithoutVehicleInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutVehicleInput
    testDrives?: TestDriveUncheckedCreateNestedManyWithoutVehicleInput
    savedBy?: SavedVehicleUncheckedCreateNestedManyWithoutVehicleInput
    branchInventory?: BranchInventoryUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutConfigurationsInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutConfigurationsInput, VehicleUncheckedCreateWithoutConfigurationsInput>
  }

  export type UserUpsertWithoutConfigurationsInput = {
    update: XOR<UserUpdateWithoutConfigurationsInput, UserUncheckedUpdateWithoutConfigurationsInput>
    create: XOR<UserCreateWithoutConfigurationsInput, UserUncheckedCreateWithoutConfigurationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConfigurationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConfigurationsInput, UserUncheckedUpdateWithoutConfigurationsInput>
  }

  export type UserUpdateWithoutConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    savedVehicles?: SavedVehicleUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    testDrives?: TestDriveUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    savedVehicles?: SavedVehicleUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    testDrives?: TestDriveUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VehicleUpsertWithoutConfigurationsInput = {
    update: XOR<VehicleUpdateWithoutConfigurationsInput, VehicleUncheckedUpdateWithoutConfigurationsInput>
    create: XOR<VehicleCreateWithoutConfigurationsInput, VehicleUncheckedCreateWithoutConfigurationsInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutConfigurationsInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutConfigurationsInput, VehicleUncheckedUpdateWithoutConfigurationsInput>
  }

  export type VehicleUpdateWithoutConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    cashPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    engineSize?: NullableStringFieldUpdateOperationsInput | string | null
    horsepower?: NullableIntFieldUpdateOperationsInput | number | null
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    cargoSpace?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    specifications?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VehicleUpdatevideosInput | string[]
    model3dUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    availability?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VehicleImageUpdateManyWithoutVehicleNestedInput
    category?: CategoryUpdateOneRequiredWithoutVehiclesNestedInput
    inquiries?: InquiryUpdateManyWithoutVehicleNestedInput
    testDrives?: TestDriveUpdateManyWithoutVehicleNestedInput
    savedBy?: SavedVehicleUpdateManyWithoutVehicleNestedInput
    branchInventory?: BranchInventoryUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    cashPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    engineSize?: NullableStringFieldUpdateOperationsInput | string | null
    horsepower?: NullableIntFieldUpdateOperationsInput | number | null
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    cargoSpace?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    specifications?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VehicleUpdatevideosInput | string[]
    model3dUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    availability?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VehicleImageUncheckedUpdateManyWithoutVehicleNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutVehicleNestedInput
    testDrives?: TestDriveUncheckedUpdateManyWithoutVehicleNestedInput
    savedBy?: SavedVehicleUncheckedUpdateManyWithoutVehicleNestedInput
    branchInventory?: BranchInventoryUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type UserCreateWithoutTestDrivesInput = {
    id?: string
    clerkId: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    avatar?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    savedVehicles?: SavedVehicleCreateNestedManyWithoutUserInput
    configurations?: ConfigurationCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTestDrivesInput = {
    id?: string
    clerkId: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    avatar?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    savedVehicles?: SavedVehicleUncheckedCreateNestedManyWithoutUserInput
    configurations?: ConfigurationUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTestDrivesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTestDrivesInput, UserUncheckedCreateWithoutTestDrivesInput>
  }

  export type VehicleCreateWithoutTestDrivesInput = {
    id?: string
    slug: string
    brand: string
    model: string
    year: number
    variant?: string | null
    cashPrice: Decimal | DecimalJsLike | number | string
    downPayment: Decimal | DecimalJsLike | number | string
    monthlyPayment: Decimal | DecimalJsLike | number | string
    leaseTerm: number
    transmission: string
    fuelType: string
    engineSize?: string | null
    horsepower?: number | null
    seatingCapacity: number
    cargoSpace?: string | null
    features: JsonNullValueInput | InputJsonValue
    specifications: JsonNullValueInput | InputJsonValue
    description?: string | null
    videos?: VehicleCreatevideosInput | string[]
    model3dUrl?: string | null
    thumbnailUrl: string
    status?: $Enums.VehicleStatus
    availability: string
    featured?: boolean
    stockCount?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VehicleImageCreateNestedManyWithoutVehicleInput
    category: CategoryCreateNestedOneWithoutVehiclesInput
    inquiries?: InquiryCreateNestedManyWithoutVehicleInput
    savedBy?: SavedVehicleCreateNestedManyWithoutVehicleInput
    configurations?: ConfigurationCreateNestedManyWithoutVehicleInput
    branchInventory?: BranchInventoryCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutTestDrivesInput = {
    id?: string
    slug: string
    brand: string
    model: string
    year: number
    variant?: string | null
    cashPrice: Decimal | DecimalJsLike | number | string
    downPayment: Decimal | DecimalJsLike | number | string
    monthlyPayment: Decimal | DecimalJsLike | number | string
    leaseTerm: number
    transmission: string
    fuelType: string
    engineSize?: string | null
    horsepower?: number | null
    seatingCapacity: number
    cargoSpace?: string | null
    features: JsonNullValueInput | InputJsonValue
    specifications: JsonNullValueInput | InputJsonValue
    description?: string | null
    videos?: VehicleCreatevideosInput | string[]
    model3dUrl?: string | null
    thumbnailUrl: string
    status?: $Enums.VehicleStatus
    availability: string
    featured?: boolean
    stockCount?: number
    metaTitle?: string | null
    metaDescription?: string | null
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VehicleImageUncheckedCreateNestedManyWithoutVehicleInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutVehicleInput
    savedBy?: SavedVehicleUncheckedCreateNestedManyWithoutVehicleInput
    configurations?: ConfigurationUncheckedCreateNestedManyWithoutVehicleInput
    branchInventory?: BranchInventoryUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutTestDrivesInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutTestDrivesInput, VehicleUncheckedCreateWithoutTestDrivesInput>
  }

  export type UserUpsertWithoutTestDrivesInput = {
    update: XOR<UserUpdateWithoutTestDrivesInput, UserUncheckedUpdateWithoutTestDrivesInput>
    create: XOR<UserCreateWithoutTestDrivesInput, UserUncheckedCreateWithoutTestDrivesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTestDrivesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTestDrivesInput, UserUncheckedUpdateWithoutTestDrivesInput>
  }

  export type UserUpdateWithoutTestDrivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    savedVehicles?: SavedVehicleUpdateManyWithoutUserNestedInput
    configurations?: ConfigurationUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTestDrivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    savedVehicles?: SavedVehicleUncheckedUpdateManyWithoutUserNestedInput
    configurations?: ConfigurationUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VehicleUpsertWithoutTestDrivesInput = {
    update: XOR<VehicleUpdateWithoutTestDrivesInput, VehicleUncheckedUpdateWithoutTestDrivesInput>
    create: XOR<VehicleCreateWithoutTestDrivesInput, VehicleUncheckedCreateWithoutTestDrivesInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutTestDrivesInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutTestDrivesInput, VehicleUncheckedUpdateWithoutTestDrivesInput>
  }

  export type VehicleUpdateWithoutTestDrivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    cashPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    engineSize?: NullableStringFieldUpdateOperationsInput | string | null
    horsepower?: NullableIntFieldUpdateOperationsInput | number | null
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    cargoSpace?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    specifications?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VehicleUpdatevideosInput | string[]
    model3dUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    availability?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VehicleImageUpdateManyWithoutVehicleNestedInput
    category?: CategoryUpdateOneRequiredWithoutVehiclesNestedInput
    inquiries?: InquiryUpdateManyWithoutVehicleNestedInput
    savedBy?: SavedVehicleUpdateManyWithoutVehicleNestedInput
    configurations?: ConfigurationUpdateManyWithoutVehicleNestedInput
    branchInventory?: BranchInventoryUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutTestDrivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    cashPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    engineSize?: NullableStringFieldUpdateOperationsInput | string | null
    horsepower?: NullableIntFieldUpdateOperationsInput | number | null
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    cargoSpace?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    specifications?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VehicleUpdatevideosInput | string[]
    model3dUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    availability?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VehicleImageUncheckedUpdateManyWithoutVehicleNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutVehicleNestedInput
    savedBy?: SavedVehicleUncheckedUpdateManyWithoutVehicleNestedInput
    configurations?: ConfigurationUncheckedUpdateManyWithoutVehicleNestedInput
    branchInventory?: BranchInventoryUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type UserCreateWithoutInquiriesInput = {
    id?: string
    clerkId: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    avatar?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    savedVehicles?: SavedVehicleCreateNestedManyWithoutUserInput
    configurations?: ConfigurationCreateNestedManyWithoutUserInput
    testDrives?: TestDriveCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInquiriesInput = {
    id?: string
    clerkId: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    avatar?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    savedVehicles?: SavedVehicleUncheckedCreateNestedManyWithoutUserInput
    configurations?: ConfigurationUncheckedCreateNestedManyWithoutUserInput
    testDrives?: TestDriveUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInquiriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInquiriesInput, UserUncheckedCreateWithoutInquiriesInput>
  }

  export type VehicleCreateWithoutInquiriesInput = {
    id?: string
    slug: string
    brand: string
    model: string
    year: number
    variant?: string | null
    cashPrice: Decimal | DecimalJsLike | number | string
    downPayment: Decimal | DecimalJsLike | number | string
    monthlyPayment: Decimal | DecimalJsLike | number | string
    leaseTerm: number
    transmission: string
    fuelType: string
    engineSize?: string | null
    horsepower?: number | null
    seatingCapacity: number
    cargoSpace?: string | null
    features: JsonNullValueInput | InputJsonValue
    specifications: JsonNullValueInput | InputJsonValue
    description?: string | null
    videos?: VehicleCreatevideosInput | string[]
    model3dUrl?: string | null
    thumbnailUrl: string
    status?: $Enums.VehicleStatus
    availability: string
    featured?: boolean
    stockCount?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VehicleImageCreateNestedManyWithoutVehicleInput
    category: CategoryCreateNestedOneWithoutVehiclesInput
    testDrives?: TestDriveCreateNestedManyWithoutVehicleInput
    savedBy?: SavedVehicleCreateNestedManyWithoutVehicleInput
    configurations?: ConfigurationCreateNestedManyWithoutVehicleInput
    branchInventory?: BranchInventoryCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutInquiriesInput = {
    id?: string
    slug: string
    brand: string
    model: string
    year: number
    variant?: string | null
    cashPrice: Decimal | DecimalJsLike | number | string
    downPayment: Decimal | DecimalJsLike | number | string
    monthlyPayment: Decimal | DecimalJsLike | number | string
    leaseTerm: number
    transmission: string
    fuelType: string
    engineSize?: string | null
    horsepower?: number | null
    seatingCapacity: number
    cargoSpace?: string | null
    features: JsonNullValueInput | InputJsonValue
    specifications: JsonNullValueInput | InputJsonValue
    description?: string | null
    videos?: VehicleCreatevideosInput | string[]
    model3dUrl?: string | null
    thumbnailUrl: string
    status?: $Enums.VehicleStatus
    availability: string
    featured?: boolean
    stockCount?: number
    metaTitle?: string | null
    metaDescription?: string | null
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VehicleImageUncheckedCreateNestedManyWithoutVehicleInput
    testDrives?: TestDriveUncheckedCreateNestedManyWithoutVehicleInput
    savedBy?: SavedVehicleUncheckedCreateNestedManyWithoutVehicleInput
    configurations?: ConfigurationUncheckedCreateNestedManyWithoutVehicleInput
    branchInventory?: BranchInventoryUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutInquiriesInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutInquiriesInput, VehicleUncheckedCreateWithoutInquiriesInput>
  }

  export type UserUpsertWithoutInquiriesInput = {
    update: XOR<UserUpdateWithoutInquiriesInput, UserUncheckedUpdateWithoutInquiriesInput>
    create: XOR<UserCreateWithoutInquiriesInput, UserUncheckedCreateWithoutInquiriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInquiriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInquiriesInput, UserUncheckedUpdateWithoutInquiriesInput>
  }

  export type UserUpdateWithoutInquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    savedVehicles?: SavedVehicleUpdateManyWithoutUserNestedInput
    configurations?: ConfigurationUpdateManyWithoutUserNestedInput
    testDrives?: TestDriveUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    savedVehicles?: SavedVehicleUncheckedUpdateManyWithoutUserNestedInput
    configurations?: ConfigurationUncheckedUpdateManyWithoutUserNestedInput
    testDrives?: TestDriveUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VehicleUpsertWithoutInquiriesInput = {
    update: XOR<VehicleUpdateWithoutInquiriesInput, VehicleUncheckedUpdateWithoutInquiriesInput>
    create: XOR<VehicleCreateWithoutInquiriesInput, VehicleUncheckedCreateWithoutInquiriesInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutInquiriesInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutInquiriesInput, VehicleUncheckedUpdateWithoutInquiriesInput>
  }

  export type VehicleUpdateWithoutInquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    cashPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    engineSize?: NullableStringFieldUpdateOperationsInput | string | null
    horsepower?: NullableIntFieldUpdateOperationsInput | number | null
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    cargoSpace?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    specifications?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VehicleUpdatevideosInput | string[]
    model3dUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    availability?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VehicleImageUpdateManyWithoutVehicleNestedInput
    category?: CategoryUpdateOneRequiredWithoutVehiclesNestedInput
    testDrives?: TestDriveUpdateManyWithoutVehicleNestedInput
    savedBy?: SavedVehicleUpdateManyWithoutVehicleNestedInput
    configurations?: ConfigurationUpdateManyWithoutVehicleNestedInput
    branchInventory?: BranchInventoryUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutInquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    cashPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    engineSize?: NullableStringFieldUpdateOperationsInput | string | null
    horsepower?: NullableIntFieldUpdateOperationsInput | number | null
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    cargoSpace?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    specifications?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VehicleUpdatevideosInput | string[]
    model3dUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    availability?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VehicleImageUncheckedUpdateManyWithoutVehicleNestedInput
    testDrives?: TestDriveUncheckedUpdateManyWithoutVehicleNestedInput
    savedBy?: SavedVehicleUncheckedUpdateManyWithoutVehicleNestedInput
    configurations?: ConfigurationUncheckedUpdateManyWithoutVehicleNestedInput
    branchInventory?: BranchInventoryUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type BranchCreateManyDealershipInput = {
    id?: string
    name: string
    address: string
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUpdateWithoutDealershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: BranchInventoryUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutDealershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: BranchInventoryUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateManyWithoutDealershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchInventoryCreateManyBranchInput = {
    id?: string
    vehicleId: string
    stock?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchInventoryUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: VehicleUpdateOneRequiredWithoutBranchInventoryNestedInput
  }

  export type BranchInventoryUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchInventoryUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleImageCreateManyVehicleInput = {
    id?: string
    url: string
    alt: string
    type: string
    order?: number
  }

  export type InquiryCreateManyVehicleInput = {
    id?: string
    userId?: string | null
    type: $Enums.InquiryType
    firstName: string
    lastName: string
    email: string
    phone: string
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    assignedTo?: string | null
    response?: string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestDriveCreateManyVehicleInput = {
    id?: string
    userId: string
    preferredDate: Date | string
    preferredTime: string
    location: string
    firstName: string
    lastName: string
    email: string
    phone: string
    status?: $Enums.BookingStatus
    notes?: string | null
    adminNotes?: string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedVehicleCreateManyVehicleInput = {
    id?: string
    userId: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type ConfigurationCreateManyVehicleInput = {
    id?: string
    userId: string
    color: string
    colorHex: string
    wheels?: string | null
    interior?: string | null
    packages: JsonNullValueInput | InputJsonValue
    accessories: JsonNullValueInput | InputJsonValue
    totalPrice: Decimal | DecimalJsLike | number | string
    shared?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchInventoryCreateManyVehicleInput = {
    id?: string
    branchId: string
    stock?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleImageUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleImageUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleImageUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type InquiryUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutInquiriesNestedInput
  }

  export type InquiryUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestDriveUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTestDrivesNestedInput
  }

  export type TestDriveUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestDriveUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedVehicleUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSavedVehiclesNestedInput
  }

  export type SavedVehicleUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedVehicleUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    colorHex?: StringFieldUpdateOperationsInput | string
    wheels?: NullableStringFieldUpdateOperationsInput | string | null
    interior?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: JsonNullValueInput | InputJsonValue
    accessories?: JsonNullValueInput | InputJsonValue
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shared?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConfigurationsNestedInput
  }

  export type ConfigurationUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    colorHex?: StringFieldUpdateOperationsInput | string
    wheels?: NullableStringFieldUpdateOperationsInput | string | null
    interior?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: JsonNullValueInput | InputJsonValue
    accessories?: JsonNullValueInput | InputJsonValue
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shared?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    colorHex?: StringFieldUpdateOperationsInput | string
    wheels?: NullableStringFieldUpdateOperationsInput | string | null
    interior?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: JsonNullValueInput | InputJsonValue
    accessories?: JsonNullValueInput | InputJsonValue
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shared?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchInventoryUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type BranchInventoryUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchInventoryUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleCreateManyCategoryInput = {
    id?: string
    slug: string
    brand: string
    model: string
    year: number
    variant?: string | null
    cashPrice: Decimal | DecimalJsLike | number | string
    downPayment: Decimal | DecimalJsLike | number | string
    monthlyPayment: Decimal | DecimalJsLike | number | string
    leaseTerm: number
    transmission: string
    fuelType: string
    engineSize?: string | null
    horsepower?: number | null
    seatingCapacity: number
    cargoSpace?: string | null
    features: JsonNullValueInput | InputJsonValue
    specifications: JsonNullValueInput | InputJsonValue
    description?: string | null
    videos?: VehicleCreatevideosInput | string[]
    model3dUrl?: string | null
    thumbnailUrl: string
    status?: $Enums.VehicleStatus
    availability: string
    featured?: boolean
    stockCount?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    cashPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    engineSize?: NullableStringFieldUpdateOperationsInput | string | null
    horsepower?: NullableIntFieldUpdateOperationsInput | number | null
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    cargoSpace?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    specifications?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VehicleUpdatevideosInput | string[]
    model3dUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    availability?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VehicleImageUpdateManyWithoutVehicleNestedInput
    inquiries?: InquiryUpdateManyWithoutVehicleNestedInput
    testDrives?: TestDriveUpdateManyWithoutVehicleNestedInput
    savedBy?: SavedVehicleUpdateManyWithoutVehicleNestedInput
    configurations?: ConfigurationUpdateManyWithoutVehicleNestedInput
    branchInventory?: BranchInventoryUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    cashPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    engineSize?: NullableStringFieldUpdateOperationsInput | string | null
    horsepower?: NullableIntFieldUpdateOperationsInput | number | null
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    cargoSpace?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    specifications?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VehicleUpdatevideosInput | string[]
    model3dUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    availability?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VehicleImageUncheckedUpdateManyWithoutVehicleNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutVehicleNestedInput
    testDrives?: TestDriveUncheckedUpdateManyWithoutVehicleNestedInput
    savedBy?: SavedVehicleUncheckedUpdateManyWithoutVehicleNestedInput
    configurations?: ConfigurationUncheckedUpdateManyWithoutVehicleNestedInput
    branchInventory?: BranchInventoryUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    cashPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    downPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    monthlyPayment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leaseTerm?: IntFieldUpdateOperationsInput | number
    transmission?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    engineSize?: NullableStringFieldUpdateOperationsInput | string | null
    horsepower?: NullableIntFieldUpdateOperationsInput | number | null
    seatingCapacity?: IntFieldUpdateOperationsInput | number
    cargoSpace?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    specifications?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: VehicleUpdatevideosInput | string[]
    model3dUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    availability?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    stockCount?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedVehicleCreateManyUserInput = {
    id?: string
    vehicleId: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type ConfigurationCreateManyUserInput = {
    id?: string
    vehicleId: string
    color: string
    colorHex: string
    wheels?: string | null
    interior?: string | null
    packages: JsonNullValueInput | InputJsonValue
    accessories: JsonNullValueInput | InputJsonValue
    totalPrice: Decimal | DecimalJsLike | number | string
    shared?: boolean
    shareToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InquiryCreateManyUserInput = {
    id?: string
    vehicleId?: string | null
    type: $Enums.InquiryType
    firstName: string
    lastName: string
    email: string
    phone: string
    subject?: string | null
    message: string
    status?: $Enums.InquiryStatus
    assignedTo?: string | null
    response?: string | null
    respondedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestDriveCreateManyUserInput = {
    id?: string
    vehicleId: string
    preferredDate: Date | string
    preferredTime: string
    location: string
    firstName: string
    lastName: string
    email: string
    phone: string
    status?: $Enums.BookingStatus
    notes?: string | null
    adminNotes?: string | null
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedVehicleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: VehicleUpdateOneRequiredWithoutSavedByNestedInput
  }

  export type SavedVehicleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedVehicleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    colorHex?: StringFieldUpdateOperationsInput | string
    wheels?: NullableStringFieldUpdateOperationsInput | string | null
    interior?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: JsonNullValueInput | InputJsonValue
    accessories?: JsonNullValueInput | InputJsonValue
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shared?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: VehicleUpdateOneRequiredWithoutConfigurationsNestedInput
  }

  export type ConfigurationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    colorHex?: StringFieldUpdateOperationsInput | string
    wheels?: NullableStringFieldUpdateOperationsInput | string | null
    interior?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: JsonNullValueInput | InputJsonValue
    accessories?: JsonNullValueInput | InputJsonValue
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shared?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    colorHex?: StringFieldUpdateOperationsInput | string
    wheels?: NullableStringFieldUpdateOperationsInput | string | null
    interior?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: JsonNullValueInput | InputJsonValue
    accessories?: JsonNullValueInput | InputJsonValue
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shared?: BoolFieldUpdateOperationsInput | boolean
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: VehicleUpdateOneWithoutInquiriesNestedInput
  }

  export type InquiryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInquiryTypeFieldUpdateOperationsInput | $Enums.InquiryType
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestDriveUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: VehicleUpdateOneRequiredWithoutTestDrivesNestedInput
  }

  export type TestDriveUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestDriveUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    preferredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use DealershipCountOutputTypeDefaultArgs instead
     */
    export type DealershipCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DealershipCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchCountOutputTypeDefaultArgs instead
     */
    export type BranchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleCountOutputTypeDefaultArgs instead
     */
    export type VehicleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DealershipDefaultArgs instead
     */
    export type DealershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DealershipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchDefaultArgs instead
     */
    export type BranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchInventoryDefaultArgs instead
     */
    export type BranchInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchInventoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LoanRateDefaultArgs instead
     */
    export type LoanRateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LoanRateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleDefaultArgs instead
     */
    export type VehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleImageDefaultArgs instead
     */
    export type VehicleImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SavedVehicleDefaultArgs instead
     */
    export type SavedVehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SavedVehicleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConfigurationDefaultArgs instead
     */
    export type ConfigurationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConfigurationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestDriveDefaultArgs instead
     */
    export type TestDriveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestDriveDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InquiryDefaultArgs instead
     */
    export type InquiryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InquiryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FinancingApplicationDefaultArgs instead
     */
    export type FinancingApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FinancingApplicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TradeInDefaultArgs instead
     */
    export type TradeInArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TradeInDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromotionDefaultArgs instead
     */
    export type PromotionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromotionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}